{"ast":null,"code":"import '../helpers/fetch-polyfill.node.js';\nimport { serializeRequest } from './serializers/request/index.js';\nimport { serializeResponse } from './serializers/response/index.js';\nexport { serializeResponse as serializeRes };\n\n// Handles fetch-like syntax and the case where there is only one object passed-in\n// (which will have the URL as a property). Also serializes the response.\nexport default async function http(url, request = {}) {\n  if (typeof url === 'object') {\n    request = url;\n    url = request.url;\n  }\n  request.headers = request.headers || {};\n\n  // Serializes query, for convenience\n  // Should be the last thing we do, as its hard to mutate the URL with\n  // the search string, but much easier to manipulate the req.query object\n  request = serializeRequest(request);\n\n  // Newlines in header values cause weird error messages from `window.fetch`,\n  // so let's message them out.\n  // Context: https://stackoverflow.com/a/50709178\n  if (request.headers) {\n    Object.keys(request.headers).forEach(headerName => {\n      const value = request.headers[headerName];\n      if (typeof value === 'string') {\n        request.headers[headerName] = value.replace(/\\n+/g, ' ');\n      }\n    });\n  }\n\n  // Wait for the request interceptor, if it was provided\n  // WARNING: don't put anything between this and the request firing unless\n  // you have a good reason!\n  if (request.requestInterceptor) {\n    request = (await request.requestInterceptor(request)) || request;\n  }\n\n  /**\n   *  For content-type=multipart/form-data remove content-type from request before fetch,\n   *  so that correct one with `boundary` is set when request body is different from boundary encoded string.\n   */\n  const contentType = request.headers['content-type'] || request.headers['Content-Type'];\n  if (/multipart\\/form-data/i.test(contentType)) {\n    delete request.headers['content-type'];\n    delete request.headers['Content-Type'];\n  }\n\n  // eslint-disable-next-line no-undef\n  let res;\n  try {\n    res = await (request.userFetch || fetch)(request.url, request);\n    res = await serializeResponse(res, url, request);\n    if (request.responseInterceptor) {\n      res = (await request.responseInterceptor(res)) || res;\n    }\n  } catch (resError) {\n    if (!res) {\n      // res is completely absent, so we can't construct our own error\n      // so we'll just throw the error we got\n      throw resError;\n    }\n    const error = new Error(res.statusText || `response status is ${res.status}`);\n    error.status = res.status;\n    error.statusCode = res.status;\n    error.responseError = resError;\n    throw error;\n  }\n  if (!res.ok) {\n    const error = new Error(res.statusText || `response status is ${res.status}`);\n    error.status = res.status;\n    error.statusCode = res.status;\n    error.response = res;\n    throw error;\n  }\n  return res;\n}\n\n// Wrap a http function ( there are otherways to do this, consider this deprecated )\nexport function makeHttp(httpFn, preFetch, postFetch) {\n  postFetch = postFetch || (a => a);\n  preFetch = preFetch || (a => a);\n  return req => {\n    if (typeof req === 'string') {\n      req = {\n        url: req\n      };\n    }\n    req = serializeRequest(req);\n    req = preFetch(req);\n    return postFetch(httpFn(req));\n  };\n}","map":{"version":3,"names":["serializeRequest","serializeResponse","serializeRes","http","url","request","headers","Object","keys","forEach","headerName","value","replace","requestInterceptor","contentType","test","res","userFetch","fetch","responseInterceptor","resError","error","Error","statusText","status","statusCode","responseError","ok","response","makeHttp","httpFn","preFetch","postFetch","a","req"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/http/index.js"],"sourcesContent":["import '../helpers/fetch-polyfill.node.js';\nimport { serializeRequest } from './serializers/request/index.js';\nimport { serializeResponse } from './serializers/response/index.js';\nexport { serializeResponse as serializeRes };\n\n// Handles fetch-like syntax and the case where there is only one object passed-in\n// (which will have the URL as a property). Also serializes the response.\nexport default async function http(url, request = {}) {\n  if (typeof url === 'object') {\n    request = url;\n    url = request.url;\n  }\n  request.headers = request.headers || {};\n\n  // Serializes query, for convenience\n  // Should be the last thing we do, as its hard to mutate the URL with\n  // the search string, but much easier to manipulate the req.query object\n  request = serializeRequest(request);\n\n  // Newlines in header values cause weird error messages from `window.fetch`,\n  // so let's message them out.\n  // Context: https://stackoverflow.com/a/50709178\n  if (request.headers) {\n    Object.keys(request.headers).forEach(headerName => {\n      const value = request.headers[headerName];\n      if (typeof value === 'string') {\n        request.headers[headerName] = value.replace(/\\n+/g, ' ');\n      }\n    });\n  }\n\n  // Wait for the request interceptor, if it was provided\n  // WARNING: don't put anything between this and the request firing unless\n  // you have a good reason!\n  if (request.requestInterceptor) {\n    request = (await request.requestInterceptor(request)) || request;\n  }\n\n  /**\n   *  For content-type=multipart/form-data remove content-type from request before fetch,\n   *  so that correct one with `boundary` is set when request body is different from boundary encoded string.\n   */\n  const contentType = request.headers['content-type'] || request.headers['Content-Type'];\n  if (/multipart\\/form-data/i.test(contentType)) {\n    delete request.headers['content-type'];\n    delete request.headers['Content-Type'];\n  }\n\n  // eslint-disable-next-line no-undef\n  let res;\n  try {\n    res = await (request.userFetch || fetch)(request.url, request);\n    res = await serializeResponse(res, url, request);\n    if (request.responseInterceptor) {\n      res = (await request.responseInterceptor(res)) || res;\n    }\n  } catch (resError) {\n    if (!res) {\n      // res is completely absent, so we can't construct our own error\n      // so we'll just throw the error we got\n      throw resError;\n    }\n    const error = new Error(res.statusText || `response status is ${res.status}`);\n    error.status = res.status;\n    error.statusCode = res.status;\n    error.responseError = resError;\n    throw error;\n  }\n  if (!res.ok) {\n    const error = new Error(res.statusText || `response status is ${res.status}`);\n    error.status = res.status;\n    error.statusCode = res.status;\n    error.response = res;\n    throw error;\n  }\n  return res;\n}\n\n// Wrap a http function ( there are otherways to do this, consider this deprecated )\nexport function makeHttp(httpFn, preFetch, postFetch) {\n  postFetch = postFetch || (a => a);\n  preFetch = preFetch || (a => a);\n  return req => {\n    if (typeof req === 'string') {\n      req = {\n        url: req\n      };\n    }\n    req = serializeRequest(req);\n    req = preFetch(req);\n    return postFetch(httpFn(req));\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}