{"ast":null,"code":"import { curry } from 'ramda';\nimport isFunction from './isFunction.js';\n\n/**\n * The catamorphism is a way of folding a type into a value.\n *\n * **Either**\n *\n * If the either is right then the right function will be executed with\n * the `right` value and the value of the function returned. Otherwise the left function\n * will be called with the `left` value.\n *\n * **Maybe**\n *\n * If the maybe is Some than the right function will be executed with the `some` value and the value of the function\n * returned. Otherwise the left function with be called without an argument.\n *\n * **Result**\n *\n * If the result is Ok than the right function will be executed with the `Ok` value and the value of the function\n * returned. Otherwise the left function will be called with the `Error` value.\n *\n * **Validation**\n *\n * If the validation is Success than the right function will be executed with the `Success` value and the value of the function\n * returned. Otherwise the left function will be called with the `Failure` value.\n *\n * Supported monadic libraries: {@link https://monet.github.io/monet.js/|monet.js}, {@link https://folktale.origamitower.com/|folktale}, {@link https://github.com/ramda/ramda-fantasy|ramda-fantasy}\n *\n * @func cata\n * @memberOf RA\n * @since {@link https://char0n.github.io/ramda-adjunct/1.4.0|v1.4.0}\n * @category Function\n * @sig (a -> b) -> (a -> c) -> Cata a -> b | c\n * @param {Function} leftFn The left function that consumes the left value\n * @param {Function} rightFn The right function that consumes the right value\n * @param {Cata} catamorphicObj Either, Maybe or any other type with catamorphic capabilities (`cata` or `either` method)\n * @return {*}\n * @see {@link https://monet.github.io/monet.js/#cata|cata explained}\n * @example\n *\n * // Either\n * const eitherR = Either.Right(1);\n * const eitherL = Either.Left(2);\n *\n * RA.cata(identity, identity, eitherR); //=> 1\n * RA.cata(identity, identity, eitherL); //=> 2\n *\n * // Maybe\n * const maybeSome = Maybe.Some(1);\n * const maybeNothing = Maybe.Nothing();\n *\n * RA.cata(identity, identity, maybeSome); //=> 1\n * RA.cata(identity, identity, maybeNothing); //=> undefined\n */\nvar catamorphism = curry(function (leftFn, rightFn, catamorphicObj) {\n  // folktale support\n  if (isFunction(catamorphicObj.matchWith)) {\n    return catamorphicObj.matchWith({\n      // Result type\n      Ok: function Ok(_ref) {\n        var value = _ref.value;\n        return rightFn(value);\n      },\n      Error: function Error(_ref2) {\n        var value = _ref2.value;\n        return leftFn(value);\n      },\n      // Maybe type\n      Just: function Just(_ref3) {\n        var value = _ref3.value;\n        return rightFn(value);\n      },\n      Nothing: function Nothing() {\n        return leftFn(undefined);\n      },\n      // Validation type\n      Success: function Success(_ref4) {\n        var value = _ref4.value;\n        return rightFn(value);\n      },\n      Failure: function Failure(_ref5) {\n        var value = _ref5.value;\n        return leftFn(value);\n      }\n    });\n  }\n  if (isFunction(catamorphicObj.cata)) {\n    return catamorphicObj.cata(leftFn, rightFn);\n  }\n  if (isFunction(catamorphicObj.getOrElse)) {\n    var elseValue = \"RA.cata\".concat(Math.random());\n    var value = catamorphicObj.getOrElse(elseValue);\n    return value === elseValue ? leftFn() : rightFn(value);\n  }\n  return catamorphicObj.either(leftFn, rightFn);\n});\nexport default catamorphism;","map":{"version":3,"names":["curry","isFunction","catamorphism","leftFn","rightFn","catamorphicObj","matchWith","Ok","_ref","value","Error","_ref2","Just","_ref3","Nothing","undefined","Success","_ref4","Failure","_ref5","cata","getOrElse","elseValue","concat","Math","random","either"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/ramda-adjunct/es/cata.js"],"sourcesContent":["import { curry } from 'ramda';\nimport isFunction from './isFunction.js';\n\n/**\n * The catamorphism is a way of folding a type into a value.\n *\n * **Either**\n *\n * If the either is right then the right function will be executed with\n * the `right` value and the value of the function returned. Otherwise the left function\n * will be called with the `left` value.\n *\n * **Maybe**\n *\n * If the maybe is Some than the right function will be executed with the `some` value and the value of the function\n * returned. Otherwise the left function with be called without an argument.\n *\n * **Result**\n *\n * If the result is Ok than the right function will be executed with the `Ok` value and the value of the function\n * returned. Otherwise the left function will be called with the `Error` value.\n *\n * **Validation**\n *\n * If the validation is Success than the right function will be executed with the `Success` value and the value of the function\n * returned. Otherwise the left function will be called with the `Failure` value.\n *\n * Supported monadic libraries: {@link https://monet.github.io/monet.js/|monet.js}, {@link https://folktale.origamitower.com/|folktale}, {@link https://github.com/ramda/ramda-fantasy|ramda-fantasy}\n *\n * @func cata\n * @memberOf RA\n * @since {@link https://char0n.github.io/ramda-adjunct/1.4.0|v1.4.0}\n * @category Function\n * @sig (a -> b) -> (a -> c) -> Cata a -> b | c\n * @param {Function} leftFn The left function that consumes the left value\n * @param {Function} rightFn The right function that consumes the right value\n * @param {Cata} catamorphicObj Either, Maybe or any other type with catamorphic capabilities (`cata` or `either` method)\n * @return {*}\n * @see {@link https://monet.github.io/monet.js/#cata|cata explained}\n * @example\n *\n * // Either\n * const eitherR = Either.Right(1);\n * const eitherL = Either.Left(2);\n *\n * RA.cata(identity, identity, eitherR); //=> 1\n * RA.cata(identity, identity, eitherL); //=> 2\n *\n * // Maybe\n * const maybeSome = Maybe.Some(1);\n * const maybeNothing = Maybe.Nothing();\n *\n * RA.cata(identity, identity, maybeSome); //=> 1\n * RA.cata(identity, identity, maybeNothing); //=> undefined\n */\nvar catamorphism = curry(function (leftFn, rightFn, catamorphicObj) {\n  // folktale support\n  if (isFunction(catamorphicObj.matchWith)) {\n    return catamorphicObj.matchWith({\n      // Result type\n      Ok: function Ok(_ref) {\n        var value = _ref.value;\n        return rightFn(value);\n      },\n      Error: function Error(_ref2) {\n        var value = _ref2.value;\n        return leftFn(value);\n      },\n      // Maybe type\n      Just: function Just(_ref3) {\n        var value = _ref3.value;\n        return rightFn(value);\n      },\n      Nothing: function Nothing() {\n        return leftFn(undefined);\n      },\n      // Validation type\n      Success: function Success(_ref4) {\n        var value = _ref4.value;\n        return rightFn(value);\n      },\n      Failure: function Failure(_ref5) {\n        var value = _ref5.value;\n        return leftFn(value);\n      }\n    });\n  }\n  if (isFunction(catamorphicObj.cata)) {\n    return catamorphicObj.cata(leftFn, rightFn);\n  }\n  if (isFunction(catamorphicObj.getOrElse)) {\n    var elseValue = \"RA.cata\".concat(Math.random());\n    var value = catamorphicObj.getOrElse(elseValue);\n    return value === elseValue ? leftFn() : rightFn(value);\n  }\n  return catamorphicObj.either(leftFn, rightFn);\n});\nexport default catamorphism;"],"mappings":"AAAA,SAASA,KAAK,QAAQ,OAAO;AAC7B,OAAOC,UAAU,MAAM,iBAAiB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,YAAY,GAAGF,KAAK,CAAC,UAAUG,MAAM,EAAEC,OAAO,EAAEC,cAAc,EAAE;EAClE;EACA,IAAIJ,UAAU,CAACI,cAAc,CAACC,SAAS,CAAC,EAAE;IACxC,OAAOD,cAAc,CAACC,SAAS,CAAC;MAC9B;MACAC,EAAE,EAAE,SAASA,EAAEA,CAACC,IAAI,EAAE;QACpB,IAAIC,KAAK,GAAGD,IAAI,CAACC,KAAK;QACtB,OAAOL,OAAO,CAACK,KAAK,CAAC;MACvB,CAAC;MACDC,KAAK,EAAE,SAASA,KAAKA,CAACC,KAAK,EAAE;QAC3B,IAAIF,KAAK,GAAGE,KAAK,CAACF,KAAK;QACvB,OAAON,MAAM,CAACM,KAAK,CAAC;MACtB,CAAC;MACD;MACAG,IAAI,EAAE,SAASA,IAAIA,CAACC,KAAK,EAAE;QACzB,IAAIJ,KAAK,GAAGI,KAAK,CAACJ,KAAK;QACvB,OAAOL,OAAO,CAACK,KAAK,CAAC;MACvB,CAAC;MACDK,OAAO,EAAE,SAASA,OAAOA,CAAA,EAAG;QAC1B,OAAOX,MAAM,CAACY,SAAS,CAAC;MAC1B,CAAC;MACD;MACAC,OAAO,EAAE,SAASA,OAAOA,CAACC,KAAK,EAAE;QAC/B,IAAIR,KAAK,GAAGQ,KAAK,CAACR,KAAK;QACvB,OAAOL,OAAO,CAACK,KAAK,CAAC;MACvB,CAAC;MACDS,OAAO,EAAE,SAASA,OAAOA,CAACC,KAAK,EAAE;QAC/B,IAAIV,KAAK,GAAGU,KAAK,CAACV,KAAK;QACvB,OAAON,MAAM,CAACM,KAAK,CAAC;MACtB;IACF,CAAC,CAAC;EACJ;EACA,IAAIR,UAAU,CAACI,cAAc,CAACe,IAAI,CAAC,EAAE;IACnC,OAAOf,cAAc,CAACe,IAAI,CAACjB,MAAM,EAAEC,OAAO,CAAC;EAC7C;EACA,IAAIH,UAAU,CAACI,cAAc,CAACgB,SAAS,CAAC,EAAE;IACxC,IAAIC,SAAS,GAAG,SAAS,CAACC,MAAM,CAACC,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC;IAC/C,IAAIhB,KAAK,GAAGJ,cAAc,CAACgB,SAAS,CAACC,SAAS,CAAC;IAC/C,OAAOb,KAAK,KAAKa,SAAS,GAAGnB,MAAM,CAAC,CAAC,GAAGC,OAAO,CAACK,KAAK,CAAC;EACxD;EACA,OAAOJ,cAAc,CAACqB,MAAM,CAACvB,MAAM,EAAEC,OAAO,CAAC;AAC/C,CAAC,CAAC;AACF,eAAeF,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}