{"ast":null,"code":"import isNotFinite from '../../isNotFinite.js';\nimport isNegative from '../../isNegative.js';\nvar repeat = function repeat(value, count) {\n  var validCount = Number(count);\n  if (validCount !== count) {\n    validCount = 0;\n  }\n  if (isNegative(validCount)) {\n    throw new RangeError('repeat count must be non-negative');\n  }\n  if (isNotFinite(validCount)) {\n    throw new RangeError('repeat count must be less than infinity');\n  }\n  validCount = Math.floor(validCount);\n  if (value.length === 0 || validCount === 0) {\n    return '';\n  }\n\n  // Ensuring validCount is a 31-bit integer allows us to heavily optimize the\n  // main part. But anyway, most current (August 2014) browsers can't handle\n  // strings 1 << 28 chars or longer, so:\n  // eslint-disable-next-line no-bitwise\n  if (value.length * validCount >= 1 << 28) {\n    throw new RangeError('repeat count must not overflow maximum string size');\n  }\n  var maxCount = value.length * validCount;\n  validCount = Math.floor(Math.log(validCount) / Math.log(2));\n  var result = value;\n  while (validCount) {\n    result += value;\n    validCount -= 1;\n  }\n  result += result.substring(0, maxCount - result.length);\n  return result;\n};\nexport default repeat;","map":{"version":3,"names":["isNotFinite","isNegative","repeat","value","count","validCount","Number","RangeError","Math","floor","length","maxCount","log","result","substring"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/ramda-adjunct/es/internal/ponyfills/String.repeat.js"],"sourcesContent":["import isNotFinite from '../../isNotFinite.js';\nimport isNegative from '../../isNegative.js';\nvar repeat = function repeat(value, count) {\n  var validCount = Number(count);\n  if (validCount !== count) {\n    validCount = 0;\n  }\n  if (isNegative(validCount)) {\n    throw new RangeError('repeat count must be non-negative');\n  }\n  if (isNotFinite(validCount)) {\n    throw new RangeError('repeat count must be less than infinity');\n  }\n  validCount = Math.floor(validCount);\n  if (value.length === 0 || validCount === 0) {\n    return '';\n  }\n\n  // Ensuring validCount is a 31-bit integer allows us to heavily optimize the\n  // main part. But anyway, most current (August 2014) browsers can't handle\n  // strings 1 << 28 chars or longer, so:\n  // eslint-disable-next-line no-bitwise\n  if (value.length * validCount >= 1 << 28) {\n    throw new RangeError('repeat count must not overflow maximum string size');\n  }\n  var maxCount = value.length * validCount;\n  validCount = Math.floor(Math.log(validCount) / Math.log(2));\n  var result = value;\n  while (validCount) {\n    result += value;\n    validCount -= 1;\n  }\n  result += result.substring(0, maxCount - result.length);\n  return result;\n};\nexport default repeat;"],"mappings":"AAAA,OAAOA,WAAW,MAAM,sBAAsB;AAC9C,OAAOC,UAAU,MAAM,qBAAqB;AAC5C,IAAIC,MAAM,GAAG,SAASA,MAAMA,CAACC,KAAK,EAAEC,KAAK,EAAE;EACzC,IAAIC,UAAU,GAAGC,MAAM,CAACF,KAAK,CAAC;EAC9B,IAAIC,UAAU,KAAKD,KAAK,EAAE;IACxBC,UAAU,GAAG,CAAC;EAChB;EACA,IAAIJ,UAAU,CAACI,UAAU,CAAC,EAAE;IAC1B,MAAM,IAAIE,UAAU,CAAC,mCAAmC,CAAC;EAC3D;EACA,IAAIP,WAAW,CAACK,UAAU,CAAC,EAAE;IAC3B,MAAM,IAAIE,UAAU,CAAC,yCAAyC,CAAC;EACjE;EACAF,UAAU,GAAGG,IAAI,CAACC,KAAK,CAACJ,UAAU,CAAC;EACnC,IAAIF,KAAK,CAACO,MAAM,KAAK,CAAC,IAAIL,UAAU,KAAK,CAAC,EAAE;IAC1C,OAAO,EAAE;EACX;;EAEA;EACA;EACA;EACA;EACA,IAAIF,KAAK,CAACO,MAAM,GAAGL,UAAU,IAAI,CAAC,IAAI,EAAE,EAAE;IACxC,MAAM,IAAIE,UAAU,CAAC,oDAAoD,CAAC;EAC5E;EACA,IAAII,QAAQ,GAAGR,KAAK,CAACO,MAAM,GAAGL,UAAU;EACxCA,UAAU,GAAGG,IAAI,CAACC,KAAK,CAACD,IAAI,CAACI,GAAG,CAACP,UAAU,CAAC,GAAGG,IAAI,CAACI,GAAG,CAAC,CAAC,CAAC,CAAC;EAC3D,IAAIC,MAAM,GAAGV,KAAK;EAClB,OAAOE,UAAU,EAAE;IACjBQ,MAAM,IAAIV,KAAK;IACfE,UAAU,IAAI,CAAC;EACjB;EACAQ,MAAM,IAAIA,MAAM,CAACC,SAAS,CAAC,CAAC,EAAEH,QAAQ,GAAGE,MAAM,CAACH,MAAM,CAAC;EACvD,OAAOG,MAAM;AACf,CAAC;AACD,eAAeX,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}