{"ast":null,"code":"import lib from './lib/index.js';\nimport refs from './lib/refs.js';\nimport allOf from './lib/all-of.js';\nimport parameters from './lib/parameters.js';\nimport properties from './lib/properties.js';\nimport ContextTree from './lib/context-tree.js';\nconst PLUGIN_DISPATCH_LIMIT = 100;\nconst TRAVERSE_LIMIT = 3000;\nconst noop = () => {};\nclass SpecMap {\n  static getPluginName(plugin) {\n    return plugin.pluginName;\n  }\n  static getPatchesOfType(patches, fn) {\n    return patches.filter(fn);\n  }\n  constructor(opts) {\n    Object.assign(this, {\n      spec: '',\n      debugLevel: 'info',\n      plugins: [],\n      pluginHistory: {},\n      errors: [],\n      mutations: [],\n      promisedPatches: [],\n      state: {},\n      patches: [],\n      context: {},\n      contextTree: new ContextTree(),\n      showDebug: false,\n      allPatches: [],\n      // only populated if showDebug is true\n      pluginProp: 'specMap',\n      libMethods: Object.assign(Object.create(this), lib, {\n        getInstance: () => this\n      }),\n      allowMetaPatches: false\n    }, opts);\n\n    // Lib methods bound\n    this.get = this._get.bind(this); // eslint-disable-line no-underscore-dangle\n    this.getContext = this._getContext.bind(this); // eslint-disable-line no-underscore-dangle\n    this.hasRun = this._hasRun.bind(this); // eslint-disable-line no-underscore-dangle\n\n    this.wrappedPlugins = this.plugins.map(this.wrapPlugin.bind(this)).filter(lib.isFunction);\n\n    // Initial patch(s)\n    this.patches.push(lib.add([], this.spec));\n    this.patches.push(lib.context([], this.context));\n    this.updatePatches(this.patches);\n  }\n  debug(level, ...args) {\n    if (this.debugLevel === level) {\n      console.log(...args); // eslint-disable-line no-console\n    }\n  }\n  verbose(header, ...args) {\n    if (this.debugLevel === 'verbose') {\n      console.log(`[${header}]   `, ...args); // eslint-disable-line no-console\n    }\n  }\n  wrapPlugin(plugin, name) {\n    const {\n      pathDiscriminator\n    } = this;\n    let ctx = null;\n    let fn;\n    if (plugin[this.pluginProp]) {\n      ctx = plugin;\n      fn = plugin[this.pluginProp];\n    } else if (lib.isFunction(plugin)) {\n      fn = plugin;\n    } else if (lib.isObject(plugin)) {\n      fn = createKeyBasedPlugin(plugin);\n    }\n    return Object.assign(fn.bind(ctx), {\n      pluginName: plugin.name || name,\n      isGenerator: lib.isGenerator(fn)\n    });\n\n    // Expected plugin interface: {key: string, plugin: fn*}\n    // This traverses depth-first and immediately applies yielded patches.\n    // This strategy should work well for most plugins (including the built-ins).\n    // We might consider making this (traversing & application) configurable later.\n    function createKeyBasedPlugin(pluginObj) {\n      const isSubPath = (path, tested) => {\n        if (!Array.isArray(path)) {\n          return true;\n        }\n        return path.every((val, i) => val === tested[i]);\n      };\n      return function* generator(patches, specmap) {\n        const refCache = {};\n\n        // eslint-disable-next-line no-restricted-syntax\n        for (const [i, patch] of patches.filter(lib.isAdditiveMutation).entries()) {\n          if (i < TRAVERSE_LIMIT) {\n            yield* traverse(patch.value, patch.path, patch);\n          } else {\n            return;\n          }\n        }\n        function* traverse(obj, path, patch) {\n          if (!lib.isObject(obj)) {\n            if (pluginObj.key === path[path.length - 1]) {\n              yield pluginObj.plugin(obj, pluginObj.key, path, specmap);\n            }\n          } else {\n            const parentIndex = path.length - 1;\n            const parent = path[parentIndex];\n            const indexOfFirstProperties = path.indexOf('properties');\n            const isRootProperties = parent === 'properties' && parentIndex === indexOfFirstProperties;\n            const traversed = specmap.allowMetaPatches && refCache[obj.$$ref];\n\n            // eslint-disable-next-line no-restricted-syntax\n            for (const key of Object.keys(obj)) {\n              const val = obj[key];\n              const updatedPath = path.concat(key);\n              const isObj = lib.isObject(val);\n              const objRef = obj.$$ref;\n              if (!traversed) {\n                if (isObj) {\n                  // Only store the ref if it exists\n                  if (specmap.allowMetaPatches && objRef) {\n                    refCache[objRef] = true;\n                  }\n                  yield* traverse(val, updatedPath, patch);\n                }\n              }\n              if (!isRootProperties && key === pluginObj.key) {\n                const isWithinPathDiscriminator = isSubPath(pathDiscriminator, path);\n                if (!pathDiscriminator || isWithinPathDiscriminator) {\n                  yield pluginObj.plugin(val, key, updatedPath, specmap, patch);\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n  }\n  nextPlugin() {\n    return this.wrappedPlugins.find(plugin => {\n      const mutations = this.getMutationsForPlugin(plugin);\n      return mutations.length > 0;\n    });\n  }\n  nextPromisedPatch() {\n    if (this.promisedPatches.length > 0) {\n      return Promise.race(this.promisedPatches.map(patch => patch.value));\n    }\n    return undefined;\n  }\n  getPluginHistory(plugin) {\n    const name = this.constructor.getPluginName(plugin);\n    return this.pluginHistory[name] || [];\n  }\n  getPluginRunCount(plugin) {\n    return this.getPluginHistory(plugin).length;\n  }\n  getPluginHistoryTip(plugin) {\n    const history = this.getPluginHistory(plugin);\n    const val = history && history[history.length - 1];\n    return val || {};\n  }\n  getPluginMutationIndex(plugin) {\n    const mi = this.getPluginHistoryTip(plugin).mutationIndex;\n    return typeof mi !== 'number' ? -1 : mi;\n  }\n  updatePluginHistory(plugin, val) {\n    const name = this.constructor.getPluginName(plugin);\n    this.pluginHistory[name] = this.pluginHistory[name] || [];\n    this.pluginHistory[name].push(val);\n  }\n  updatePatches(patches) {\n    lib.normalizeArray(patches).forEach(patch => {\n      if (patch instanceof Error) {\n        this.errors.push(patch);\n        return;\n      }\n      try {\n        if (!lib.isObject(patch)) {\n          this.debug('updatePatches', 'Got a non-object patch', patch);\n          return;\n        }\n        if (this.showDebug) {\n          this.allPatches.push(patch);\n        }\n        if (lib.isPromise(patch.value)) {\n          this.promisedPatches.push(patch);\n          this.promisedPatchThen(patch);\n          return;\n        }\n        if (lib.isContextPatch(patch)) {\n          this.setContext(patch.path, patch.value);\n          return;\n        }\n        if (lib.isMutation(patch)) {\n          this.updateMutations(patch);\n        }\n      } catch (e) {\n        console.error(e); // eslint-disable-line no-console\n        this.errors.push(e);\n      }\n    });\n  }\n  updateMutations(patch) {\n    if (typeof patch.value === 'object' && !Array.isArray(patch.value) && this.allowMetaPatches) {\n      patch.value = {\n        ...patch.value\n      };\n    }\n    const result = lib.applyPatch(this.state, patch, {\n      allowMetaPatches: this.allowMetaPatches\n    });\n    if (result) {\n      this.mutations.push(patch);\n      this.state = result;\n    }\n  }\n  removePromisedPatch(patch) {\n    const index = this.promisedPatches.indexOf(patch);\n    if (index < 0) {\n      this.debug(\"Tried to remove a promisedPatch that isn't there!\");\n      return;\n    }\n    this.promisedPatches.splice(index, 1);\n  }\n  promisedPatchThen(patch) {\n    patch.value = patch.value.then(val => {\n      const promisedPatch = {\n        ...patch,\n        value: val\n      };\n      this.removePromisedPatch(patch);\n      this.updatePatches(promisedPatch);\n    }).catch(e => {\n      this.removePromisedPatch(patch);\n      this.updatePatches(e);\n    });\n    return patch.value;\n  }\n  getMutations(from, to) {\n    from = from || 0;\n    if (typeof to !== 'number') {\n      to = this.mutations.length;\n    }\n    return this.mutations.slice(from, to);\n  }\n  getCurrentMutations() {\n    return this.getMutationsForPlugin(this.getCurrentPlugin());\n  }\n  getMutationsForPlugin(plugin) {\n    const tip = this.getPluginMutationIndex(plugin);\n    return this.getMutations(tip + 1);\n  }\n  getCurrentPlugin() {\n    return this.currentPlugin;\n  }\n  getLib() {\n    return this.libMethods;\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _get(path) {\n    return lib.getIn(this.state, path);\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _getContext(path) {\n    return this.contextTree.get(path);\n  }\n  setContext(path, value) {\n    return this.contextTree.set(path, value);\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _hasRun(count) {\n    const times = this.getPluginRunCount(this.getCurrentPlugin());\n    return times > (count || 0);\n  }\n  dispatch() {\n    const that = this;\n    const plugin = this.nextPlugin();\n    if (!plugin) {\n      const nextPromise = this.nextPromisedPatch();\n      if (nextPromise) {\n        return nextPromise.then(() => this.dispatch()).catch(() => this.dispatch());\n      }\n\n      // We're done!\n      const result = {\n        spec: this.state,\n        errors: this.errors\n      };\n      if (this.showDebug) {\n        result.patches = this.allPatches;\n      }\n      return Promise.resolve(result);\n    }\n\n    // Makes sure plugin isn't running an endless loop\n    that.pluginCount = that.pluginCount || new WeakMap();\n    that.pluginCount.set(plugin, (that.pluginCount.get(plugin) || 0) + 1);\n    if (that.pluginCount[plugin] > PLUGIN_DISPATCH_LIMIT) {\n      return Promise.resolve({\n        spec: that.state,\n        errors: that.errors.concat(new Error(`We've reached a hard limit of ${PLUGIN_DISPATCH_LIMIT} plugin runs`))\n      });\n    }\n\n    // A different plugin runs, wait for all promises to resolve, then retry\n    if (plugin !== this.currentPlugin && this.promisedPatches.length) {\n      const promises = this.promisedPatches.map(p => p.value);\n\n      // Waits for all to settle instead of Promise.all which stops on rejection\n      return Promise.all(promises.map(promise => promise.then(noop, noop))).then(() => this.dispatch());\n    }\n\n    // Ok, run the plugin\n    return executePlugin();\n    function executePlugin() {\n      that.currentPlugin = plugin;\n      const mutations = that.getCurrentMutations();\n      const lastMutationIndex = that.mutations.length - 1;\n      try {\n        if (plugin.isGenerator) {\n          // eslint-disable-next-line no-restricted-syntax\n          for (const yieldedPatches of plugin(mutations, that.getLib())) {\n            updatePatches(yieldedPatches);\n          }\n        } else {\n          const newPatches = plugin(mutations, that.getLib());\n          updatePatches(newPatches);\n        }\n      } catch (e) {\n        console.error(e); // eslint-disable-line no-console\n        updatePatches([Object.assign(Object.create(e), {\n          plugin\n        })]);\n      } finally {\n        that.updatePluginHistory(plugin, {\n          mutationIndex: lastMutationIndex\n        });\n      }\n      return that.dispatch();\n    }\n    function updatePatches(patches) {\n      if (patches) {\n        patches = lib.fullyNormalizeArray(patches);\n        that.updatePatches(patches, plugin);\n      }\n    }\n  }\n}\nexport default function mapSpec(opts) {\n  return new SpecMap(opts).dispatch();\n}\nconst plugins = {\n  refs,\n  allOf,\n  parameters,\n  properties\n};\nexport { SpecMap, plugins };","map":{"version":3,"names":["lib","refs","allOf","parameters","properties","ContextTree","PLUGIN_DISPATCH_LIMIT","TRAVERSE_LIMIT","noop","SpecMap","getPluginName","plugin","pluginName","getPatchesOfType","patches","fn","filter","constructor","opts","Object","assign","spec","debugLevel","plugins","pluginHistory","errors","mutations","promisedPatches","state","context","contextTree","showDebug","allPatches","pluginProp","libMethods","create","getInstance","allowMetaPatches","get","_get","bind","getContext","_getContext","hasRun","_hasRun","wrappedPlugins","map","wrapPlugin","isFunction","push","add","updatePatches","debug","level","args","console","log","verbose","header","name","pathDiscriminator","ctx","isObject","createKeyBasedPlugin","isGenerator","pluginObj","isSubPath","path","tested","Array","isArray","every","val","i","generator","specmap","refCache","patch","isAdditiveMutation","entries","traverse","value","obj","key","length","parentIndex","parent","indexOfFirstProperties","indexOf","isRootProperties","traversed","$$ref","keys","updatedPath","concat","isObj","objRef","isWithinPathDiscriminator","nextPlugin","find","getMutationsForPlugin","nextPromisedPatch","Promise","race","undefined","getPluginHistory","getPluginRunCount","getPluginHistoryTip","history","getPluginMutationIndex","mi","mutationIndex","updatePluginHistory","normalizeArray","forEach","Error","isPromise","promisedPatchThen","isContextPatch","setContext","isMutation","updateMutations","e","error","result","applyPatch","removePromisedPatch","index","splice","then","promisedPatch","catch","getMutations","from","to","slice","getCurrentMutations","getCurrentPlugin","tip","currentPlugin","getLib","getIn","set","count","times","dispatch","that","nextPromise","resolve","pluginCount","WeakMap","promises","p","all","promise","executePlugin","lastMutationIndex","yieldedPatches","newPatches","fullyNormalizeArray","mapSpec"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/resolver/specmap/index.js"],"sourcesContent":["import lib from './lib/index.js';\nimport refs from './lib/refs.js';\nimport allOf from './lib/all-of.js';\nimport parameters from './lib/parameters.js';\nimport properties from './lib/properties.js';\nimport ContextTree from './lib/context-tree.js';\nconst PLUGIN_DISPATCH_LIMIT = 100;\nconst TRAVERSE_LIMIT = 3000;\nconst noop = () => {};\nclass SpecMap {\n  static getPluginName(plugin) {\n    return plugin.pluginName;\n  }\n  static getPatchesOfType(patches, fn) {\n    return patches.filter(fn);\n  }\n  constructor(opts) {\n    Object.assign(this, {\n      spec: '',\n      debugLevel: 'info',\n      plugins: [],\n      pluginHistory: {},\n      errors: [],\n      mutations: [],\n      promisedPatches: [],\n      state: {},\n      patches: [],\n      context: {},\n      contextTree: new ContextTree(),\n      showDebug: false,\n      allPatches: [],\n      // only populated if showDebug is true\n      pluginProp: 'specMap',\n      libMethods: Object.assign(Object.create(this), lib, {\n        getInstance: () => this\n      }),\n      allowMetaPatches: false\n    }, opts);\n\n    // Lib methods bound\n    this.get = this._get.bind(this); // eslint-disable-line no-underscore-dangle\n    this.getContext = this._getContext.bind(this); // eslint-disable-line no-underscore-dangle\n    this.hasRun = this._hasRun.bind(this); // eslint-disable-line no-underscore-dangle\n\n    this.wrappedPlugins = this.plugins.map(this.wrapPlugin.bind(this)).filter(lib.isFunction);\n\n    // Initial patch(s)\n    this.patches.push(lib.add([], this.spec));\n    this.patches.push(lib.context([], this.context));\n    this.updatePatches(this.patches);\n  }\n  debug(level, ...args) {\n    if (this.debugLevel === level) {\n      console.log(...args); // eslint-disable-line no-console\n    }\n  }\n  verbose(header, ...args) {\n    if (this.debugLevel === 'verbose') {\n      console.log(`[${header}]   `, ...args); // eslint-disable-line no-console\n    }\n  }\n  wrapPlugin(plugin, name) {\n    const {\n      pathDiscriminator\n    } = this;\n    let ctx = null;\n    let fn;\n    if (plugin[this.pluginProp]) {\n      ctx = plugin;\n      fn = plugin[this.pluginProp];\n    } else if (lib.isFunction(plugin)) {\n      fn = plugin;\n    } else if (lib.isObject(plugin)) {\n      fn = createKeyBasedPlugin(plugin);\n    }\n    return Object.assign(fn.bind(ctx), {\n      pluginName: plugin.name || name,\n      isGenerator: lib.isGenerator(fn)\n    });\n\n    // Expected plugin interface: {key: string, plugin: fn*}\n    // This traverses depth-first and immediately applies yielded patches.\n    // This strategy should work well for most plugins (including the built-ins).\n    // We might consider making this (traversing & application) configurable later.\n    function createKeyBasedPlugin(pluginObj) {\n      const isSubPath = (path, tested) => {\n        if (!Array.isArray(path)) {\n          return true;\n        }\n        return path.every((val, i) => val === tested[i]);\n      };\n      return function* generator(patches, specmap) {\n        const refCache = {};\n\n        // eslint-disable-next-line no-restricted-syntax\n        for (const [i, patch] of patches.filter(lib.isAdditiveMutation).entries()) {\n          if (i < TRAVERSE_LIMIT) {\n            yield* traverse(patch.value, patch.path, patch);\n          } else {\n            return;\n          }\n        }\n        function* traverse(obj, path, patch) {\n          if (!lib.isObject(obj)) {\n            if (pluginObj.key === path[path.length - 1]) {\n              yield pluginObj.plugin(obj, pluginObj.key, path, specmap);\n            }\n          } else {\n            const parentIndex = path.length - 1;\n            const parent = path[parentIndex];\n            const indexOfFirstProperties = path.indexOf('properties');\n            const isRootProperties = parent === 'properties' && parentIndex === indexOfFirstProperties;\n            const traversed = specmap.allowMetaPatches && refCache[obj.$$ref];\n\n            // eslint-disable-next-line no-restricted-syntax\n            for (const key of Object.keys(obj)) {\n              const val = obj[key];\n              const updatedPath = path.concat(key);\n              const isObj = lib.isObject(val);\n              const objRef = obj.$$ref;\n              if (!traversed) {\n                if (isObj) {\n                  // Only store the ref if it exists\n                  if (specmap.allowMetaPatches && objRef) {\n                    refCache[objRef] = true;\n                  }\n                  yield* traverse(val, updatedPath, patch);\n                }\n              }\n              if (!isRootProperties && key === pluginObj.key) {\n                const isWithinPathDiscriminator = isSubPath(pathDiscriminator, path);\n                if (!pathDiscriminator || isWithinPathDiscriminator) {\n                  yield pluginObj.plugin(val, key, updatedPath, specmap, patch);\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n  }\n  nextPlugin() {\n    return this.wrappedPlugins.find(plugin => {\n      const mutations = this.getMutationsForPlugin(plugin);\n      return mutations.length > 0;\n    });\n  }\n  nextPromisedPatch() {\n    if (this.promisedPatches.length > 0) {\n      return Promise.race(this.promisedPatches.map(patch => patch.value));\n    }\n    return undefined;\n  }\n  getPluginHistory(plugin) {\n    const name = this.constructor.getPluginName(plugin);\n    return this.pluginHistory[name] || [];\n  }\n  getPluginRunCount(plugin) {\n    return this.getPluginHistory(plugin).length;\n  }\n  getPluginHistoryTip(plugin) {\n    const history = this.getPluginHistory(plugin);\n    const val = history && history[history.length - 1];\n    return val || {};\n  }\n  getPluginMutationIndex(plugin) {\n    const mi = this.getPluginHistoryTip(plugin).mutationIndex;\n    return typeof mi !== 'number' ? -1 : mi;\n  }\n  updatePluginHistory(plugin, val) {\n    const name = this.constructor.getPluginName(plugin);\n    this.pluginHistory[name] = this.pluginHistory[name] || [];\n    this.pluginHistory[name].push(val);\n  }\n  updatePatches(patches) {\n    lib.normalizeArray(patches).forEach(patch => {\n      if (patch instanceof Error) {\n        this.errors.push(patch);\n        return;\n      }\n      try {\n        if (!lib.isObject(patch)) {\n          this.debug('updatePatches', 'Got a non-object patch', patch);\n          return;\n        }\n        if (this.showDebug) {\n          this.allPatches.push(patch);\n        }\n        if (lib.isPromise(patch.value)) {\n          this.promisedPatches.push(patch);\n          this.promisedPatchThen(patch);\n          return;\n        }\n        if (lib.isContextPatch(patch)) {\n          this.setContext(patch.path, patch.value);\n          return;\n        }\n        if (lib.isMutation(patch)) {\n          this.updateMutations(patch);\n        }\n      } catch (e) {\n        console.error(e); // eslint-disable-line no-console\n        this.errors.push(e);\n      }\n    });\n  }\n  updateMutations(patch) {\n    if (typeof patch.value === 'object' && !Array.isArray(patch.value) && this.allowMetaPatches) {\n      patch.value = {\n        ...patch.value\n      };\n    }\n    const result = lib.applyPatch(this.state, patch, {\n      allowMetaPatches: this.allowMetaPatches\n    });\n    if (result) {\n      this.mutations.push(patch);\n      this.state = result;\n    }\n  }\n  removePromisedPatch(patch) {\n    const index = this.promisedPatches.indexOf(patch);\n    if (index < 0) {\n      this.debug(\"Tried to remove a promisedPatch that isn't there!\");\n      return;\n    }\n    this.promisedPatches.splice(index, 1);\n  }\n  promisedPatchThen(patch) {\n    patch.value = patch.value.then(val => {\n      const promisedPatch = {\n        ...patch,\n        value: val\n      };\n      this.removePromisedPatch(patch);\n      this.updatePatches(promisedPatch);\n    }).catch(e => {\n      this.removePromisedPatch(patch);\n      this.updatePatches(e);\n    });\n    return patch.value;\n  }\n  getMutations(from, to) {\n    from = from || 0;\n    if (typeof to !== 'number') {\n      to = this.mutations.length;\n    }\n    return this.mutations.slice(from, to);\n  }\n  getCurrentMutations() {\n    return this.getMutationsForPlugin(this.getCurrentPlugin());\n  }\n  getMutationsForPlugin(plugin) {\n    const tip = this.getPluginMutationIndex(plugin);\n    return this.getMutations(tip + 1);\n  }\n  getCurrentPlugin() {\n    return this.currentPlugin;\n  }\n  getLib() {\n    return this.libMethods;\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _get(path) {\n    return lib.getIn(this.state, path);\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _getContext(path) {\n    return this.contextTree.get(path);\n  }\n  setContext(path, value) {\n    return this.contextTree.set(path, value);\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  _hasRun(count) {\n    const times = this.getPluginRunCount(this.getCurrentPlugin());\n    return times > (count || 0);\n  }\n  dispatch() {\n    const that = this;\n    const plugin = this.nextPlugin();\n    if (!plugin) {\n      const nextPromise = this.nextPromisedPatch();\n      if (nextPromise) {\n        return nextPromise.then(() => this.dispatch()).catch(() => this.dispatch());\n      }\n\n      // We're done!\n      const result = {\n        spec: this.state,\n        errors: this.errors\n      };\n      if (this.showDebug) {\n        result.patches = this.allPatches;\n      }\n      return Promise.resolve(result);\n    }\n\n    // Makes sure plugin isn't running an endless loop\n    that.pluginCount = that.pluginCount || new WeakMap();\n    that.pluginCount.set(plugin, (that.pluginCount.get(plugin) || 0) + 1);\n    if (that.pluginCount[plugin] > PLUGIN_DISPATCH_LIMIT) {\n      return Promise.resolve({\n        spec: that.state,\n        errors: that.errors.concat(new Error(`We've reached a hard limit of ${PLUGIN_DISPATCH_LIMIT} plugin runs`))\n      });\n    }\n\n    // A different plugin runs, wait for all promises to resolve, then retry\n    if (plugin !== this.currentPlugin && this.promisedPatches.length) {\n      const promises = this.promisedPatches.map(p => p.value);\n\n      // Waits for all to settle instead of Promise.all which stops on rejection\n      return Promise.all(promises.map(promise => promise.then(noop, noop))).then(() => this.dispatch());\n    }\n\n    // Ok, run the plugin\n    return executePlugin();\n    function executePlugin() {\n      that.currentPlugin = plugin;\n      const mutations = that.getCurrentMutations();\n      const lastMutationIndex = that.mutations.length - 1;\n      try {\n        if (plugin.isGenerator) {\n          // eslint-disable-next-line no-restricted-syntax\n          for (const yieldedPatches of plugin(mutations, that.getLib())) {\n            updatePatches(yieldedPatches);\n          }\n        } else {\n          const newPatches = plugin(mutations, that.getLib());\n          updatePatches(newPatches);\n        }\n      } catch (e) {\n        console.error(e); // eslint-disable-line no-console\n        updatePatches([Object.assign(Object.create(e), {\n          plugin\n        })]);\n      } finally {\n        that.updatePluginHistory(plugin, {\n          mutationIndex: lastMutationIndex\n        });\n      }\n      return that.dispatch();\n    }\n    function updatePatches(patches) {\n      if (patches) {\n        patches = lib.fullyNormalizeArray(patches);\n        that.updatePatches(patches, plugin);\n      }\n    }\n  }\n}\nexport default function mapSpec(opts) {\n  return new SpecMap(opts).dispatch();\n}\nconst plugins = {\n  refs,\n  allOf,\n  parameters,\n  properties\n};\nexport { SpecMap, plugins };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}