{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Matcher } from './matcher';\nimport { alphaNumericAndMarksCharsStr, domainNameCharRegex } from '../regex-lib';\nimport { EmailMatch } from '../match/email-match';\nimport { throwUnhandledCaseError } from '../utils';\nimport { tldRegex } from './tld-regex';\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n// RegExp objects which are shared by all instances of EmailMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating EmailMatcher and its RegExp\n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314).\n// See descriptions of the properties where they are used for details about them\nvar localPartCharRegex = new RegExp(\"[\".concat(alphaNumericAndMarksCharsStr, \"!#$%&'*+/=?^_`{|}~-]\"));\nvar strictTldRegex = new RegExp(\"^\".concat(tldRegex.source, \"$\"));\n/**\n * @class Autolinker.matcher.Email\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find email matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n */\nvar EmailMatcher = /** @class */function (_super) {\n  __extends(EmailMatcher, _super);\n  function EmailMatcher() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * Valid characters that can be used in the \"local\" part of an email address,\n     * i.e. the \"name\" part of \"name@site.com\"\n     */\n    _this.localPartCharRegex = localPartCharRegex;\n    /**\n     * Stricter TLD regex which adds a beginning and end check to ensure\n     * the string is a valid TLD\n     */\n    _this.strictTldRegex = strictTldRegex;\n    return _this;\n  }\n  /**\n   * @inheritdoc\n   */\n  EmailMatcher.prototype.parseMatches = function (text) {\n    var tagBuilder = this.tagBuilder,\n      localPartCharRegex = this.localPartCharRegex,\n      strictTldRegex = this.strictTldRegex,\n      matches = [],\n      len = text.length,\n      noCurrentEmailMatch = new CurrentEmailMatch();\n    // for matching a 'mailto:' prefix\n    var mailtoTransitions = {\n      m: 'a',\n      a: 'i',\n      i: 'l',\n      l: 't',\n      t: 'o',\n      o: ':'\n    };\n    var charIdx = 0,\n      state = 0 /* NonEmailMatch */,\n      currentEmailMatch = noCurrentEmailMatch;\n    // For debugging: search for other \"For debugging\" lines\n    // const table = new CliTable( {\n    // \thead: [ 'charIdx', 'char', 'state', 'charIdx', 'currentEmailAddress.idx', 'hasDomainDot' ]\n    // } );\n    while (charIdx < len) {\n      var char = text.charAt(charIdx);\n      // For debugging: search for other \"For debugging\" lines\n      // table.push(\n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ]\n      // );\n      switch (state) {\n        case 0 /* NonEmailMatch */:\n          stateNonEmailAddress(char);\n          break;\n        case 1 /* Mailto */:\n          stateMailTo(text.charAt(charIdx - 1), char);\n          break;\n        case 2 /* LocalPart */:\n          stateLocalPart(char);\n          break;\n        case 3 /* LocalPartDot */:\n          stateLocalPartDot(char);\n          break;\n        case 4 /* AtSign */:\n          stateAtSign(char);\n          break;\n        case 5 /* DomainChar */:\n          stateDomainChar(char);\n          break;\n        case 6 /* DomainHyphen */:\n          stateDomainHyphen(char);\n          break;\n        case 7 /* DomainDot */:\n          stateDomainDot(char);\n          break;\n        default:\n          throwUnhandledCaseError(state);\n      }\n      // For debugging: search for other \"For debugging\" lines\n      // table.push(\n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ]\n      // );\n      charIdx++;\n    }\n    // Capture any valid match at the end of the string\n    captureMatchIfValidAndReset();\n    // For debugging: search for other \"For debugging\" lines\n    //console.log( '\\n' + table.toString() );\n    return matches;\n    // Handles the state when we're not in an email address\n    function stateNonEmailAddress(char) {\n      if (char === 'm') {\n        beginEmailMatch(1 /* Mailto */);\n      } else if (localPartCharRegex.test(char)) {\n        beginEmailMatch();\n      } else {\n        // not an email address character, continue\n      }\n    }\n    // Handles if we're reading a 'mailto:' prefix on the string\n    function stateMailTo(prevChar, char) {\n      if (prevChar === ':') {\n        // We've reached the end of the 'mailto:' prefix\n        if (localPartCharRegex.test(char)) {\n          state = 2 /* LocalPart */;\n          currentEmailMatch = new CurrentEmailMatch(__assign(__assign({}, currentEmailMatch), {\n            hasMailtoPrefix: true\n          }));\n        } else {\n          // we've matched 'mailto:' but didn't get anything meaningful\n          // immediately afterwards (for example, we encountered a\n          // space character, or an '@' character which formed 'mailto:@'\n          resetToNonEmailMatchState();\n        }\n      } else if (mailtoTransitions[prevChar] === char) {\n        // We're currently reading the 'mailto:' prefix, stay in\n        // Mailto state\n      } else if (localPartCharRegex.test(char)) {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // different character that didn't continue the prefix\n        state = 2 /* LocalPart */;\n      } else if (char === '.') {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // dot character\n        state = 3 /* LocalPartDot */;\n      } else if (char === '@') {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // an @ character\n        state = 4 /* AtSign */;\n      } else {\n        // not an email address character, return to \"NonEmailAddress\" state\n        resetToNonEmailMatchState();\n      }\n    }\n    // Handles the state when we're currently in the \"local part\" of an\n    // email address (as opposed to the \"domain part\")\n    function stateLocalPart(char) {\n      if (char === '.') {\n        state = 3 /* LocalPartDot */;\n      } else if (char === '@') {\n        state = 4 /* AtSign */;\n      } else if (localPartCharRegex.test(char)) {\n        // stay in the \"local part\" of the email address\n      } else {\n        // not an email address character, return to \"NonEmailAddress\" state\n        resetToNonEmailMatchState();\n      }\n    }\n    // Handles the state where we've read\n    function stateLocalPartDot(char) {\n      if (char === '.') {\n        // We read a second '.' in a row, not a valid email address\n        // local part\n        resetToNonEmailMatchState();\n      } else if (char === '@') {\n        // We read the '@' character immediately after a dot ('.'), not\n        // an email address\n        resetToNonEmailMatchState();\n      } else if (localPartCharRegex.test(char)) {\n        state = 2 /* LocalPart */;\n      } else {\n        // Anything else, not an email address\n        resetToNonEmailMatchState();\n      }\n    }\n    function stateAtSign(char) {\n      if (domainNameCharRegex.test(char)) {\n        state = 5 /* DomainChar */;\n      } else {\n        // Anything else, not an email address\n        resetToNonEmailMatchState();\n      }\n    }\n    function stateDomainChar(char) {\n      if (char === '.') {\n        state = 7 /* DomainDot */;\n      } else if (char === '-') {\n        state = 6 /* DomainHyphen */;\n      } else if (domainNameCharRegex.test(char)) {\n        // Stay in the DomainChar state\n      } else {\n        // Anything else, we potentially matched if the criteria has\n        // been met\n        captureMatchIfValidAndReset();\n      }\n    }\n    function stateDomainHyphen(char) {\n      if (char === '-' || char === '.') {\n        // Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n        captureMatchIfValidAndReset();\n      } else if (domainNameCharRegex.test(char)) {\n        state = 5 /* DomainChar */;\n      } else {\n        // Anything else\n        captureMatchIfValidAndReset();\n      }\n    }\n    function stateDomainDot(char) {\n      if (char === '.' || char === '-') {\n        // not valid to have two dots (\"..\") or dot+hypen (\".-\")\n        captureMatchIfValidAndReset();\n      } else if (domainNameCharRegex.test(char)) {\n        state = 5 /* DomainChar */;\n        // After having read a '.' and then a valid domain character,\n        // we now know that the domain part of the email is valid, and\n        // we have found at least a partial EmailMatch (however, the\n        // email address may have additional characters from this point)\n        currentEmailMatch = new CurrentEmailMatch(__assign(__assign({}, currentEmailMatch), {\n          hasDomainDot: true\n        }));\n      } else {\n        // Anything else\n        captureMatchIfValidAndReset();\n      }\n    }\n    function beginEmailMatch(newState) {\n      if (newState === void 0) {\n        newState = 2 /* LocalPart */;\n      }\n      state = newState;\n      currentEmailMatch = new CurrentEmailMatch({\n        idx: charIdx\n      });\n    }\n    function resetToNonEmailMatchState() {\n      state = 0 /* NonEmailMatch */;\n      currentEmailMatch = noCurrentEmailMatch;\n    }\n    /*\n     * Captures the current email address as an EmailMatch if it's valid,\n     * and resets the state to read another email address.\n     */\n    function captureMatchIfValidAndReset() {\n      if (currentEmailMatch.hasDomainDot) {\n        // we need at least one dot in the domain to be considered a valid email address\n        var matchedText = text.slice(currentEmailMatch.idx, charIdx);\n        // If we read a '.' or '-' char that ended the email address\n        // (valid domain name characters, but only valid email address\n        // characters if they are followed by something else), strip\n        // it off now\n        if (/[-.]$/.test(matchedText)) {\n          matchedText = matchedText.slice(0, -1);\n        }\n        var emailAddress = currentEmailMatch.hasMailtoPrefix ? matchedText.slice('mailto:'.length) : matchedText;\n        // if the email address has a valid TLD, add it to the list of matches\n        if (doesEmailHaveValidTld(emailAddress)) {\n          matches.push(new EmailMatch({\n            tagBuilder: tagBuilder,\n            matchedText: matchedText,\n            offset: currentEmailMatch.idx,\n            email: emailAddress\n          }));\n        }\n      }\n      resetToNonEmailMatchState();\n      /**\n       * Determines if the given email address has a valid TLD or not\n       * @param {string} emailAddress - email address\n       * @return {Boolean} - true is email have valid TLD, false otherwise\n       */\n      function doesEmailHaveValidTld(emailAddress) {\n        var emailAddressTld = emailAddress.split('.').pop() || '';\n        var emailAddressNormalized = emailAddressTld.toLowerCase();\n        var isValidTld = strictTldRegex.test(emailAddressNormalized);\n        return isValidTld;\n      }\n    }\n  };\n  return EmailMatcher;\n}(Matcher);\nexport { EmailMatcher };\nvar CurrentEmailMatch = /** @class */function () {\n  function CurrentEmailMatch(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    this.idx = cfg.idx !== undefined ? cfg.idx : -1;\n    this.hasMailtoPrefix = !!cfg.hasMailtoPrefix;\n    this.hasDomainDot = !!cfg.hasDomainDot;\n  }\n  return CurrentEmailMatch;\n}();","map":{"version":3,"names":["Matcher","alphaNumericAndMarksCharsStr","domainNameCharRegex","EmailMatch","throwUnhandledCaseError","tldRegex","localPartCharRegex","RegExp","concat","strictTldRegex","source","EmailMatcher","_super","__extends","_this","apply","arguments","prototype","parseMatches","text","tagBuilder","matches","len","length","noCurrentEmailMatch","CurrentEmailMatch","mailtoTransitions","m","a","i","l","t","o","charIdx","state","currentEmailMatch","char","charAt","stateNonEmailAddress","stateMailTo","stateLocalPart","stateLocalPartDot","stateAtSign","stateDomainChar","stateDomainHyphen","stateDomainDot","captureMatchIfValidAndReset","beginEmailMatch","test","prevChar","__assign","hasMailtoPrefix","resetToNonEmailMatchState","hasDomainDot","newState","idx","matchedText","slice","emailAddress","doesEmailHaveValidTld","push","offset","email","emailAddressTld","split","pop","emailAddressNormalized","toLowerCase","isValidTld","cfg","undefined"],"sources":["../../../src/matcher/email-matcher.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}