{"ast":null,"code":"/**\n * Zenscroll 4.0.2\n * https://github.com/zengabor/zenscroll/\n *\n * Copyright 2015–2018 Gabor Lenard\n *\n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org>\n * \n */\n\n/*jshint devel:true, asi:true */\n\n/*global define, module */\n\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory());\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    (function install() {\n      // To make sure Zenscroll can be referenced from the header, before `body` is available\n      if (document && document.body) {\n        root.zenscroll = factory();\n      } else {\n        // retry 9ms later\n        setTimeout(install, 9);\n      }\n    })();\n  }\n})(this, function () {\n  \"use strict\";\n\n  // Detect if the browser already supports native smooth scrolling (e.g., Firefox 36+ and Chrome 49+) and it is enabled:\n  var isNativeSmoothScrollEnabledOn = function (elem) {\n    return elem && \"getComputedStyle\" in window && window.getComputedStyle(elem)[\"scroll-behavior\"] === \"smooth\";\n  };\n\n  // Exit if it’s not a browser environment:\n  if (typeof window === \"undefined\" || !(\"document\" in window)) {\n    return {};\n  }\n  var makeScroller = function (container, defaultDuration, edgeOffset) {\n    // Use defaults if not provided\n    defaultDuration = defaultDuration || 999; //ms\n    if (!edgeOffset && edgeOffset !== 0) {\n      // When scrolling, this amount of distance is kept from the edges of the container:\n      edgeOffset = 9; //px\n    }\n\n    // Handling the life-cycle of the scroller\n    var scrollTimeoutId;\n    var setScrollTimeoutId = function (newValue) {\n      scrollTimeoutId = newValue;\n    };\n\n    /**\n     * Stop the current smooth scroll operation immediately\n     */\n    var stopScroll = function () {\n      clearTimeout(scrollTimeoutId);\n      setScrollTimeoutId(0);\n    };\n    var getTopWithEdgeOffset = function (elem) {\n      return Math.max(0, container.getTopOf(elem) - edgeOffset);\n    };\n\n    /**\n     * Scrolls to a specific vertical position in the document.\n     *\n     * @param {targetY} The vertical position within the document.\n     * @param {duration} Optionally the duration of the scroll operation.\n     *        If not provided the default duration is used.\n     * @param {onDone} An optional callback function to be invoked once the scroll finished.\n     */\n    var scrollToY = function (targetY, duration, onDone) {\n      stopScroll();\n      if (duration === 0 || duration && duration < 0 || isNativeSmoothScrollEnabledOn(container.body)) {\n        container.toY(targetY);\n        if (onDone) {\n          onDone();\n        }\n      } else {\n        var startY = container.getY();\n        var distance = Math.max(0, targetY) - startY;\n        var startTime = new Date().getTime();\n        duration = duration || Math.min(Math.abs(distance), defaultDuration);\n        (function loopScroll() {\n          setScrollTimeoutId(setTimeout(function () {\n            // Calculate percentage:\n            var p = Math.min(1, (new Date().getTime() - startTime) / duration);\n            // Calculate the absolute vertical position:\n            var y = Math.max(0, Math.floor(startY + distance * (p < 0.5 ? 2 * p * p : p * (4 - p * 2) - 1)));\n            container.toY(y);\n            if (p < 1 && container.getHeight() + y < container.body.scrollHeight) {\n              loopScroll();\n            } else {\n              setTimeout(stopScroll, 99); // with cooldown time\n              if (onDone) {\n                onDone();\n              }\n            }\n          }, 9));\n        })();\n      }\n    };\n\n    /**\n     * Scrolls to the top of a specific element.\n     *\n     * @param {elem} The element to scroll to.\n     * @param {duration} Optionally the duration of the scroll operation.\n     * @param {onDone} An optional callback function to be invoked once the scroll finished.\n     */\n    var scrollToElem = function (elem, duration, onDone) {\n      scrollToY(getTopWithEdgeOffset(elem), duration, onDone);\n    };\n\n    /**\n     * Scrolls an element into view if necessary.\n     *\n     * @param {elem} The element.\n     * @param {duration} Optionally the duration of the scroll operation.\n     * @param {onDone} An optional callback function to be invoked once the scroll finished.\n     */\n    var scrollIntoView = function (elem, duration, onDone) {\n      var elemHeight = elem.getBoundingClientRect().height;\n      var elemBottom = container.getTopOf(elem) + elemHeight;\n      var containerHeight = container.getHeight();\n      var y = container.getY();\n      var containerBottom = y + containerHeight;\n      if (getTopWithEdgeOffset(elem) < y || elemHeight + edgeOffset > containerHeight) {\n        // Element is clipped at top or is higher than screen.\n        scrollToElem(elem, duration, onDone);\n      } else if (elemBottom + edgeOffset > containerBottom) {\n        // Element is clipped at the bottom.\n        scrollToY(elemBottom - containerHeight + edgeOffset, duration, onDone);\n      } else if (onDone) {\n        onDone();\n      }\n    };\n\n    /**\n     * Scrolls to the center of an element.\n     *\n     * @param {elem} The element.\n     * @param {duration} Optionally the duration of the scroll operation.\n     * @param {offset} Optionally the offset of the top of the element from the center of the screen.\n     *        A value of 0 is ignored.\n     * @param {onDone} An optional callback function to be invoked once the scroll finished.\n     */\n    var scrollToCenterOf = function (elem, duration, offset, onDone) {\n      scrollToY(Math.max(0, container.getTopOf(elem) - container.getHeight() / 2 + (offset || elem.getBoundingClientRect().height / 2)), duration, onDone);\n    };\n\n    /**\n     * Changes default settings for this scroller.\n     *\n     * @param {newDefaultDuration} Optionally a new value for default duration, used for each scroll method by default.\n     *        Ignored if null or undefined.\n     * @param {newEdgeOffset} Optionally a new value for the edge offset, used by each scroll method by default. Ignored if null or undefined.\n     * @returns An object with the current values.\n     */\n    var setup = function (newDefaultDuration, newEdgeOffset) {\n      if (newDefaultDuration === 0 || newDefaultDuration) {\n        defaultDuration = newDefaultDuration;\n      }\n      if (newEdgeOffset === 0 || newEdgeOffset) {\n        edgeOffset = newEdgeOffset;\n      }\n      return {\n        defaultDuration: defaultDuration,\n        edgeOffset: edgeOffset\n      };\n    };\n    return {\n      setup: setup,\n      to: scrollToElem,\n      toY: scrollToY,\n      intoView: scrollIntoView,\n      center: scrollToCenterOf,\n      stop: stopScroll,\n      moving: function () {\n        return !!scrollTimeoutId;\n      },\n      getY: container.getY,\n      getTopOf: container.getTopOf\n    };\n  };\n  var docElem = document.documentElement;\n  var getDocY = function () {\n    return window.scrollY || docElem.scrollTop;\n  };\n\n  // Create a scroller for the document:\n  var zenscroll = makeScroller({\n    body: document.scrollingElement || document.body,\n    toY: function (y) {\n      window.scrollTo(0, y);\n    },\n    getY: getDocY,\n    getHeight: function () {\n      return window.innerHeight || docElem.clientHeight;\n    },\n    getTopOf: function (elem) {\n      return elem.getBoundingClientRect().top + getDocY() - docElem.offsetTop;\n    }\n  });\n\n  /**\n   * Creates a scroller from the provided container element (e.g., a DIV)\n   *\n   * @param {scrollContainer} The vertical position within the document.\n   * @param {defaultDuration} Optionally a value for default duration, used for each scroll method by default.\n   *        Ignored if 0 or null or undefined.\n   * @param {edgeOffset} Optionally a value for the edge offset, used by each scroll method by default. \n   *        Ignored if null or undefined.\n   * @returns A scroller object, similar to `zenscroll` but controlling the provided element.\n   */\n  zenscroll.createScroller = function (scrollContainer, defaultDuration, edgeOffset) {\n    return makeScroller({\n      body: scrollContainer,\n      toY: function (y) {\n        scrollContainer.scrollTop = y;\n      },\n      getY: function () {\n        return scrollContainer.scrollTop;\n      },\n      getHeight: function () {\n        return Math.min(scrollContainer.clientHeight, window.innerHeight || docElem.clientHeight);\n      },\n      getTopOf: function (elem) {\n        return elem.offsetTop;\n      }\n    }, defaultDuration, edgeOffset);\n  };\n\n  // Automatic link-smoothing on achors\n  // Exclude IE8- or when native is enabled or Zenscroll auto- is disabled\n  if (\"addEventListener\" in window && !window.noZensmooth && !isNativeSmoothScrollEnabledOn(document.body)) {\n    var isHistorySupported = \"history\" in window && \"pushState\" in history;\n    var isScrollRestorationSupported = isHistorySupported && \"scrollRestoration\" in history;\n\n    // On first load & refresh make sure the browser restores the position first\n    if (isScrollRestorationSupported) {\n      history.scrollRestoration = \"auto\";\n    }\n    window.addEventListener(\"load\", function () {\n      if (isScrollRestorationSupported) {\n        // Set it to manual\n        setTimeout(function () {\n          history.scrollRestoration = \"manual\";\n        }, 9);\n        window.addEventListener(\"popstate\", function (event) {\n          if (event.state && \"zenscrollY\" in event.state) {\n            zenscroll.toY(event.state.zenscrollY);\n          }\n        }, false);\n      }\n\n      // Add edge offset on first load if necessary\n      // This may not work on IE (or older computer?) as it requires more timeout, around 100 ms\n      if (window.location.hash) {\n        setTimeout(function () {\n          // Adjustment is only needed if there is an edge offset:\n          var edgeOffset = zenscroll.setup().edgeOffset;\n          if (edgeOffset) {\n            var targetElem = document.getElementById(window.location.href.split(\"#\")[1]);\n            if (targetElem) {\n              var targetY = Math.max(0, zenscroll.getTopOf(targetElem) - edgeOffset);\n              var diff = zenscroll.getY() - targetY;\n              // Only do the adjustment if the browser is very close to the element:\n              if (0 <= diff && diff < 9) {\n                window.scrollTo(0, targetY);\n              }\n            }\n          }\n        }, 9);\n      }\n    }, false);\n\n    // Handling clicks on anchors\n    var RE_noZensmooth = new RegExp(\"(^|\\\\s)noZensmooth(\\\\s|$)\");\n    window.addEventListener(\"click\", function (event) {\n      var anchor = event.target;\n      while (anchor && anchor.tagName !== \"A\") {\n        anchor = anchor.parentNode;\n      }\n      // Let the browser handle the click if it wasn't with the primary button, or with some modifier keys:\n      if (!anchor || event.which !== 1 || event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n        return;\n      }\n      // Save the current scrolling position so it can be used for scroll restoration:\n      if (isScrollRestorationSupported) {\n        var historyState = history.state && typeof history.state === \"object\" ? history.state : {};\n        historyState.zenscrollY = zenscroll.getY();\n        try {\n          history.replaceState(historyState, \"\");\n        } catch (e) {\n          // Avoid the Chrome Security exception on file protocol, e.g., file://index.html\n        }\n      }\n      // Find the referenced ID:\n      var href = anchor.getAttribute(\"href\") || \"\";\n      if (href.indexOf(\"#\") === 0 && !RE_noZensmooth.test(anchor.className)) {\n        var targetY = 0;\n        var targetElem = document.getElementById(href.substring(1));\n        if (href !== \"#\") {\n          if (!targetElem) {\n            // Let the browser handle the click if the target ID is not found.\n            return;\n          }\n          targetY = zenscroll.getTopOf(targetElem);\n        }\n        event.preventDefault();\n        // By default trigger the browser's `hashchange` event...\n        var onDone = function () {\n          window.location = href;\n        };\n        // ...unless there is an edge offset specified\n        var edgeOffset = zenscroll.setup().edgeOffset;\n        if (edgeOffset) {\n          targetY = Math.max(0, targetY - edgeOffset);\n          if (isHistorySupported) {\n            onDone = function () {\n              history.pushState({}, \"\", href);\n            };\n          }\n        }\n        zenscroll.toY(targetY, null, onDone);\n      }\n    }, false);\n  }\n  return zenscroll;\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","install","document","body","zenscroll","setTimeout","isNativeSmoothScrollEnabledOn","elem","window","getComputedStyle","makeScroller","container","defaultDuration","edgeOffset","scrollTimeoutId","setScrollTimeoutId","newValue","stopScroll","clearTimeout","getTopWithEdgeOffset","Math","max","getTopOf","scrollToY","targetY","duration","onDone","toY","startY","getY","distance","startTime","Date","getTime","min","abs","loopScroll","p","y","floor","getHeight","scrollHeight","scrollToElem","scrollIntoView","elemHeight","getBoundingClientRect","height","elemBottom","containerHeight","containerBottom","scrollToCenterOf","offset","setup","newDefaultDuration","newEdgeOffset","to","intoView","center","stop","moving","docElem","documentElement","getDocY","scrollY","scrollTop","scrollingElement","scrollTo","innerHeight","clientHeight","top","offsetTop","createScroller","scrollContainer","noZensmooth","isHistorySupported","history","isScrollRestorationSupported","scrollRestoration","addEventListener","event","state","zenscrollY","location","hash","targetElem","getElementById","href","split","diff","RE_noZensmooth","RegExp","anchor","target","tagName","parentNode","which","shiftKey","metaKey","ctrlKey","altKey","historyState","replaceState","e","getAttribute","indexOf","test","className","substring","preventDefault","pushState"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/zenscroll/zenscroll.js"],"sourcesContent":["/**\n * Zenscroll 4.0.2\n * https://github.com/zengabor/zenscroll/\n *\n * Copyright 2015–2018 Gabor Lenard\n *\n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org>\n * \n */\n\n/*jshint devel:true, asi:true */\n\n/*global define, module */\n\n\n(function (root, factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine([], factory())\n\t} else if (typeof module === \"object\" && module.exports) {\n\t\tmodule.exports = factory()\n\t} else {\n\t\t(function install() {\n\t\t\t// To make sure Zenscroll can be referenced from the header, before `body` is available\n\t\t\tif (document && document.body) {\n\t\t\t\troot.zenscroll = factory()\n\t\t\t} else {\n\t\t\t\t// retry 9ms later\n\t\t\t\tsetTimeout(install, 9)\n\t\t\t}\n\t\t})()\n\t}\n}(this, function () {\n\t\"use strict\"\n\n\n\t// Detect if the browser already supports native smooth scrolling (e.g., Firefox 36+ and Chrome 49+) and it is enabled:\n\tvar isNativeSmoothScrollEnabledOn = function (elem) {\n\t\treturn elem && \"getComputedStyle\" in window &&\n\t\t\twindow.getComputedStyle(elem)[\"scroll-behavior\"] === \"smooth\"\n\t}\n\n\n\t// Exit if it’s not a browser environment:\n\tif (typeof window === \"undefined\" || !(\"document\" in window)) {\n\t\treturn {}\n\t}\n\n\n\tvar makeScroller = function (container, defaultDuration, edgeOffset) {\n\n\t\t// Use defaults if not provided\n\t\tdefaultDuration = defaultDuration || 999 //ms\n\t\tif (!edgeOffset && edgeOffset !== 0) {\n\t\t\t// When scrolling, this amount of distance is kept from the edges of the container:\n\t\t\tedgeOffset = 9 //px\n\t\t}\n\n\t\t// Handling the life-cycle of the scroller\n\t\tvar scrollTimeoutId\n\t\tvar setScrollTimeoutId = function (newValue) {\n\t\t\tscrollTimeoutId = newValue\n\t\t}\n\n\t\t/**\n\t\t * Stop the current smooth scroll operation immediately\n\t\t */\n\t\tvar stopScroll = function () {\n\t\t\tclearTimeout(scrollTimeoutId)\n\t\t\tsetScrollTimeoutId(0)\n\t\t}\n\n\t\tvar getTopWithEdgeOffset = function (elem) {\n\t\t\treturn Math.max(0, container.getTopOf(elem) - edgeOffset)\n\t\t}\n\n\t\t/**\n\t\t * Scrolls to a specific vertical position in the document.\n\t\t *\n\t\t * @param {targetY} The vertical position within the document.\n\t\t * @param {duration} Optionally the duration of the scroll operation.\n\t\t *        If not provided the default duration is used.\n\t\t * @param {onDone} An optional callback function to be invoked once the scroll finished.\n\t\t */\n\t\tvar scrollToY = function (targetY, duration, onDone) {\n\t\t\tstopScroll()\n\t\t\tif (duration === 0 || (duration && duration < 0) || isNativeSmoothScrollEnabledOn(container.body)) {\n\t\t\t\tcontainer.toY(targetY)\n\t\t\t\tif (onDone) {\n\t\t\t\t\tonDone()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar startY = container.getY()\n\t\t\t\tvar distance = Math.max(0, targetY) - startY\n\t\t\t\tvar startTime = new Date().getTime()\n\t\t\t\tduration = duration || Math.min(Math.abs(distance), defaultDuration);\n\t\t\t\t(function loopScroll() {\n\t\t\t\t\tsetScrollTimeoutId(setTimeout(function () {\n\t\t\t\t\t\t// Calculate percentage:\n\t\t\t\t\t\tvar p = Math.min(1, (new Date().getTime() - startTime) / duration)\n\t\t\t\t\t\t// Calculate the absolute vertical position:\n\t\t\t\t\t\tvar y = Math.max(0, Math.floor(startY + distance*(p < 0.5 ? 2*p*p : p*(4 - p*2)-1)))\n\t\t\t\t\t\tcontainer.toY(y)\n\t\t\t\t\t\tif (p < 1 && (container.getHeight() + y) < container.body.scrollHeight) {\n\t\t\t\t\t\t\tloopScroll()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetTimeout(stopScroll, 99) // with cooldown time\n\t\t\t\t\t\t\tif (onDone) {\n\t\t\t\t\t\t\t\tonDone()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 9))\n\t\t\t\t})()\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Scrolls to the top of a specific element.\n\t\t *\n\t\t * @param {elem} The element to scroll to.\n\t\t * @param {duration} Optionally the duration of the scroll operation.\n\t\t * @param {onDone} An optional callback function to be invoked once the scroll finished.\n\t\t */\n\t\tvar scrollToElem = function (elem, duration, onDone) {\n\t\t\tscrollToY(getTopWithEdgeOffset(elem), duration, onDone)\n\t\t}\n\n\t\t/**\n\t\t * Scrolls an element into view if necessary.\n\t\t *\n\t\t * @param {elem} The element.\n\t\t * @param {duration} Optionally the duration of the scroll operation.\n\t\t * @param {onDone} An optional callback function to be invoked once the scroll finished.\n\t\t */\n\t\tvar scrollIntoView = function (elem, duration, onDone) {\n\t\t\tvar elemHeight = elem.getBoundingClientRect().height\n\t\t\tvar elemBottom = container.getTopOf(elem) + elemHeight\n\t\t\tvar containerHeight = container.getHeight()\n\t\t\tvar y = container.getY()\n\t\t\tvar containerBottom = y + containerHeight\n\t\t\tif (getTopWithEdgeOffset(elem) < y || (elemHeight + edgeOffset) > containerHeight) {\n\t\t\t\t// Element is clipped at top or is higher than screen.\n\t\t\t\tscrollToElem(elem, duration, onDone)\n\t\t\t} else if ((elemBottom + edgeOffset) > containerBottom) {\n\t\t\t\t// Element is clipped at the bottom.\n\t\t\t\tscrollToY(elemBottom - containerHeight + edgeOffset, duration, onDone)\n\t\t\t} else if (onDone) {\n\t\t\t\tonDone()\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Scrolls to the center of an element.\n\t\t *\n\t\t * @param {elem} The element.\n\t\t * @param {duration} Optionally the duration of the scroll operation.\n\t\t * @param {offset} Optionally the offset of the top of the element from the center of the screen.\n\t\t *        A value of 0 is ignored.\n\t\t * @param {onDone} An optional callback function to be invoked once the scroll finished.\n\t\t */\n\t\tvar scrollToCenterOf = function (elem, duration, offset, onDone) {\n\t\t\tscrollToY(Math.max(0, container.getTopOf(elem) - container.getHeight()/2 + (offset || elem.getBoundingClientRect().height/2)), duration, onDone)\n\t\t}\n\n\t\t/**\n\t\t * Changes default settings for this scroller.\n\t\t *\n\t\t * @param {newDefaultDuration} Optionally a new value for default duration, used for each scroll method by default.\n\t\t *        Ignored if null or undefined.\n\t\t * @param {newEdgeOffset} Optionally a new value for the edge offset, used by each scroll method by default. Ignored if null or undefined.\n\t\t * @returns An object with the current values.\n\t\t */\n\t\tvar setup = function (newDefaultDuration, newEdgeOffset) {\n\t\t\tif (newDefaultDuration === 0 || newDefaultDuration) {\n\t\t\t\tdefaultDuration = newDefaultDuration\n\t\t\t}\n\t\t\tif (newEdgeOffset === 0 || newEdgeOffset) {\n\t\t\t\tedgeOffset = newEdgeOffset\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tdefaultDuration: defaultDuration,\n\t\t\t\tedgeOffset: edgeOffset\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsetup: setup,\n\t\t\tto: scrollToElem,\n\t\t\ttoY: scrollToY,\n\t\t\tintoView: scrollIntoView,\n\t\t\tcenter: scrollToCenterOf,\n\t\t\tstop: stopScroll,\n\t\t\tmoving: function () { return !!scrollTimeoutId },\n\t\t\tgetY: container.getY,\n\t\t\tgetTopOf: container.getTopOf\n\t\t}\n\n\t}\n\n\n\tvar docElem = document.documentElement\n\tvar getDocY = function () { return window.scrollY || docElem.scrollTop }\n\n\t// Create a scroller for the document:\n\tvar zenscroll = makeScroller({\n\t\tbody: document.scrollingElement || document.body,\n\t\ttoY: function (y) { window.scrollTo(0, y) },\n\t\tgetY: getDocY,\n\t\tgetHeight: function () { return window.innerHeight || docElem.clientHeight },\n\t\tgetTopOf: function (elem) { return elem.getBoundingClientRect().top + getDocY() - docElem.offsetTop }\n\t})\n\n\n\t/**\n\t * Creates a scroller from the provided container element (e.g., a DIV)\n\t *\n\t * @param {scrollContainer} The vertical position within the document.\n\t * @param {defaultDuration} Optionally a value for default duration, used for each scroll method by default.\n\t *        Ignored if 0 or null or undefined.\n\t * @param {edgeOffset} Optionally a value for the edge offset, used by each scroll method by default. \n\t *        Ignored if null or undefined.\n\t * @returns A scroller object, similar to `zenscroll` but controlling the provided element.\n\t */\n\tzenscroll.createScroller = function (scrollContainer, defaultDuration, edgeOffset) {\n\t\treturn makeScroller({\n\t\t\tbody: scrollContainer,\n\t\t\ttoY: function (y) { scrollContainer.scrollTop = y },\n\t\t\tgetY: function () { return scrollContainer.scrollTop },\n\t\t\tgetHeight: function () { return Math.min(scrollContainer.clientHeight, window.innerHeight || docElem.clientHeight) },\n\t\t\tgetTopOf: function (elem) { return elem.offsetTop }\n\t\t}, defaultDuration, edgeOffset)\n\t}\n\n\n\t// Automatic link-smoothing on achors\n\t// Exclude IE8- or when native is enabled or Zenscroll auto- is disabled\n\tif (\"addEventListener\" in window && !window.noZensmooth && !isNativeSmoothScrollEnabledOn(document.body)) {\n\n\t\tvar isHistorySupported = \"history\" in window && \"pushState\" in history\n\t\tvar isScrollRestorationSupported = isHistorySupported && \"scrollRestoration\" in history\n\n\t\t// On first load & refresh make sure the browser restores the position first\n\t\tif (isScrollRestorationSupported) {\n\t\t\thistory.scrollRestoration = \"auto\"\n\t\t}\n\n\t\twindow.addEventListener(\"load\", function () {\n\n\t\t\tif (isScrollRestorationSupported) {\n\t\t\t\t// Set it to manual\n\t\t\t\tsetTimeout(function () { history.scrollRestoration = \"manual\" }, 9)\n\t\t\t\twindow.addEventListener(\"popstate\", function (event) {\n\t\t\t\t\tif (event.state && \"zenscrollY\" in event.state) {\n\t\t\t\t\t\tzenscroll.toY(event.state.zenscrollY)\n\t\t\t\t\t}\n\t\t\t\t}, false)\n\t\t\t}\n\n\t\t\t// Add edge offset on first load if necessary\n\t\t\t// This may not work on IE (or older computer?) as it requires more timeout, around 100 ms\n\t\t\tif (window.location.hash) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t// Adjustment is only needed if there is an edge offset:\n\t\t\t\t\tvar edgeOffset = zenscroll.setup().edgeOffset\n\t\t\t\t\tif (edgeOffset) {\n\t\t\t\t\t\tvar targetElem = document.getElementById(window.location.href.split(\"#\")[1])\n\t\t\t\t\t\tif (targetElem) {\n\t\t\t\t\t\t\tvar targetY = Math.max(0, zenscroll.getTopOf(targetElem) - edgeOffset)\n\t\t\t\t\t\t\tvar diff = zenscroll.getY() - targetY\n\t\t\t\t\t\t\t// Only do the adjustment if the browser is very close to the element:\n\t\t\t\t\t\t\tif (0 <= diff && diff < 9 ) {\n\t\t\t\t\t\t\t\twindow.scrollTo(0, targetY)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 9)\n\t\t\t}\n\n\t\t}, false)\n\n\t\t// Handling clicks on anchors\n\t\tvar RE_noZensmooth = new RegExp(\"(^|\\\\s)noZensmooth(\\\\s|$)\")\n\t\twindow.addEventListener(\"click\", function (event) {\n\t\t\tvar anchor = event.target\n\t\t\twhile (anchor && anchor.tagName !== \"A\") {\n\t\t\t\tanchor = anchor.parentNode\n\t\t\t}\n\t\t\t// Let the browser handle the click if it wasn't with the primary button, or with some modifier keys:\n\t\t\tif (!anchor || event.which !== 1 || event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Save the current scrolling position so it can be used for scroll restoration:\n\t\t\tif (isScrollRestorationSupported) {\n\t\t\t\tvar historyState = history.state && typeof history.state === \"object\" ? history.state : {}\n\t\t\t\thistoryState.zenscrollY = zenscroll.getY()\n\t\t\t\ttry {\n\t\t\t\t\thistory.replaceState(historyState, \"\")\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Avoid the Chrome Security exception on file protocol, e.g., file://index.html\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Find the referenced ID:\n\t\t\tvar href = anchor.getAttribute(\"href\") || \"\"\n\t\t\tif (href.indexOf(\"#\") === 0 && !RE_noZensmooth.test(anchor.className)) {\n\t\t\t\tvar targetY = 0\n\t\t\t\tvar targetElem = document.getElementById(href.substring(1))\n\t\t\t\tif (href !== \"#\") {\n\t\t\t\t\tif (!targetElem) {\n\t\t\t\t\t\t// Let the browser handle the click if the target ID is not found.\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\ttargetY = zenscroll.getTopOf(targetElem)\n\t\t\t\t}\n\t\t\t\tevent.preventDefault()\n\t\t\t\t// By default trigger the browser's `hashchange` event...\n\t\t\t\tvar onDone = function () { window.location = href }\n\t\t\t\t// ...unless there is an edge offset specified\n\t\t\t\tvar edgeOffset = zenscroll.setup().edgeOffset\n\t\t\t\tif (edgeOffset) {\n\t\t\t\t\ttargetY = Math.max(0, targetY - edgeOffset)\n\t\t\t\t\tif (isHistorySupported) {\n\t\t\t\t\t\tonDone = function () { history.pushState({}, \"\", href) }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzenscroll.toY(targetY, null, onDone)\n\t\t\t}\n\t\t}, false)\n\n\t}\n\n\n\treturn zenscroll\n\n\n}));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}