{"ast":null,"code":"import applyTo from \"./applyTo.js\";\nimport _curry2 from \"./internal/_curry2.js\";\nimport _reduce from \"./internal/_reduce.js\";\n\n/**\n * Takes the value of an expression and applies it to a function\n * which is the left-to-right serial composition of the functions\n * given in the second argument.\n *\n * The functions in the pipeline should be unary functions.\n *\n * `flow` is helps to avoid introducing an extra function with named arguments\n * for computing the result of a function pipeline which depends on given initial values.\n * Rather than defining a referential transparent function `f = (_x, _y) => R.pipe(g(_x), h(_y), …)`\n * which is only later needed once `z = f(x, y)`,\n * the introduction of `f`, `_x` and `_y` can be avoided: `z = flow(x, [g, h(y),…]`\n *\n * In some libraries this function is named `pipe`.\n *\n * @func\n * @memberOf R\n * @since v0.30.0\n * @category Function\n * @sig a → [(a → b), …, (y → z)] → z\n * @param {*} a The seed value\n * @param {Array<Function>} pipeline functions composing the pipeline\n * @return {*} z The result of applying the seed value to the function pipeline\n * @see R.pipe\n * @example\n *      R.flow(9, [Math.sqrt, R.negate, R.inc]); //=> -2\n *\n *      const personObj = { first: 'Jane', last: 'Doe' };\n *      const fullName = R.flow(personObj, [R.values, R.join(' ')]); //=> \"Jane Doe\"\n *      const givenName = R.flow('    ', [R.trim, R.when(R.isEmpty, R.always(fullName))]); //=> \"Jane Doe\"\n */\nvar flow = /*#__PURE__*/_curry2(function flow(seed, pipeline) {\n  return _reduce(applyTo, seed, pipeline);\n});\nexport default flow;","map":{"version":3,"names":["applyTo","_curry2","_reduce","flow","seed","pipeline"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/ramda/es/flow.js"],"sourcesContent":["import applyTo from \"./applyTo.js\";\nimport _curry2 from \"./internal/_curry2.js\";\nimport _reduce from \"./internal/_reduce.js\";\n\n/**\n * Takes the value of an expression and applies it to a function\n * which is the left-to-right serial composition of the functions\n * given in the second argument.\n *\n * The functions in the pipeline should be unary functions.\n *\n * `flow` is helps to avoid introducing an extra function with named arguments\n * for computing the result of a function pipeline which depends on given initial values.\n * Rather than defining a referential transparent function `f = (_x, _y) => R.pipe(g(_x), h(_y), …)`\n * which is only later needed once `z = f(x, y)`,\n * the introduction of `f`, `_x` and `_y` can be avoided: `z = flow(x, [g, h(y),…]`\n *\n * In some libraries this function is named `pipe`.\n *\n * @func\n * @memberOf R\n * @since v0.30.0\n * @category Function\n * @sig a → [(a → b), …, (y → z)] → z\n * @param {*} a The seed value\n * @param {Array<Function>} pipeline functions composing the pipeline\n * @return {*} z The result of applying the seed value to the function pipeline\n * @see R.pipe\n * @example\n *      R.flow(9, [Math.sqrt, R.negate, R.inc]); //=> -2\n *\n *      const personObj = { first: 'Jane', last: 'Doe' };\n *      const fullName = R.flow(personObj, [R.values, R.join(' ')]); //=> \"Jane Doe\"\n *      const givenName = R.flow('    ', [R.trim, R.when(R.isEmpty, R.always(fullName))]); //=> \"Jane Doe\"\n */\nvar flow = /*#__PURE__*/_curry2(function flow(seed, pipeline) {\n  return _reduce(applyTo, seed, pipeline);\n});\nexport default flow;"],"mappings":"AAAA,OAAOA,OAAO,MAAM,cAAc;AAClC,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,OAAO,MAAM,uBAAuB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,IAAI,GAAG,aAAaF,OAAO,CAAC,SAASE,IAAIA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EAC5D,OAAOH,OAAO,CAACF,OAAO,EAAEI,IAAI,EAAEC,QAAQ,CAAC;AACzC,CAAC,CAAC;AACF,eAAeF,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}