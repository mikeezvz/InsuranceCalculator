{"ast":null,"code":"import { ApiDOMStructuredError } from '@swagger-api/apidom-error';\n\n/**\n * SPDX-FileCopyrightText: Copyright (c) GraphQL Contributors\n *\n * SPDX-License-Identifier: MIT\n */\n\n// getVisitFn :: (Visitor, String, Boolean) -> Function\nexport const getVisitFn = (visitor, type, isLeaving) => {\n  const typeVisitor = visitor[type];\n  if (typeVisitor != null) {\n    if (!isLeaving && typeof typeVisitor === 'function') {\n      // { Type() {} }\n      return typeVisitor;\n    }\n    const typeSpecificVisitor = isLeaving ? typeVisitor.leave : typeVisitor.enter;\n    if (typeof typeSpecificVisitor === 'function') {\n      // { Type: { enter() {}, leave() {} } }\n      return typeSpecificVisitor;\n    }\n  } else {\n    const specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor != null) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      const specificTypeVisitor = specificVisitor[type];\n      if (typeof specificTypeVisitor === 'function') {\n        // { enter: { Type() {} }, leave: { Type() {} } }\n        return specificTypeVisitor;\n      }\n    }\n  }\n  return null;\n};\nexport const BREAK = {};\n\n// getNodeType :: Node -> String\nexport const getNodeType = node => node === null || node === void 0 ? void 0 : node.type;\n\n// isNode :: Node -> Boolean\nexport const isNode = node => typeof getNodeType(node) === 'string';\n\n// cloneNode :: a -> a\nexport const cloneNode = node => Object.create(Object.getPrototypeOf(node), Object.getOwnPropertyDescriptors(node));\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n * `exposeEdits=true` can be used to expose the edited node from the previous visitors.\n */\n\nexport const mergeAll = (visitors, {\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  exposeEdits = false\n} = {}) => {\n  const skipSymbol = Symbol('skip');\n  const skipping = new Array(visitors.length).fill(skipSymbol);\n  return {\n    enter(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      let hasChanged = false;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);\n          if (typeof visitFn === 'function') {\n            const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n\n            // check if the visitor is async\n            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {\n              throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n                visitor: visitors[i],\n                visitFn\n              });\n            }\n            if (result === skipVisitingNodeSymbol) {\n              skipping[i] = currentNode;\n            } else if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result === deleteNodeSymbol) {\n              return result;\n            } else if (result !== undefined) {\n              if (exposeEdits) {\n                currentNode = result;\n                hasChanged = true;\n              } else {\n                return result;\n              }\n            }\n          }\n        }\n      }\n      return hasChanged ? currentNode : undefined;\n    },\n    leave(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);\n          if (typeof visitFn === 'function') {\n            const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n\n            // check if the visitor is async\n            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {\n              throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n                visitor: visitors[i],\n                visitFn\n              });\n            }\n            if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result !== undefined && result !== skipVisitingNodeSymbol) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === currentNode) {\n          skipping[i] = skipSymbol;\n        }\n      }\n      return undefined;\n    }\n  };\n};\nconst mergeAllAsync = (visitors, {\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  exposeEdits = false\n} = {}) => {\n  const skipSymbol = Symbol('skip');\n  const skipping = new Array(visitors.length).fill(skipSymbol);\n  return {\n    async enter(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      let hasChanged = false;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);\n          if (typeof visitFn === 'function') {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n            if (result === skipVisitingNodeSymbol) {\n              skipping[i] = currentNode;\n            } else if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result === deleteNodeSymbol) {\n              return result;\n            } else if (result !== undefined) {\n              if (exposeEdits) {\n                currentNode = result;\n                hasChanged = true;\n              } else {\n                return result;\n              }\n            }\n          }\n        }\n      }\n      return hasChanged ? currentNode : undefined;\n    },\n    async leave(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);\n          if (typeof visitFn === 'function') {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n            if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result !== undefined && result !== skipVisitingNodeSymbol) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === currentNode) {\n          skipping[i] = skipSymbol;\n        }\n      }\n      return undefined;\n    }\n  };\n};\nmergeAll[Symbol.for('nodejs.util.promisify.custom')] = mergeAllAsync;\n\n/* eslint-disable no-continue, no-param-reassign */\n/**\n * visit() will walk through an AST using a preorder depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n *  @sig visit :: (Node, Visitor, Options)\n *  @sig      Options = { keyMap: Object, state: Object }\n */\nexport const visit = (\n// @ts-ignore\nroot,\n// @ts-ignore\nvisitor, {\n  keyMap = null,\n  state = {},\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  nodePredicate = isNode,\n  nodeCloneFn = cloneNode,\n  detectCycles = true\n} = {}) => {\n  const visitorKeys = keyMap || {};\n  let stack;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let parent;\n  let edits = [];\n  let node = root;\n  const path = [];\n  // @ts-ignore\n  const ancestors = [];\n  do {\n    index += 1;\n    const isLeaving = index === keys.length;\n    let key;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      // @ts-ignore\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          // @ts-ignore; creating clone\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === deleteNodeSymbol) {\n              node.splice(arrayKey, 1);\n              editOffset += 1;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          // creating clone\n          node = nodeCloneFn(node);\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      // @ts-ignore\n      edits = stack.edits;\n      // @ts-ignore\n      inArray = stack.inArray;\n      // @ts-ignore\n      stack = stack.prev;\n    } else if (parent !== deleteNodeSymbol && parent !== undefined) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === deleteNodeSymbol || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      var _result;\n      if (!nodePredicate(node)) {\n        throw new ApiDOMStructuredError(`Invalid AST Node:  ${String(node)}`, {\n          node\n        });\n      }\n\n      // cycle detected; skipping over a sub-tree to avoid recursion\n      if (detectCycles && ancestors.includes(node)) {\n        path.pop();\n        continue;\n      }\n      // call appropriate visitor function if available\n      const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);\n      if (visitFn) {\n        // assign state\n        for (const [stateKey, stateValue] of Object.entries(state)) {\n          visitor[stateKey] = stateValue;\n        }\n        const link = {\n          // eslint-disable-next-line @typescript-eslint/no-loop-func\n          replaceWith(newNode, replacer) {\n            if (typeof replacer === 'function') {\n              replacer(newNode, node, key, parent, path, ancestors);\n            } else if (parent) {\n              parent[key] = newNode;\n            }\n            if (!isLeaving) {\n              node = newNode;\n            }\n          }\n        };\n\n        // retrieve result\n        result = visitFn.call(visitor, node, key, parent, path, ancestors, link);\n      }\n\n      // check if the visitor is async\n      if (typeof ((_result = result) === null || _result === void 0 ? void 0 : _result.then) === 'function') {\n        throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n          visitor,\n          visitFn\n        });\n      }\n      if (result === breakSymbol) {\n        break;\n      }\n      if (result === skipVisitingNodeSymbol) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (nodePredicate(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (!isLeaving) {\n      var _visitorKeys$nodeType;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      // @ts-ignore\n      keys = inArray ? node : (_visitorKeys$nodeType = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType !== void 0 ? _visitorKeys$nodeType : [];\n      index = -1;\n      edits = [];\n      if (parent !== deleteNodeSymbol && parent !== undefined) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future\n  }\n  return root;\n};\n\n/**\n * Asynchronous version of visit.\n */\n// @ts-ignore\nvisit[Symbol.for('nodejs.util.promisify.custom')] = async (\n// @ts-ignore\nroot,\n// @ts-ignore\nvisitor, {\n  keyMap = null,\n  state = {},\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  nodePredicate = isNode,\n  nodeCloneFn = cloneNode,\n  detectCycles = true\n} = {}) => {\n  const visitorKeys = keyMap || {};\n  let stack;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let parent;\n  let edits = [];\n  let node = root;\n  const path = [];\n  // @ts-ignore\n  const ancestors = [];\n  do {\n    index += 1;\n    const isLeaving = index === keys.length;\n    let key;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      // @ts-ignore\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          // @ts-ignore; creating clone\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === deleteNodeSymbol) {\n              node.splice(arrayKey, 1);\n              editOffset += 1;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          // creating clone\n          node = nodeCloneFn(node);\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      // @ts-ignore\n      edits = stack.edits;\n      // @ts-ignore\n      inArray = stack.inArray;\n      // @ts-ignore\n      stack = stack.prev;\n    } else if (parent !== deleteNodeSymbol && parent !== undefined) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === deleteNodeSymbol || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      if (!nodePredicate(node)) {\n        throw new ApiDOMStructuredError(`Invalid AST Node: ${String(node)}`, {\n          node\n        });\n      }\n\n      // cycle detected; skipping over a sub-tree to avoid recursion\n      if (detectCycles && ancestors.includes(node)) {\n        path.pop();\n        continue;\n      }\n      const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);\n      if (visitFn) {\n        // assign state\n        for (const [stateKey, stateValue] of Object.entries(state)) {\n          visitor[stateKey] = stateValue;\n        }\n        const link = {\n          // eslint-disable-next-line @typescript-eslint/no-loop-func\n          replaceWith(newNode, replacer) {\n            if (typeof replacer === 'function') {\n              replacer(newNode, node, key, parent, path, ancestors);\n            } else if (parent) {\n              parent[key] = newNode;\n            }\n            if (!isLeaving) {\n              node = newNode;\n            }\n          }\n        };\n\n        // retrieve result\n        result = await visitFn.call(visitor, node, key, parent, path, ancestors, link); // eslint-disable-line no-await-in-loop\n      }\n      if (result === breakSymbol) {\n        break;\n      }\n      if (result === skipVisitingNodeSymbol) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (nodePredicate(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (!isLeaving) {\n      var _visitorKeys$nodeType2;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      // @ts-ignore\n      keys = inArray ? node : (_visitorKeys$nodeType2 = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType2 !== void 0 ? _visitorKeys$nodeType2 : [];\n      index = -1;\n      edits = [];\n      if (parent !== deleteNodeSymbol && parent !== undefined) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future\n  }\n  return root;\n};\n\n/* eslint-enable */","map":{"version":3,"names":["ApiDOMStructuredError","getVisitFn","visitor","type","isLeaving","typeVisitor","typeSpecificVisitor","leave","enter","specificVisitor","specificTypeVisitor","BREAK","getNodeType","node","isNode","cloneNode","Object","create","getPrototypeOf","getOwnPropertyDescriptors","mergeAll","visitors","visitFnGetter","nodeTypeGetter","breakSymbol","deleteNodeSymbol","skipVisitingNodeSymbol","exposeEdits","skipSymbol","Symbol","skipping","Array","length","fill","key","parent","path","ancestors","link","currentNode","hasChanged","linkProxy","replaceWith","newNode","replacer","i","visitFn","result","call","then","undefined","mergeAllAsync","for","visit","root","keyMap","state","nodePredicate","nodeCloneFn","detectCycles","visitorKeys","stack","inArray","isArray","keys","index","edits","isEdited","pop","slice","editOffset","editKey","editValue","arrayKey","splice","prev","push","_result","String","includes","stateKey","stateValue","entries","_visitorKeys$nodeType","_visitorKeys$nodeType2"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-ast/es/traversal/visitor.mjs"],"sourcesContent":["import { ApiDOMStructuredError } from '@swagger-api/apidom-error';\n\n/**\n * SPDX-FileCopyrightText: Copyright (c) GraphQL Contributors\n *\n * SPDX-License-Identifier: MIT\n */\n\n// getVisitFn :: (Visitor, String, Boolean) -> Function\nexport const getVisitFn = (visitor, type, isLeaving) => {\n  const typeVisitor = visitor[type];\n  if (typeVisitor != null) {\n    if (!isLeaving && typeof typeVisitor === 'function') {\n      // { Type() {} }\n      return typeVisitor;\n    }\n    const typeSpecificVisitor = isLeaving ? typeVisitor.leave : typeVisitor.enter;\n    if (typeof typeSpecificVisitor === 'function') {\n      // { Type: { enter() {}, leave() {} } }\n      return typeSpecificVisitor;\n    }\n  } else {\n    const specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor != null) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      const specificTypeVisitor = specificVisitor[type];\n      if (typeof specificTypeVisitor === 'function') {\n        // { enter: { Type() {} }, leave: { Type() {} } }\n        return specificTypeVisitor;\n      }\n    }\n  }\n  return null;\n};\nexport const BREAK = {};\n\n// getNodeType :: Node -> String\nexport const getNodeType = node => node === null || node === void 0 ? void 0 : node.type;\n\n// isNode :: Node -> Boolean\nexport const isNode = node => typeof getNodeType(node) === 'string';\n\n// cloneNode :: a -> a\nexport const cloneNode = node => Object.create(Object.getPrototypeOf(node), Object.getOwnPropertyDescriptors(node));\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n * `exposeEdits=true` can be used to expose the edited node from the previous visitors.\n */\n\nexport const mergeAll = (visitors, {\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  exposeEdits = false\n} = {}) => {\n  const skipSymbol = Symbol('skip');\n  const skipping = new Array(visitors.length).fill(skipSymbol);\n  return {\n    enter(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      let hasChanged = false;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);\n          if (typeof visitFn === 'function') {\n            const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n\n            // check if the visitor is async\n            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {\n              throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n                visitor: visitors[i],\n                visitFn\n              });\n            }\n            if (result === skipVisitingNodeSymbol) {\n              skipping[i] = currentNode;\n            } else if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result === deleteNodeSymbol) {\n              return result;\n            } else if (result !== undefined) {\n              if (exposeEdits) {\n                currentNode = result;\n                hasChanged = true;\n              } else {\n                return result;\n              }\n            }\n          }\n        }\n      }\n      return hasChanged ? currentNode : undefined;\n    },\n    leave(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);\n          if (typeof visitFn === 'function') {\n            const result = visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n\n            // check if the visitor is async\n            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {\n              throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n                visitor: visitors[i],\n                visitFn\n              });\n            }\n            if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result !== undefined && result !== skipVisitingNodeSymbol) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === currentNode) {\n          skipping[i] = skipSymbol;\n        }\n      }\n      return undefined;\n    }\n  };\n};\nconst mergeAllAsync = (visitors, {\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  exposeEdits = false\n} = {}) => {\n  const skipSymbol = Symbol('skip');\n  const skipping = new Array(visitors.length).fill(skipSymbol);\n  return {\n    async enter(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      let hasChanged = false;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), false);\n          if (typeof visitFn === 'function') {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n            if (result === skipVisitingNodeSymbol) {\n              skipping[i] = currentNode;\n            } else if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result === deleteNodeSymbol) {\n              return result;\n            } else if (result !== undefined) {\n              if (exposeEdits) {\n                currentNode = result;\n                hasChanged = true;\n              } else {\n                return result;\n              }\n            }\n          }\n        }\n      }\n      return hasChanged ? currentNode : undefined;\n    },\n    async leave(node, key, parent, path, ancestors, link) {\n      let currentNode = node;\n      const linkProxy = {\n        ...link,\n        replaceWith(newNode, replacer) {\n          link.replaceWith(newNode, replacer);\n          currentNode = newNode;\n        }\n      };\n      for (let i = 0; i < visitors.length; i += 1) {\n        if (skipping[i] === skipSymbol) {\n          const visitFn = visitFnGetter(visitors[i], nodeTypeGetter(currentNode), true);\n          if (typeof visitFn === 'function') {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await visitFn.call(visitors[i], currentNode, key, parent, path, ancestors, linkProxy);\n            if (result === breakSymbol) {\n              skipping[i] = breakSymbol;\n            } else if (result !== undefined && result !== skipVisitingNodeSymbol) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === currentNode) {\n          skipping[i] = skipSymbol;\n        }\n      }\n      return undefined;\n    }\n  };\n};\nmergeAll[Symbol.for('nodejs.util.promisify.custom')] = mergeAllAsync;\n\n/* eslint-disable no-continue, no-param-reassign */\n/**\n * visit() will walk through an AST using a preorder depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n *  @sig visit :: (Node, Visitor, Options)\n *  @sig      Options = { keyMap: Object, state: Object }\n */\nexport const visit = (\n// @ts-ignore\nroot,\n// @ts-ignore\nvisitor, {\n  keyMap = null,\n  state = {},\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  nodePredicate = isNode,\n  nodeCloneFn = cloneNode,\n  detectCycles = true\n} = {}) => {\n  const visitorKeys = keyMap || {};\n  let stack;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let parent;\n  let edits = [];\n  let node = root;\n  const path = [];\n  // @ts-ignore\n  const ancestors = [];\n  do {\n    index += 1;\n    const isLeaving = index === keys.length;\n    let key;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      // @ts-ignore\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          // @ts-ignore; creating clone\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === deleteNodeSymbol) {\n              node.splice(arrayKey, 1);\n              editOffset += 1;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          // creating clone\n          node = nodeCloneFn(node);\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      // @ts-ignore\n      edits = stack.edits;\n      // @ts-ignore\n      inArray = stack.inArray;\n      // @ts-ignore\n      stack = stack.prev;\n    } else if (parent !== deleteNodeSymbol && parent !== undefined) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === deleteNodeSymbol || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      var _result;\n      if (!nodePredicate(node)) {\n        throw new ApiDOMStructuredError(`Invalid AST Node:  ${String(node)}`, {\n          node\n        });\n      }\n\n      // cycle detected; skipping over a sub-tree to avoid recursion\n      if (detectCycles && ancestors.includes(node)) {\n        path.pop();\n        continue;\n      }\n      // call appropriate visitor function if available\n      const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);\n      if (visitFn) {\n        // assign state\n        for (const [stateKey, stateValue] of Object.entries(state)) {\n          visitor[stateKey] = stateValue;\n        }\n        const link = {\n          // eslint-disable-next-line @typescript-eslint/no-loop-func\n          replaceWith(newNode, replacer) {\n            if (typeof replacer === 'function') {\n              replacer(newNode, node, key, parent, path, ancestors);\n            } else if (parent) {\n              parent[key] = newNode;\n            }\n            if (!isLeaving) {\n              node = newNode;\n            }\n          }\n        };\n\n        // retrieve result\n        result = visitFn.call(visitor, node, key, parent, path, ancestors, link);\n      }\n\n      // check if the visitor is async\n      if (typeof ((_result = result) === null || _result === void 0 ? void 0 : _result.then) === 'function') {\n        throw new ApiDOMStructuredError('Async visitor not supported in sync mode', {\n          visitor,\n          visitFn\n        });\n      }\n      if (result === breakSymbol) {\n        break;\n      }\n      if (result === skipVisitingNodeSymbol) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (nodePredicate(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (!isLeaving) {\n      var _visitorKeys$nodeType;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      // @ts-ignore\n      keys = inArray ? node : (_visitorKeys$nodeType = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType !== void 0 ? _visitorKeys$nodeType : [];\n      index = -1;\n      edits = [];\n      if (parent !== deleteNodeSymbol && parent !== undefined) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future\n  }\n  return root;\n};\n\n/**\n * Asynchronous version of visit.\n */\n// @ts-ignore\nvisit[Symbol.for('nodejs.util.promisify.custom')] = async (\n// @ts-ignore\nroot,\n// @ts-ignore\nvisitor, {\n  keyMap = null,\n  state = {},\n  breakSymbol = BREAK,\n  deleteNodeSymbol = null,\n  skipVisitingNodeSymbol = false,\n  visitFnGetter = getVisitFn,\n  nodeTypeGetter = getNodeType,\n  nodePredicate = isNode,\n  nodeCloneFn = cloneNode,\n  detectCycles = true\n} = {}) => {\n  const visitorKeys = keyMap || {};\n  let stack;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let parent;\n  let edits = [];\n  let node = root;\n  const path = [];\n  // @ts-ignore\n  const ancestors = [];\n  do {\n    index += 1;\n    const isLeaving = index === keys.length;\n    let key;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      // @ts-ignore\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          // @ts-ignore; creating clone\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === deleteNodeSymbol) {\n              node.splice(arrayKey, 1);\n              editOffset += 1;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          // creating clone\n          node = nodeCloneFn(node);\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      // @ts-ignore\n      edits = stack.edits;\n      // @ts-ignore\n      inArray = stack.inArray;\n      // @ts-ignore\n      stack = stack.prev;\n    } else if (parent !== deleteNodeSymbol && parent !== undefined) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === deleteNodeSymbol || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      if (!nodePredicate(node)) {\n        throw new ApiDOMStructuredError(`Invalid AST Node: ${String(node)}`, {\n          node\n        });\n      }\n\n      // cycle detected; skipping over a sub-tree to avoid recursion\n      if (detectCycles && ancestors.includes(node)) {\n        path.pop();\n        continue;\n      }\n      const visitFn = visitFnGetter(visitor, nodeTypeGetter(node), isLeaving);\n      if (visitFn) {\n        // assign state\n        for (const [stateKey, stateValue] of Object.entries(state)) {\n          visitor[stateKey] = stateValue;\n        }\n        const link = {\n          // eslint-disable-next-line @typescript-eslint/no-loop-func\n          replaceWith(newNode, replacer) {\n            if (typeof replacer === 'function') {\n              replacer(newNode, node, key, parent, path, ancestors);\n            } else if (parent) {\n              parent[key] = newNode;\n            }\n            if (!isLeaving) {\n              node = newNode;\n            }\n          }\n        };\n\n        // retrieve result\n        result = await visitFn.call(visitor, node, key, parent, path, ancestors, link); // eslint-disable-line no-await-in-loop\n      }\n      if (result === breakSymbol) {\n        break;\n      }\n      if (result === skipVisitingNodeSymbol) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (nodePredicate(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (!isLeaving) {\n      var _visitorKeys$nodeType2;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      // @ts-ignore\n      keys = inArray ? node : (_visitorKeys$nodeType2 = visitorKeys[nodeTypeGetter(node)]) !== null && _visitorKeys$nodeType2 !== void 0 ? _visitorKeys$nodeType2 : [];\n      index = -1;\n      edits = [];\n      if (parent !== deleteNodeSymbol && parent !== undefined) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1]; // @TODO(vladimir.gorej@gmail.com): can be replaced by Array.prototype.at in future\n  }\n  return root;\n};\n\n/* eslint-enable */"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}