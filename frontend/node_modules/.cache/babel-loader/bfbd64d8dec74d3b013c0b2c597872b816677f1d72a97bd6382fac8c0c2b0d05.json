{"ast":null,"code":"import { traverse, curry, pipe, prop, curryN } from 'ramda';\nimport Identity from './fantasy-land/Identity.js';\n\n/**\n * Creates a [Traversable](https://github.com/fantasyland/fantasy-land#traversable) lens\n * from an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning function.\n *\n * When executed, it maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning\n * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),\n * then uses [`sequence`](https://ramdajs.com/docs/#sequence) to transform the resulting Traversable of Applicative\n * into an Applicative of Traversable.\n *\n * Dispatches to the `traverse` method of the third argument, if present.\n *\n * @func lensTraverse\n * @memberOf RA\n * @since {@link https://char0n.github.io/ramda-adjunct/2.7.0|2.7.0}\n * @category Relation\n * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s\n * @sig fantasy-land/of :: TypeRep f => f ~> a → f a\n * @sig Applicative f => (a -> f a) -> Lens s a\n * @sig Applicative f => TypeRep f -> Lens s a\n * @param {!Object|!Function} TypeRepresentative with an `of` or `fantasy-land/of` method\n * @return {!function} The Traversable lens\n * @see {@link http://ramdajs.com/docs/#lens|R.lens}, {@link http://ramdajs.com/docs/#traverse|R.traverse}\n *\n * @example\n *\n * const maybeLens = RA.lensTraverse(Maybe.of);\n * const safeDiv = n => d => d === 0 ? Maybe.Nothing() : Maybe.Just(n / d)\n *\n * R.over(maybeLens, safeDiv(10), [2, 4, 5]); // => Just([5, 2.5, 2])\n * R.over(maybeLens, safeDiv(10), [2, 0, 5]); // => Nothing\n *\n * R.view(maybeLens, [Maybe.Just(2), Maybe.Just(3)]); // => Maybe.Just([2, 3])\n *\n * R.set(maybeLens, Maybe.Just(1), [Maybe.just(2), Maybe.Just(3)]); // => Maybe.Just([1, 1])\n */\n/* eslint-disable no-nested-ternary */\nvar lensTraverse = curryN(1, function (F) {\n  var of = typeof F['fantasy-land/of'] === 'function' ? F['fantasy-land/of'] : typeof F.of === 'function' ? F.of : F;\n  var TypeRep = {\n    'fantasy-land/of': of\n  };\n  return curry(function (toFunctorFn, target) {\n    return Identity.of(traverse(TypeRep, pipe(toFunctorFn, prop('value')), target));\n  });\n});\n/* eslint-enable */\n\nexport default lensTraverse;","map":{"version":3,"names":["traverse","curry","pipe","prop","curryN","Identity","lensTraverse","F","of","TypeRep","toFunctorFn","target"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/ramda-adjunct/es/lensTraverse.js"],"sourcesContent":["import { traverse, curry, pipe, prop, curryN } from 'ramda';\nimport Identity from './fantasy-land/Identity.js';\n\n/**\n * Creates a [Traversable](https://github.com/fantasyland/fantasy-land#traversable) lens\n * from an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning function.\n *\n * When executed, it maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning\n * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),\n * then uses [`sequence`](https://ramdajs.com/docs/#sequence) to transform the resulting Traversable of Applicative\n * into an Applicative of Traversable.\n *\n * Dispatches to the `traverse` method of the third argument, if present.\n *\n * @func lensTraverse\n * @memberOf RA\n * @since {@link https://char0n.github.io/ramda-adjunct/2.7.0|2.7.0}\n * @category Relation\n * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s\n * @sig fantasy-land/of :: TypeRep f => f ~> a → f a\n * @sig Applicative f => (a -> f a) -> Lens s a\n * @sig Applicative f => TypeRep f -> Lens s a\n * @param {!Object|!Function} TypeRepresentative with an `of` or `fantasy-land/of` method\n * @return {!function} The Traversable lens\n * @see {@link http://ramdajs.com/docs/#lens|R.lens}, {@link http://ramdajs.com/docs/#traverse|R.traverse}\n *\n * @example\n *\n * const maybeLens = RA.lensTraverse(Maybe.of);\n * const safeDiv = n => d => d === 0 ? Maybe.Nothing() : Maybe.Just(n / d)\n *\n * R.over(maybeLens, safeDiv(10), [2, 4, 5]); // => Just([5, 2.5, 2])\n * R.over(maybeLens, safeDiv(10), [2, 0, 5]); // => Nothing\n *\n * R.view(maybeLens, [Maybe.Just(2), Maybe.Just(3)]); // => Maybe.Just([2, 3])\n *\n * R.set(maybeLens, Maybe.Just(1), [Maybe.just(2), Maybe.Just(3)]); // => Maybe.Just([1, 1])\n */\n/* eslint-disable no-nested-ternary */\nvar lensTraverse = curryN(1, function (F) {\n  var of = typeof F['fantasy-land/of'] === 'function' ? F['fantasy-land/of'] : typeof F.of === 'function' ? F.of : F;\n  var TypeRep = {\n    'fantasy-land/of': of\n  };\n  return curry(function (toFunctorFn, target) {\n    return Identity.of(traverse(TypeRep, pipe(toFunctorFn, prop('value')), target));\n  });\n});\n/* eslint-enable */\n\nexport default lensTraverse;"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,KAAK,EAAEC,IAAI,EAAEC,IAAI,EAAEC,MAAM,QAAQ,OAAO;AAC3D,OAAOC,QAAQ,MAAM,4BAA4B;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,YAAY,GAAGF,MAAM,CAAC,CAAC,EAAE,UAAUG,CAAC,EAAE;EACxC,IAAIC,EAAE,GAAG,OAAOD,CAAC,CAAC,iBAAiB,CAAC,KAAK,UAAU,GAAGA,CAAC,CAAC,iBAAiB,CAAC,GAAG,OAAOA,CAAC,CAACC,EAAE,KAAK,UAAU,GAAGD,CAAC,CAACC,EAAE,GAAGD,CAAC;EAClH,IAAIE,OAAO,GAAG;IACZ,iBAAiB,EAAED;EACrB,CAAC;EACD,OAAOP,KAAK,CAAC,UAAUS,WAAW,EAAEC,MAAM,EAAE;IAC1C,OAAON,QAAQ,CAACG,EAAE,CAACR,QAAQ,CAACS,OAAO,EAAEP,IAAI,CAACQ,WAAW,EAAEP,IAAI,CAAC,OAAO,CAAC,CAAC,EAAEQ,MAAM,CAAC,CAAC;EACjF,CAAC,CAAC;AACJ,CAAC,CAAC;AACF;;AAEA,eAAeL,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}