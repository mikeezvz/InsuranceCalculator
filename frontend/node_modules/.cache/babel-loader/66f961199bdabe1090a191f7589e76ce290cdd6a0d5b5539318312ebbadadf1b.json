{"ast":null,"code":"import { invokeArgs } from 'ramda-adjunct';\nimport PluginError from \"../errors/PluginError.mjs\";\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n */\nexport const filter = async (method, parameters, plugins) => {\n  const pluginResults = await Promise.all(plugins.map(invokeArgs([method], parameters)));\n  return plugins.filter((plugin, index) => pluginResults[index]);\n};\n\n/**\n * Runs the specified method of the given plugins, in order,\n * until one of them returns a successful result.\n * Each method can return a synchronous value or a Promise.\n * If the promise resolves successfully then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n */\nexport const run = async (method, parameters, plugins) => {\n  let lastError;\n  for (const plugin of plugins) {\n    try {\n      const result = await plugin[method].call(plugin, ...parameters); // eslint-disable-line no-await-in-loop\n      return {\n        plugin,\n        result\n      };\n    } catch (error) {\n      lastError = new PluginError('Error while running plugin', {\n        cause: error,\n        plugin\n      });\n    }\n  }\n  return Promise.reject(lastError);\n};","map":{"version":3,"names":["invokeArgs","PluginError","filter","method","parameters","plugins","pluginResults","Promise","all","map","plugin","index","run","lastError","result","call","error","cause","reject"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-reference/es/util/plugins.mjs"],"sourcesContent":["import { invokeArgs } from 'ramda-adjunct';\nimport PluginError from \"../errors/PluginError.mjs\";\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n */\nexport const filter = async (method, parameters, plugins) => {\n  const pluginResults = await Promise.all(plugins.map(invokeArgs([method], parameters)));\n  return plugins.filter((plugin, index) => pluginResults[index]);\n};\n\n/**\n * Runs the specified method of the given plugins, in order,\n * until one of them returns a successful result.\n * Each method can return a synchronous value or a Promise.\n * If the promise resolves successfully then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n */\nexport const run = async (method, parameters, plugins) => {\n  let lastError;\n  for (const plugin of plugins) {\n    try {\n      const result = await plugin[method].call(plugin, ...parameters); // eslint-disable-line no-await-in-loop\n      return {\n        plugin,\n        result\n      };\n    } catch (error) {\n      lastError = new PluginError('Error while running plugin', {\n        cause: error,\n        plugin\n      });\n    }\n  }\n  return Promise.reject(lastError);\n};"],"mappings":"AAAA,SAASA,UAAU,QAAQ,eAAe;AAC1C,OAAOC,WAAW,MAAM,2BAA2B;AACnD;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAG,MAAAA,CAAOC,MAAM,EAAEC,UAAU,EAAEC,OAAO,KAAK;EAC3D,MAAMC,aAAa,GAAG,MAAMC,OAAO,CAACC,GAAG,CAACH,OAAO,CAACI,GAAG,CAACT,UAAU,CAAC,CAACG,MAAM,CAAC,EAAEC,UAAU,CAAC,CAAC,CAAC;EACtF,OAAOC,OAAO,CAACH,MAAM,CAAC,CAACQ,MAAM,EAAEC,KAAK,KAAKL,aAAa,CAACK,KAAK,CAAC,CAAC;AAChE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,GAAG,GAAG,MAAAA,CAAOT,MAAM,EAAEC,UAAU,EAAEC,OAAO,KAAK;EACxD,IAAIQ,SAAS;EACb,KAAK,MAAMH,MAAM,IAAIL,OAAO,EAAE;IAC5B,IAAI;MACF,MAAMS,MAAM,GAAG,MAAMJ,MAAM,CAACP,MAAM,CAAC,CAACY,IAAI,CAACL,MAAM,EAAE,GAAGN,UAAU,CAAC,CAAC,CAAC;MACjE,OAAO;QACLM,MAAM;QACNI;MACF,CAAC;IACH,CAAC,CAAC,OAAOE,KAAK,EAAE;MACdH,SAAS,GAAG,IAAIZ,WAAW,CAAC,4BAA4B,EAAE;QACxDgB,KAAK,EAAED,KAAK;QACZN;MACF,CAAC,CAAC;IACJ;EACF;EACA,OAAOH,OAAO,CAACW,MAAM,CAACL,SAAS,CAAC;AAClC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}