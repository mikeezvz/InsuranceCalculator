{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unraw = exports.errorMessages = exports.ErrorType = void 0;\nconst errors_1 = require(\"./errors\");\nObject.defineProperty(exports, \"ErrorType\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.ErrorType;\n  }\n});\nObject.defineProperty(exports, \"errorMessages\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.errorMessages;\n  }\n});\n/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex) {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(hex, errorName, enforcedLength) {\n  const parsedHex = parseHexToInt(hex);\n  if (Number.isNaN(parsedHex) || enforcedLength !== undefined && enforcedLength !== hex.length) {\n    throw new SyntaxError(errors_1.errorMessages.get(errorName));\n  }\n  return parsedHex;\n}\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code) {\n  const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);\n  return String.fromCharCode(parsedCode);\n}\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code, surrogateCode) {\n  const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n  return String.fromCharCode(parsedCode);\n}\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text) {\n  return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint) {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit)) : err;\n  }\n}\n// Have to give overload that takes boolean for when compiler doesn't know if\n// true or false\nfunction parseOctalCode(code, error = false) {\n  if (error) {\n    throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));\n  }\n  // The original regex only allows digits so we don't need to have a strict\n  // octal parser like hexToInt. Length is not enforced for octals.\n  const parsedCode = parseInt(code, 8);\n  return String.fromCharCode(parsedCode);\n}\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map([[\"b\", \"\\b\"], [\"f\", \"\\f\"], [\"n\", \"\\n\"], [\"r\", \"\\r\"], [\"t\", \"\\t\"], [\"v\", \"\\v\"], [\"0\", \"\\0\"]]);\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code) {\n  return singleCharacterEscapes.get(code) || code;\n}\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nfunction unraw(raw, allowOctals = false) {\n  return raw.replace(escapeMatch, function (_, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {\n    // Compare groups to undefined because empty strings mean different errors\n    // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n    if (backslash !== undefined) {\n      return \"\\\\\";\n    }\n    if (hex !== undefined) {\n      return parseHexadecimalCode(hex);\n    }\n    if (codePoint !== undefined) {\n      return parseUnicodeCodePointCode(codePoint);\n    }\n    if (unicodeWithSurrogate !== undefined) {\n      return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n    }\n    if (unicode !== undefined) {\n      return parseUnicodeCode(unicode);\n    }\n    if (octal === \"0\") {\n      return \"\\0\";\n    }\n    if (octal !== undefined) {\n      return parseOctalCode(octal, !allowOctals);\n    }\n    if (singleCharacter !== undefined) {\n      return parseSingleCharacterCode(singleCharacter);\n    }\n    throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));\n  });\n}\nexports.unraw = unraw;\nexports.default = unraw;","map":{"version":3,"names":["Object","defineProperty","exports","value","unraw","errorMessages","ErrorType","errors_1","require","enumerable","get","parseHexToInt","hex","isOnlyHexChars","match","parseInt","NaN","validateAndParseHex","errorName","enforcedLength","parsedHex","Number","isNaN","undefined","length","SyntaxError","parseHexadecimalCode","code","parsedCode","MalformedHexadecimal","String","fromCharCode","parseUnicodeCode","surrogateCode","MalformedUnicode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","withoutBraces","slice","fromCodePoint","err","RangeError","CodePointLimit","parseOctalCode","error","OctalDeprecation","singleCharacterEscapes","Map","parseSingleCharacterCode","escapeMatch","raw","allowOctals","replace","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","EndOfString","default"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/unraw/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unraw = exports.errorMessages = exports.ErrorType = void 0;\nconst errors_1 = require(\"./errors\");\nObject.defineProperty(exports, \"ErrorType\", { enumerable: true, get: function () { return errors_1.ErrorType; } });\nObject.defineProperty(exports, \"errorMessages\", { enumerable: true, get: function () { return errors_1.errorMessages; } });\n/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex) {\n    const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n    return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(hex, errorName, enforcedLength) {\n    const parsedHex = parseHexToInt(hex);\n    if (Number.isNaN(parsedHex) ||\n        (enforcedLength !== undefined && enforcedLength !== hex.length)) {\n        throw new SyntaxError(errors_1.errorMessages.get(errorName));\n    }\n    return parsedHex;\n}\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code) {\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code, surrogateCode) {\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);\n    if (surrogateCode !== undefined) {\n        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);\n        return String.fromCharCode(parsedCode, parsedSurrogateCode);\n    }\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text) {\n    return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint) {\n    if (!isCurlyBraced(codePoint)) {\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));\n    }\n    const withoutBraces = codePoint.slice(1, -1);\n    const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);\n    try {\n        return String.fromCodePoint(parsedCode);\n    }\n    catch (err) {\n        throw err instanceof RangeError\n            ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit))\n            : err;\n    }\n}\n// Have to give overload that takes boolean for when compiler doesn't know if\n// true or false\nfunction parseOctalCode(code, error = false) {\n    if (error) {\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));\n    }\n    // The original regex only allows digits so we don't need to have a strict\n    // octal parser like hexToInt. Length is not enforced for octals.\n    const parsedCode = parseInt(code, 8);\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map([\n    [\"b\", \"\\b\"],\n    [\"f\", \"\\f\"],\n    [\"n\", \"\\n\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"],\n    [\"v\", \"\\v\"],\n    [\"0\", \"\\0\"]\n]);\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code) {\n    return singleCharacterEscapes.get(code) || code;\n}\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nfunction unraw(raw, allowOctals = false) {\n    return raw.replace(escapeMatch, function (_, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {\n        // Compare groups to undefined because empty strings mean different errors\n        // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n        if (backslash !== undefined) {\n            return \"\\\\\";\n        }\n        if (hex !== undefined) {\n            return parseHexadecimalCode(hex);\n        }\n        if (codePoint !== undefined) {\n            return parseUnicodeCodePointCode(codePoint);\n        }\n        if (unicodeWithSurrogate !== undefined) {\n            return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n        }\n        if (unicode !== undefined) {\n            return parseUnicodeCode(unicode);\n        }\n        if (octal === \"0\") {\n            return \"\\0\";\n        }\n        if (octal !== undefined) {\n            return parseOctalCode(octal, !allowOctals);\n        }\n        if (singleCharacter !== undefined) {\n            return parseSingleCharacterCode(singleCharacter);\n        }\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));\n    });\n}\nexports.unraw = unraw;\nexports.default = unraw;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}