{"ast":null,"code":"import { propEq, none } from 'ramda';\nimport { isUndefined } from 'ramda-adjunct';\nimport { isElement, isPrimitiveElement, isStringElement, isMemberElement, isObjectElement, IdentityManager, visit, find, cloneShallow, cloneDeep, toValue, RefElement } from '@swagger-api/apidom-core';\nimport { ApiDOMError } from '@swagger-api/apidom-error';\nimport { evaluate as jsonPointerEvaluate, uriToPointer } from '@swagger-api/apidom-json-pointer';\nimport { getNodeType, isReferenceLikeElement, keyMap, ReferenceElement, PathItemElement, OperationElement, SchemaElement, isPathItemElement, isReferenceElement, isSchemaElement, isOperationElement, isBooleanJsonSchemaElement } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from \"./selectors/$anchor.mjs\";\nimport { evaluate as uriEvaluate } from \"./selectors/uri.mjs\";\nimport MaximumDereferenceDepthError from \"../../../errors/MaximumDereferenceDepthError.mjs\";\nimport MaximumResolveDepthError from \"../../../errors/MaximumResolveDepthError.mjs\";\nimport * as url from \"../../../util/url.mjs\";\nimport parse from \"../../../parse/index.mjs\";\nimport Reference from \"../../../Reference.mjs\";\nimport File from \"../../../File.mjs\";\nimport { resolveSchema$refField, maybeRefractToSchemaElement } from \"./util.mjs\";\nimport { AncestorLineage } from \"../../util.mjs\";\nimport EvaluationJsonSchemaUriError from \"../../../errors/EvaluationJsonSchemaUriError.mjs\";\n// @ts-ignore\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n// initialize element identity manager\nconst identityManager = new IdentityManager();\n\n// custom mutation replacer\nconst mutationReplacer = (newElement, oldElement, key, parent) => {\n  if (isMemberElement(parent)) {\n    parent.value = newElement; // eslint-disable-line no-param-reassign\n  } else if (Array.isArray(parent)) {\n    parent[key] = newElement; // eslint-disable-line no-param-reassign\n  }\n};\nclass OpenAPI3_1DereferenceVisitor {\n  indirections;\n  namespace;\n  reference;\n  options;\n  ancestors;\n  refractCache;\n  constructor({\n    reference,\n    namespace,\n    options,\n    indirections = [],\n    ancestors = new AncestorLineage(),\n    refractCache = new Map()\n  }) {\n    this.indirections = indirections;\n    this.namespace = namespace;\n    this.reference = reference;\n    this.options = options;\n    this.ancestors = new AncestorLineage(...ancestors);\n    this.refractCache = refractCache;\n  }\n  toBaseURI(uri) {\n    return url.resolve(this.reference.uri, url.sanitize(url.stripHash(uri)));\n  }\n  async toReference(uri) {\n    // detect maximum depth of resolution\n    if (this.reference.depth >= this.options.resolve.maxDepth) {\n      throw new MaximumResolveDepthError(`Maximum resolution depth of ${this.options.resolve.maxDepth} has been exceeded by file \"${this.reference.uri}\"`);\n    }\n    const baseURI = this.toBaseURI(uri);\n    const {\n      refSet\n    } = this.reference;\n\n    // we've already processed this Reference in past\n    if (refSet.has(baseURI)) {\n      return refSet.find(propEq(baseURI, 'uri'));\n    }\n    const parseResult = await parse(url.unsanitize(baseURI), {\n      ...this.options,\n      parse: {\n        ...this.options.parse,\n        mediaType: 'text/plain'\n      }\n    });\n\n    // register new mutable reference with a refSet\n    const mutableReference = new Reference({\n      uri: baseURI,\n      value: cloneDeep(parseResult),\n      depth: this.reference.depth + 1\n    });\n    refSet.add(mutableReference);\n    if (this.options.dereference.immutable) {\n      // register new immutable reference with a refSet\n      const immutableReference = new Reference({\n        uri: `immutable://${baseURI}`,\n        value: parseResult,\n        depth: this.reference.depth + 1\n      });\n      refSet.add(immutableReference);\n    }\n    return mutableReference;\n  }\n  toAncestorLineage(ancestors) {\n    /**\n     * Compute full ancestors lineage.\n     * Ancestors are flatten to unwrap all Element instances.\n     */\n    const directAncestors = new Set(ancestors.filter(isElement));\n    const ancestorsLineage = new AncestorLineage(...this.ancestors, directAncestors);\n    return [ancestorsLineage, directAncestors];\n  }\n  async ReferenceElement(referencingElement, key, parent, path, ancestors, link) {\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Reference Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    // ignore resolving external Reference Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    const reference = await this.toReference(toValue(referencingElement.$ref));\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = uriToPointer($refBaseURI);\n\n    // possibly non-semantic fragment\n    let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    // applying semantics to a fragment\n    if (isPrimitiveElement(referencedElement)) {\n      const referencedElementType = toValue(referencingElement.meta.get('referenced-element'));\n      const cacheKey = `${referencedElementType}-${toValue(identityManager.identify(referencedElement))}`;\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else if (isReferenceLikeElement(referencedElement)) {\n        // handling indirect references\n        referencedElement = ReferenceElement.refract(referencedElement);\n        referencedElement.setMetaProperty('referenced-element', referencedElementType);\n        this.refractCache.set(cacheKey, referencedElement);\n      } else {\n        // handling direct references\n        const ElementClass = this.namespace.getElementClass(referencedElementType);\n        referencedElement = ElementClass.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      throw new ApiDOMError('Recursive Reference Object detected');\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        throw new ApiDOMError('Circular reference detected');\n      } else if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer, _this$options$derefer2;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'reference',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer = (_this$options$derefer2 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer2 === void 0 ? void 0 : _this$options$derefer2.circularReplacer) !== null && _this$options$derefer !== void 0 ? _this$options$derefer : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Reference Object. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isReferenceElement(referencedElement) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.options,\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage\n      });\n      referencedElement = await visitAsync(referencedElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of referenced element to avoid modifying the original one.\n     */\n    const mergedElement = cloneShallow(referencedElement);\n    // assign unique id to merged element\n    mergedElement.setMetaProperty('id', identityManager.generateId());\n    // annotate fragment with info about original Reference element\n    mergedElement.setMetaProperty('ref-fields', {\n      $ref: toValue(referencingElement.$ref),\n      // @ts-ignore\n      description: toValue(referencingElement.description),\n      // @ts-ignore\n      summary: toValue(referencingElement.summary)\n    });\n    // annotate fragment with info about origin\n    mergedElement.setMetaProperty('ref-origin', reference.uri);\n    // annotate fragment with info about referencing element\n    mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n    // override description and summary (outer has higher priority then inner)\n    if (isObjectElement(referencedElement) && isObjectElement(mergedElement)) {\n      if (referencingElement.hasKey('description') && 'description' in referencedElement) {\n        mergedElement.remove('description');\n        mergedElement.set('description', referencingElement.get('description'));\n      }\n      if (referencingElement.hasKey('summary') && 'summary' in referencedElement) {\n        mergedElement.remove('summary');\n        mergedElement.set('summary', referencingElement.get('summary'));\n      }\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(mergedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? mergedElement : false;\n  }\n  async PathItemElement(referencingElement, key, parent, path, ancestors, link) {\n    // ignore PathItemElement without $ref field\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    const reference = await this.toReference(toValue(referencingElement.$ref));\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = uriToPointer($refBaseURI);\n\n    // possibly non-semantic referenced element\n    let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    /**\n     * Applying semantics to a referenced element if semantics are missing.\n     */\n    if (isPrimitiveElement(referencedElement)) {\n      const cacheKey = `path-item-${toValue(identityManager.identify(referencedElement))}`;\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else {\n        referencedElement = PathItemElement.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      throw new ApiDOMError('Recursive Path Item Object reference detected');\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        throw new ApiDOMError('Circular reference detected');\n      } else if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer3, _this$options$derefer4;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'path-item',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer3 = (_this$options$derefer4 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer4 === void 0 ? void 0 : _this$options$derefer4.circularReplacer) !== null && _this$options$derefer3 !== void 0 ? _this$options$derefer3 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Path Item Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isPathItemElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.options,\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage\n      });\n      referencedElement = await visitAsync(referencedElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of Path Item by merging fields from referenced Path Item with referencing one.\n     */\n    if (isPathItemElement(referencedElement)) {\n      const mergedElement = new PathItemElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing PathItemElement overrides ones from referenced element\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref)\n      });\n      // annotate referenced element with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      referencedElement = mergedElement;\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n  async LinkElement(linkElement, key, parent, path, ancestors, link) {\n    // ignore LinkElement without operationRef or operationId field\n    if (!isStringElement(linkElement.operationRef) && !isStringElement(linkElement.operationId)) {\n      return undefined;\n    }\n\n    // operationRef and operationId fields are mutually exclusive\n    if (isStringElement(linkElement.operationRef) && isStringElement(linkElement.operationId)) {\n      throw new ApiDOMError('LinkElement operationRef and operationId fields are mutually exclusive.');\n    }\n    let operationElement;\n    if (isStringElement(linkElement.operationRef)) {\n      var _linkElementCopy$oper;\n      // possibly non-semantic referenced element\n      const jsonPointer = uriToPointer(toValue(linkElement.operationRef));\n      const retrievalURI = this.toBaseURI(toValue(linkElement.operationRef));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Operation Object reference\n      if (!this.options.resolve.internal && isInternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      // ignore resolving external Operation Object reference\n      if (!this.options.resolve.external && isExternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      const reference = await this.toReference(toValue(linkElement.operationRef));\n      operationElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n      // applying semantics to a referenced element\n      if (isPrimitiveElement(operationElement)) {\n        const cacheKey = `operation-${toValue(identityManager.identify(operationElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          operationElement = this.refractCache.get(cacheKey);\n        } else {\n          operationElement = OperationElement.refract(operationElement);\n          this.refractCache.set(cacheKey, operationElement);\n        }\n      }\n      // create shallow clone to be able to annotate with metadata\n      operationElement = cloneShallow(operationElement);\n      // annotate operation element with info about origin\n      operationElement.setMetaProperty('ref-origin', reference.uri);\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper = linkElementCopy.operationRef) === null || _linkElementCopy$oper === void 0 || _linkElementCopy$oper.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    if (isStringElement(linkElement.operationId)) {\n      var _linkElementCopy$oper2;\n      const operationId = toValue(linkElement.operationId);\n      const reference = await this.toReference(url.unsanitize(this.reference.uri));\n      operationElement = find(e => isOperationElement(e) && isElement(e.operationId) && e.operationId.equals(operationId), reference.value.result);\n      // OperationElement not found by its operationId\n      if (isUndefined(operationElement)) {\n        throw new ApiDOMError(`OperationElement(operationId=${operationId}) not found.`);\n      }\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper2 = linkElementCopy.operationId) === null || _linkElementCopy$oper2 === void 0 || _linkElementCopy$oper2.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    return undefined;\n  }\n  async ExampleElement(exampleElement, key, parent, path, ancestors, link) {\n    // ignore ExampleElement without externalValue field\n    if (!isStringElement(exampleElement.externalValue)) {\n      return undefined;\n    }\n\n    // value and externalValue fields are mutually exclusive\n    if (exampleElement.hasKey('value') && isStringElement(exampleElement.externalValue)) {\n      throw new ApiDOMError('ExampleElement value and externalValue fields are mutually exclusive.');\n    }\n    const retrievalURI = this.toBaseURI(toValue(exampleElement.externalValue));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Example Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Example Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    const reference = await this.toReference(toValue(exampleElement.externalValue));\n\n    // shallow clone of the referenced element\n    const valueElement = cloneShallow(reference.value.result);\n    // annotate operation element with info about origin\n    valueElement.setMetaProperty('ref-origin', reference.uri);\n    const exampleElementCopy = cloneShallow(exampleElement);\n    exampleElementCopy.value = valueElement;\n\n    /**\n     * Transclude Example Object containing external value.\n     */\n    link.replaceWith(exampleElementCopy, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? exampleElementCopy : undefined;\n  }\n  async SchemaElement(referencingElement, key, parent, path, ancestors, link) {\n    // skip current referencing schema as $ref keyword was not defined\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n\n    // compute baseURI using rules around $id and $ref keywords\n    let reference = await this.toReference(url.unsanitize(this.reference.uri));\n    let {\n      uri: retrievalURI\n    } = reference;\n    const $refBaseURI = resolveSchema$refField(retrievalURI, referencingElement);\n    const $refBaseURIStrippedHash = url.stripHash($refBaseURI);\n    const file = new File({\n      uri: $refBaseURIStrippedHash\n    });\n    const isUnknownURI = none(r => r.canRead(file), this.options.resolve.resolvers);\n    const isURL = !isUnknownURI;\n    let isInternalReference = url.stripHash(this.reference.uri) === $refBaseURI;\n    let isExternalReference = !isInternalReference;\n    this.indirections.push(referencingElement);\n\n    // determining reference, proper evaluation and selection mechanism\n    let referencedElement;\n    try {\n      if (isUnknownURI || isURL) {\n        // we're dealing with canonical URI or URL with possible fragment\n        retrievalURI = this.toBaseURI($refBaseURI);\n        const selector = $refBaseURI;\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = uriEvaluate(selector, referenceAsSchema);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n      } else {\n        // we're assuming here that we're dealing with JSON Pointer here\n        retrievalURI = this.toBaseURI($refBaseURI);\n        isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n        isExternalReference = !isInternalReference;\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        reference = await this.toReference(url.unsanitize($refBaseURI));\n        const selector = uriToPointer($refBaseURI);\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = jsonPointerEvaluate(selector, referenceAsSchema);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n      }\n    } catch (error) {\n      /**\n       * No SchemaElement($id=URL) was not found, so we're going to try to resolve\n       * the URL and assume the returned response is a JSON Schema.\n       */\n      if (isURL && error instanceof EvaluationJsonSchemaUriError) {\n        if (isAnchor(uriToAnchor($refBaseURI))) {\n          // we're dealing with JSON Schema $anchor here\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = uriToAnchor($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = $anchorEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        } else {\n          // we're assuming here that we're dealing with JSON Pointer here\n          retrievalURI = this.toBaseURI($refBaseURI);\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = uriToPointer($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = jsonPointerEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        }\n      } else {\n        throw error;\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      throw new ApiDOMError('Recursive Schema Object reference detected');\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        throw new ApiDOMError('Circular reference detected');\n      } else if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer5, _this$options$derefer6;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'json-schema',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer5 = (_this$options$derefer6 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer6 === void 0 ? void 0 : _this$options$derefer6.circularReplacer) !== null && _this$options$derefer5 !== void 0 ? _this$options$derefer5 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Schema Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isSchemaElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.options,\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage\n      });\n      referencedElement = await visitAsync(referencedElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    // Boolean JSON Schemas\n    if (isBooleanJsonSchemaElement(referencedElement)) {\n      const booleanJsonSchemaElement = cloneDeep(referencedElement);\n      // assign unique id to merged element\n      booleanJsonSchemaElement.setMetaProperty('id', identityManager.generateId());\n      // annotate referenced element with info about original referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref)\n      });\n      // annotate referenced element with info about origin\n      booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      link.replaceWith(booleanJsonSchemaElement, mutationReplacer);\n      return !parent ? booleanJsonSchemaElement : false;\n    }\n\n    /**\n     * Creating a new version of Schema Object by merging fields from referenced Schema Object with referencing one.\n     */\n    if (isSchemaElement(referencedElement)) {\n      const mergedElement = new SchemaElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing schema overrides ones from referenced schema\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref)\n      });\n      // annotate fragment with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      referencedElement = mergedElement;\n    }\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n}\nexport default OpenAPI3_1DereferenceVisitor;","map":{"version":3,"names":["propEq","none","isUndefined","isElement","isPrimitiveElement","isStringElement","isMemberElement","isObjectElement","IdentityManager","visit","find","cloneShallow","cloneDeep","toValue","RefElement","ApiDOMError","evaluate","jsonPointerEvaluate","uriToPointer","getNodeType","isReferenceLikeElement","keyMap","ReferenceElement","PathItemElement","OperationElement","SchemaElement","isPathItemElement","isReferenceElement","isSchemaElement","isOperationElement","isBooleanJsonSchemaElement","isAnchor","uriToAnchor","$anchorEvaluate","uriEvaluate","MaximumDereferenceDepthError","MaximumResolveDepthError","url","parse","Reference","File","resolveSchema$refField","maybeRefractToSchemaElement","AncestorLineage","EvaluationJsonSchemaUriError","visitAsync","Symbol","for","identityManager","mutationReplacer","newElement","oldElement","key","parent","value","Array","isArray","OpenAPI3_1DereferenceVisitor","indirections","namespace","reference","options","ancestors","refractCache","constructor","Map","toBaseURI","uri","resolve","sanitize","stripHash","toReference","depth","maxDepth","baseURI","refSet","has","parseResult","unsanitize","mediaType","mutableReference","add","dereference","immutable","immutableReference","toAncestorLineage","directAncestors","Set","filter","ancestorsLineage","referencingElement","path","link","includes","retrievalURI","$ref","isInternalReference","isExternalReference","internal","external","$refBaseURI","push","jsonPointer","referencedElement","result","id","identify","referencedElementType","meta","get","cacheKey","refract","setMetaProperty","set","ElementClass","getElementClass","length","circular","_this$options$derefer","_this$options$derefer2","refElement","type","replacer","strategyOpts","circularReplacer","replacement","replaceWith","isNonRootDocument","rootRef","shouldDetectCircular","includesCycle","visitor","nodeTypeGetter","delete","pop","mergedElement","generateId","description","summary","hasKey","remove","undefined","_this$options$derefer3","_this$options$derefer4","content","attributes","forEach","keyElement","item","LinkElement","linkElement","operationRef","operationId","operationElement","_linkElementCopy$oper","linkElementCopy","_linkElementCopy$oper2","e","equals","ExampleElement","exampleElement","externalValue","valueElement","exampleElementCopy","$refBaseURIStrippedHash","file","isUnknownURI","r","canRead","resolvers","isURL","selector","referenceAsSchema","error","_this$options$derefer5","_this$options$derefer6","booleanJsonSchemaElement"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-reference/es/dereference/strategies/openapi-3-1/visitor.mjs"],"sourcesContent":["import { propEq, none } from 'ramda';\nimport { isUndefined } from 'ramda-adjunct';\nimport { isElement, isPrimitiveElement, isStringElement, isMemberElement, isObjectElement, IdentityManager, visit, find, cloneShallow, cloneDeep, toValue, RefElement } from '@swagger-api/apidom-core';\nimport { ApiDOMError } from '@swagger-api/apidom-error';\nimport { evaluate as jsonPointerEvaluate, uriToPointer } from '@swagger-api/apidom-json-pointer';\nimport { getNodeType, isReferenceLikeElement, keyMap, ReferenceElement, PathItemElement, OperationElement, SchemaElement, isPathItemElement, isReferenceElement, isSchemaElement, isOperationElement, isBooleanJsonSchemaElement } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from \"./selectors/$anchor.mjs\";\nimport { evaluate as uriEvaluate } from \"./selectors/uri.mjs\";\nimport MaximumDereferenceDepthError from \"../../../errors/MaximumDereferenceDepthError.mjs\";\nimport MaximumResolveDepthError from \"../../../errors/MaximumResolveDepthError.mjs\";\nimport * as url from \"../../../util/url.mjs\";\nimport parse from \"../../../parse/index.mjs\";\nimport Reference from \"../../../Reference.mjs\";\nimport File from \"../../../File.mjs\";\nimport { resolveSchema$refField, maybeRefractToSchemaElement } from \"./util.mjs\";\nimport { AncestorLineage } from \"../../util.mjs\";\nimport EvaluationJsonSchemaUriError from \"../../../errors/EvaluationJsonSchemaUriError.mjs\";\n// @ts-ignore\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n// initialize element identity manager\nconst identityManager = new IdentityManager();\n\n// custom mutation replacer\nconst mutationReplacer = (newElement, oldElement, key, parent) => {\n  if (isMemberElement(parent)) {\n    parent.value = newElement; // eslint-disable-line no-param-reassign\n  } else if (Array.isArray(parent)) {\n    parent[key] = newElement; // eslint-disable-line no-param-reassign\n  }\n};\nclass OpenAPI3_1DereferenceVisitor {\n  indirections;\n  namespace;\n  reference;\n  options;\n  ancestors;\n  refractCache;\n  constructor({\n    reference,\n    namespace,\n    options,\n    indirections = [],\n    ancestors = new AncestorLineage(),\n    refractCache = new Map()\n  }) {\n    this.indirections = indirections;\n    this.namespace = namespace;\n    this.reference = reference;\n    this.options = options;\n    this.ancestors = new AncestorLineage(...ancestors);\n    this.refractCache = refractCache;\n  }\n  toBaseURI(uri) {\n    return url.resolve(this.reference.uri, url.sanitize(url.stripHash(uri)));\n  }\n  async toReference(uri) {\n    // detect maximum depth of resolution\n    if (this.reference.depth >= this.options.resolve.maxDepth) {\n      throw new MaximumResolveDepthError(`Maximum resolution depth of ${this.options.resolve.maxDepth} has been exceeded by file \"${this.reference.uri}\"`);\n    }\n    const baseURI = this.toBaseURI(uri);\n    const {\n      refSet\n    } = this.reference;\n\n    // we've already processed this Reference in past\n    if (refSet.has(baseURI)) {\n      return refSet.find(propEq(baseURI, 'uri'));\n    }\n    const parseResult = await parse(url.unsanitize(baseURI), {\n      ...this.options,\n      parse: {\n        ...this.options.parse,\n        mediaType: 'text/plain'\n      }\n    });\n\n    // register new mutable reference with a refSet\n    const mutableReference = new Reference({\n      uri: baseURI,\n      value: cloneDeep(parseResult),\n      depth: this.reference.depth + 1\n    });\n    refSet.add(mutableReference);\n    if (this.options.dereference.immutable) {\n      // register new immutable reference with a refSet\n      const immutableReference = new Reference({\n        uri: `immutable://${baseURI}`,\n        value: parseResult,\n        depth: this.reference.depth + 1\n      });\n      refSet.add(immutableReference);\n    }\n    return mutableReference;\n  }\n  toAncestorLineage(ancestors) {\n    /**\n     * Compute full ancestors lineage.\n     * Ancestors are flatten to unwrap all Element instances.\n     */\n    const directAncestors = new Set(ancestors.filter(isElement));\n    const ancestorsLineage = new AncestorLineage(...this.ancestors, directAncestors);\n    return [ancestorsLineage, directAncestors];\n  }\n  async ReferenceElement(referencingElement, key, parent, path, ancestors, link) {\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Reference Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    // ignore resolving external Reference Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    const reference = await this.toReference(toValue(referencingElement.$ref));\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = uriToPointer($refBaseURI);\n\n    // possibly non-semantic fragment\n    let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    // applying semantics to a fragment\n    if (isPrimitiveElement(referencedElement)) {\n      const referencedElementType = toValue(referencingElement.meta.get('referenced-element'));\n      const cacheKey = `${referencedElementType}-${toValue(identityManager.identify(referencedElement))}`;\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else if (isReferenceLikeElement(referencedElement)) {\n        // handling indirect references\n        referencedElement = ReferenceElement.refract(referencedElement);\n        referencedElement.setMetaProperty('referenced-element', referencedElementType);\n        this.refractCache.set(cacheKey, referencedElement);\n      } else {\n        // handling direct references\n        const ElementClass = this.namespace.getElementClass(referencedElementType);\n        referencedElement = ElementClass.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      throw new ApiDOMError('Recursive Reference Object detected');\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        throw new ApiDOMError('Circular reference detected');\n      } else if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer, _this$options$derefer2;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'reference',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer = (_this$options$derefer2 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer2 === void 0 ? void 0 : _this$options$derefer2.circularReplacer) !== null && _this$options$derefer !== void 0 ? _this$options$derefer : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Reference Object. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isReferenceElement(referencedElement) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.options,\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage\n      });\n      referencedElement = await visitAsync(referencedElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of referenced element to avoid modifying the original one.\n     */\n    const mergedElement = cloneShallow(referencedElement);\n    // assign unique id to merged element\n    mergedElement.setMetaProperty('id', identityManager.generateId());\n    // annotate fragment with info about original Reference element\n    mergedElement.setMetaProperty('ref-fields', {\n      $ref: toValue(referencingElement.$ref),\n      // @ts-ignore\n      description: toValue(referencingElement.description),\n      // @ts-ignore\n      summary: toValue(referencingElement.summary)\n    });\n    // annotate fragment with info about origin\n    mergedElement.setMetaProperty('ref-origin', reference.uri);\n    // annotate fragment with info about referencing element\n    mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n    // override description and summary (outer has higher priority then inner)\n    if (isObjectElement(referencedElement) && isObjectElement(mergedElement)) {\n      if (referencingElement.hasKey('description') && 'description' in referencedElement) {\n        mergedElement.remove('description');\n        mergedElement.set('description', referencingElement.get('description'));\n      }\n      if (referencingElement.hasKey('summary') && 'summary' in referencedElement) {\n        mergedElement.remove('summary');\n        mergedElement.set('summary', referencingElement.get('summary'));\n      }\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(mergedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? mergedElement : false;\n  }\n  async PathItemElement(referencingElement, key, parent, path, ancestors, link) {\n    // ignore PathItemElement without $ref field\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    const reference = await this.toReference(toValue(referencingElement.$ref));\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = uriToPointer($refBaseURI);\n\n    // possibly non-semantic referenced element\n    let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    /**\n     * Applying semantics to a referenced element if semantics are missing.\n     */\n    if (isPrimitiveElement(referencedElement)) {\n      const cacheKey = `path-item-${toValue(identityManager.identify(referencedElement))}`;\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else {\n        referencedElement = PathItemElement.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      throw new ApiDOMError('Recursive Path Item Object reference detected');\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        throw new ApiDOMError('Circular reference detected');\n      } else if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer3, _this$options$derefer4;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'path-item',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer3 = (_this$options$derefer4 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer4 === void 0 ? void 0 : _this$options$derefer4.circularReplacer) !== null && _this$options$derefer3 !== void 0 ? _this$options$derefer3 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Path Item Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isPathItemElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.options,\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage\n      });\n      referencedElement = await visitAsync(referencedElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of Path Item by merging fields from referenced Path Item with referencing one.\n     */\n    if (isPathItemElement(referencedElement)) {\n      const mergedElement = new PathItemElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing PathItemElement overrides ones from referenced element\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref)\n      });\n      // annotate referenced element with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      referencedElement = mergedElement;\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n  async LinkElement(linkElement, key, parent, path, ancestors, link) {\n    // ignore LinkElement without operationRef or operationId field\n    if (!isStringElement(linkElement.operationRef) && !isStringElement(linkElement.operationId)) {\n      return undefined;\n    }\n\n    // operationRef and operationId fields are mutually exclusive\n    if (isStringElement(linkElement.operationRef) && isStringElement(linkElement.operationId)) {\n      throw new ApiDOMError('LinkElement operationRef and operationId fields are mutually exclusive.');\n    }\n    let operationElement;\n    if (isStringElement(linkElement.operationRef)) {\n      var _linkElementCopy$oper;\n      // possibly non-semantic referenced element\n      const jsonPointer = uriToPointer(toValue(linkElement.operationRef));\n      const retrievalURI = this.toBaseURI(toValue(linkElement.operationRef));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Operation Object reference\n      if (!this.options.resolve.internal && isInternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      // ignore resolving external Operation Object reference\n      if (!this.options.resolve.external && isExternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      const reference = await this.toReference(toValue(linkElement.operationRef));\n      operationElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n      // applying semantics to a referenced element\n      if (isPrimitiveElement(operationElement)) {\n        const cacheKey = `operation-${toValue(identityManager.identify(operationElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          operationElement = this.refractCache.get(cacheKey);\n        } else {\n          operationElement = OperationElement.refract(operationElement);\n          this.refractCache.set(cacheKey, operationElement);\n        }\n      }\n      // create shallow clone to be able to annotate with metadata\n      operationElement = cloneShallow(operationElement);\n      // annotate operation element with info about origin\n      operationElement.setMetaProperty('ref-origin', reference.uri);\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper = linkElementCopy.operationRef) === null || _linkElementCopy$oper === void 0 || _linkElementCopy$oper.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    if (isStringElement(linkElement.operationId)) {\n      var _linkElementCopy$oper2;\n      const operationId = toValue(linkElement.operationId);\n      const reference = await this.toReference(url.unsanitize(this.reference.uri));\n      operationElement = find(e => isOperationElement(e) && isElement(e.operationId) && e.operationId.equals(operationId), reference.value.result);\n      // OperationElement not found by its operationId\n      if (isUndefined(operationElement)) {\n        throw new ApiDOMError(`OperationElement(operationId=${operationId}) not found.`);\n      }\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper2 = linkElementCopy.operationId) === null || _linkElementCopy$oper2 === void 0 || _linkElementCopy$oper2.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    return undefined;\n  }\n  async ExampleElement(exampleElement, key, parent, path, ancestors, link) {\n    // ignore ExampleElement without externalValue field\n    if (!isStringElement(exampleElement.externalValue)) {\n      return undefined;\n    }\n\n    // value and externalValue fields are mutually exclusive\n    if (exampleElement.hasKey('value') && isStringElement(exampleElement.externalValue)) {\n      throw new ApiDOMError('ExampleElement value and externalValue fields are mutually exclusive.');\n    }\n    const retrievalURI = this.toBaseURI(toValue(exampleElement.externalValue));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Example Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Example Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    const reference = await this.toReference(toValue(exampleElement.externalValue));\n\n    // shallow clone of the referenced element\n    const valueElement = cloneShallow(reference.value.result);\n    // annotate operation element with info about origin\n    valueElement.setMetaProperty('ref-origin', reference.uri);\n    const exampleElementCopy = cloneShallow(exampleElement);\n    exampleElementCopy.value = valueElement;\n\n    /**\n     * Transclude Example Object containing external value.\n     */\n    link.replaceWith(exampleElementCopy, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? exampleElementCopy : undefined;\n  }\n  async SchemaElement(referencingElement, key, parent, path, ancestors, link) {\n    // skip current referencing schema as $ref keyword was not defined\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n\n    // compute baseURI using rules around $id and $ref keywords\n    let reference = await this.toReference(url.unsanitize(this.reference.uri));\n    let {\n      uri: retrievalURI\n    } = reference;\n    const $refBaseURI = resolveSchema$refField(retrievalURI, referencingElement);\n    const $refBaseURIStrippedHash = url.stripHash($refBaseURI);\n    const file = new File({\n      uri: $refBaseURIStrippedHash\n    });\n    const isUnknownURI = none(r => r.canRead(file), this.options.resolve.resolvers);\n    const isURL = !isUnknownURI;\n    let isInternalReference = url.stripHash(this.reference.uri) === $refBaseURI;\n    let isExternalReference = !isInternalReference;\n    this.indirections.push(referencingElement);\n\n    // determining reference, proper evaluation and selection mechanism\n    let referencedElement;\n    try {\n      if (isUnknownURI || isURL) {\n        // we're dealing with canonical URI or URL with possible fragment\n        retrievalURI = this.toBaseURI($refBaseURI);\n        const selector = $refBaseURI;\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = uriEvaluate(selector, referenceAsSchema);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n      } else {\n        // we're assuming here that we're dealing with JSON Pointer here\n        retrievalURI = this.toBaseURI($refBaseURI);\n        isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n        isExternalReference = !isInternalReference;\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        reference = await this.toReference(url.unsanitize($refBaseURI));\n        const selector = uriToPointer($refBaseURI);\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = jsonPointerEvaluate(selector, referenceAsSchema);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n      }\n    } catch (error) {\n      /**\n       * No SchemaElement($id=URL) was not found, so we're going to try to resolve\n       * the URL and assume the returned response is a JSON Schema.\n       */\n      if (isURL && error instanceof EvaluationJsonSchemaUriError) {\n        if (isAnchor(uriToAnchor($refBaseURI))) {\n          // we're dealing with JSON Schema $anchor here\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = uriToAnchor($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = $anchorEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        } else {\n          // we're assuming here that we're dealing with JSON Pointer here\n          retrievalURI = this.toBaseURI($refBaseURI);\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = uriToPointer($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = jsonPointerEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        }\n      } else {\n        throw error;\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      throw new ApiDOMError('Recursive Schema Object reference detected');\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        throw new ApiDOMError('Circular reference detected');\n      } else if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer5, _this$options$derefer6;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'json-schema',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer5 = (_this$options$derefer6 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer6 === void 0 ? void 0 : _this$options$derefer6.circularReplacer) !== null && _this$options$derefer5 !== void 0 ? _this$options$derefer5 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Schema Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isSchemaElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.options,\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage\n      });\n      referencedElement = await visitAsync(referencedElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    // Boolean JSON Schemas\n    if (isBooleanJsonSchemaElement(referencedElement)) {\n      const booleanJsonSchemaElement = cloneDeep(referencedElement);\n      // assign unique id to merged element\n      booleanJsonSchemaElement.setMetaProperty('id', identityManager.generateId());\n      // annotate referenced element with info about original referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref)\n      });\n      // annotate referenced element with info about origin\n      booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      link.replaceWith(booleanJsonSchemaElement, mutationReplacer);\n      return !parent ? booleanJsonSchemaElement : false;\n    }\n\n    /**\n     * Creating a new version of Schema Object by merging fields from referenced Schema Object with referencing one.\n     */\n    if (isSchemaElement(referencedElement)) {\n      const mergedElement = new SchemaElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing schema overrides ones from referenced schema\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref)\n      });\n      // annotate fragment with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      referencedElement = mergedElement;\n    }\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n}\nexport default OpenAPI3_1DereferenceVisitor;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}