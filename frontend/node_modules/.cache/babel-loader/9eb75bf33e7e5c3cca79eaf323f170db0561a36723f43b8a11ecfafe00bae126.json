{"ast":null,"code":"import traverse from 'traverse';\nimport { url } from '@swagger-api/apidom-reference/configuration/empty';\nimport { DEFAULT_BASE_URL } from '../../constants.js';\n\n// This will match if the direct parent's key exactly matches an item.\nconst freelyNamedKeyParents = ['properties'];\n\n// This will match if the grandparent's key exactly matches an item.\n// NOTE that this is for finding non-free paths!\nconst nonFreelyNamedKeyGrandparents = ['properties'];\n\n// This will match if the joined parent path exactly matches an item.\n//\n// This is mostly useful for filtering out root-level reusable item names,\n// for example `[\"definitions\", \"$ref\"]`\nconst freelyNamedPaths = [\n// Swagger 2.0\n'definitions', 'parameters', 'responses', 'securityDefinitions',\n// OpenAPI 3.0\n'components/schemas', 'components/responses', 'components/parameters', 'components/securitySchemes'];\n\n// This will match if any of these items are substrings of the joined\n// parent path.\n//\n// Warning! These are powerful. Beware of edge cases.\nconst freelyNamedAncestors = ['schema/example', 'items/example'];\nexport function isFreelyNamed(parentPath) {\n  const parentKey = parentPath[parentPath.length - 1];\n  const grandparentKey = parentPath[parentPath.length - 2];\n  const parentStr = parentPath.join('/');\n  return (\n    // eslint-disable-next-line max-len\n    freelyNamedKeyParents.indexOf(parentKey) > -1 && nonFreelyNamedKeyGrandparents.indexOf(grandparentKey) === -1 || freelyNamedPaths.indexOf(parentStr) > -1 || freelyNamedAncestors.some(el => parentStr.indexOf(el) > -1)\n  );\n}\nexport function generateAbsoluteRefPatches(obj, basePath, {\n  specmap,\n  getBaseUrlForNodePath = path => specmap.getContext([...basePath, ...path]).baseDoc,\n  targetKeys = ['$ref', '$$ref']\n} = {}) {\n  const patches = [];\n  traverse(obj).forEach(function callback() {\n    if (targetKeys.includes(this.key) && typeof this.node === 'string') {\n      const nodePath = this.path; // this node's path, relative to `obj`\n      const fullPath = basePath.concat(this.path);\n      const absolutifiedRefValue = absolutifyPointer(this.node, getBaseUrlForNodePath(nodePath));\n      patches.push(specmap.replace(fullPath, absolutifiedRefValue));\n    }\n  });\n  return patches;\n}\nexport function absolutifyPointer(pointer, baseUrl) {\n  const [urlPart, fragmentPart] = pointer.split('#');\n  const safeBaseUrl = baseUrl !== null && baseUrl !== void 0 ? baseUrl : '';\n  const safeUrlPart = urlPart !== null && urlPart !== void 0 ? urlPart : '';\n  let newRefUrlPart;\n  if (!url.isHttpUrl(safeBaseUrl)) {\n    const absoluteBaseUrl = url.resolve(DEFAULT_BASE_URL, safeBaseUrl);\n    const absoluteRefUrlPart = url.resolve(absoluteBaseUrl, safeUrlPart);\n    const rawRefUrlPart = absoluteRefUrlPart.replace(DEFAULT_BASE_URL, '');\n    newRefUrlPart = safeUrlPart.startsWith('/') ? rawRefUrlPart : rawRefUrlPart.substring(1);\n  } else {\n    newRefUrlPart = url.resolve(safeBaseUrl, safeUrlPart);\n  }\n  return fragmentPart ? `${newRefUrlPart}#${fragmentPart}` : newRefUrlPart;\n}","map":{"version":3,"names":["traverse","url","DEFAULT_BASE_URL","freelyNamedKeyParents","nonFreelyNamedKeyGrandparents","freelyNamedPaths","freelyNamedAncestors","isFreelyNamed","parentPath","parentKey","length","grandparentKey","parentStr","join","indexOf","some","el","generateAbsoluteRefPatches","obj","basePath","specmap","getBaseUrlForNodePath","path","getContext","baseDoc","targetKeys","patches","forEach","callback","includes","key","node","nodePath","fullPath","concat","absolutifiedRefValue","absolutifyPointer","push","replace","pointer","baseUrl","urlPart","fragmentPart","split","safeBaseUrl","safeUrlPart","newRefUrlPart","isHttpUrl","absoluteBaseUrl","resolve","absoluteRefUrlPart","rawRefUrlPart","startsWith","substring"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/resolver/specmap/helpers.js"],"sourcesContent":["import traverse from 'traverse';\nimport { url } from '@swagger-api/apidom-reference/configuration/empty';\nimport { DEFAULT_BASE_URL } from '../../constants.js';\n\n// This will match if the direct parent's key exactly matches an item.\nconst freelyNamedKeyParents = ['properties'];\n\n// This will match if the grandparent's key exactly matches an item.\n// NOTE that this is for finding non-free paths!\nconst nonFreelyNamedKeyGrandparents = ['properties'];\n\n// This will match if the joined parent path exactly matches an item.\n//\n// This is mostly useful for filtering out root-level reusable item names,\n// for example `[\"definitions\", \"$ref\"]`\nconst freelyNamedPaths = [\n// Swagger 2.0\n'definitions', 'parameters', 'responses', 'securityDefinitions',\n// OpenAPI 3.0\n'components/schemas', 'components/responses', 'components/parameters', 'components/securitySchemes'];\n\n// This will match if any of these items are substrings of the joined\n// parent path.\n//\n// Warning! These are powerful. Beware of edge cases.\nconst freelyNamedAncestors = ['schema/example', 'items/example'];\nexport function isFreelyNamed(parentPath) {\n  const parentKey = parentPath[parentPath.length - 1];\n  const grandparentKey = parentPath[parentPath.length - 2];\n  const parentStr = parentPath.join('/');\n  return (\n    // eslint-disable-next-line max-len\n    freelyNamedKeyParents.indexOf(parentKey) > -1 && nonFreelyNamedKeyGrandparents.indexOf(grandparentKey) === -1 || freelyNamedPaths.indexOf(parentStr) > -1 || freelyNamedAncestors.some(el => parentStr.indexOf(el) > -1)\n  );\n}\nexport function generateAbsoluteRefPatches(obj, basePath, {\n  specmap,\n  getBaseUrlForNodePath = path => specmap.getContext([...basePath, ...path]).baseDoc,\n  targetKeys = ['$ref', '$$ref']\n} = {}) {\n  const patches = [];\n  traverse(obj).forEach(function callback() {\n    if (targetKeys.includes(this.key) && typeof this.node === 'string') {\n      const nodePath = this.path; // this node's path, relative to `obj`\n      const fullPath = basePath.concat(this.path);\n      const absolutifiedRefValue = absolutifyPointer(this.node, getBaseUrlForNodePath(nodePath));\n      patches.push(specmap.replace(fullPath, absolutifiedRefValue));\n    }\n  });\n  return patches;\n}\nexport function absolutifyPointer(pointer, baseUrl) {\n  const [urlPart, fragmentPart] = pointer.split('#');\n  const safeBaseUrl = baseUrl !== null && baseUrl !== void 0 ? baseUrl : '';\n  const safeUrlPart = urlPart !== null && urlPart !== void 0 ? urlPart : '';\n  let newRefUrlPart;\n  if (!url.isHttpUrl(safeBaseUrl)) {\n    const absoluteBaseUrl = url.resolve(DEFAULT_BASE_URL, safeBaseUrl);\n    const absoluteRefUrlPart = url.resolve(absoluteBaseUrl, safeUrlPart);\n    const rawRefUrlPart = absoluteRefUrlPart.replace(DEFAULT_BASE_URL, '');\n    newRefUrlPart = safeUrlPart.startsWith('/') ? rawRefUrlPart : rawRefUrlPart.substring(1);\n  } else {\n    newRefUrlPart = url.resolve(safeBaseUrl, safeUrlPart);\n  }\n  return fragmentPart ? `${newRefUrlPart}#${fragmentPart}` : newRefUrlPart;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}