{"ast":null,"code":"import { defaultTo, has, mapObjIndexed, path, propSatisfies } from 'ramda';\nimport { isPlainObject, isString, trimCharsStart } from 'ramda-adjunct';\n\n/**\n * This dereference algorithm is used exclusively for dereferencing specification objects.\n * It doesn't handle circular references of external references and works on objects only (not arrays).\n */\n// eslint-disable-next-line import/prefer-default-export\nexport const dereference = (object, root) => {\n  const rootObject = defaultTo(object, root);\n  return mapObjIndexed(val => {\n    if (isPlainObject(val) && has('$ref', val) && propSatisfies(isString, '$ref', val)) {\n      const $ref = path(['$ref'], val);\n      // @ts-ignore\n      const pointer = trimCharsStart('#/', $ref);\n      return path(pointer.split('/'), rootObject);\n    }\n    if (isPlainObject(val)) {\n      return dereference(val, rootObject);\n    }\n    return val;\n  }, object);\n};","map":{"version":3,"names":["defaultTo","has","mapObjIndexed","path","propSatisfies","isPlainObject","isString","trimCharsStart","dereference","object","root","rootObject","val","$ref","pointer","split"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-core/es/util.mjs"],"sourcesContent":["import { defaultTo, has, mapObjIndexed, path, propSatisfies } from 'ramda';\nimport { isPlainObject, isString, trimCharsStart } from 'ramda-adjunct';\n\n/**\n * This dereference algorithm is used exclusively for dereferencing specification objects.\n * It doesn't handle circular references of external references and works on objects only (not arrays).\n */\n// eslint-disable-next-line import/prefer-default-export\nexport const dereference = (object, root) => {\n  const rootObject = defaultTo(object, root);\n  return mapObjIndexed(val => {\n    if (isPlainObject(val) && has('$ref', val) && propSatisfies(isString, '$ref', val)) {\n      const $ref = path(['$ref'], val);\n      // @ts-ignore\n      const pointer = trimCharsStart('#/', $ref);\n      return path(pointer.split('/'), rootObject);\n    }\n    if (isPlainObject(val)) {\n      return dereference(val, rootObject);\n    }\n    return val;\n  }, object);\n};"],"mappings":"AAAA,SAASA,SAAS,EAAEC,GAAG,EAAEC,aAAa,EAAEC,IAAI,EAAEC,aAAa,QAAQ,OAAO;AAC1E,SAASC,aAAa,EAAEC,QAAQ,EAAEC,cAAc,QAAQ,eAAe;;AAEvE;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAGA,CAACC,MAAM,EAAEC,IAAI,KAAK;EAC3C,MAAMC,UAAU,GAAGX,SAAS,CAACS,MAAM,EAAEC,IAAI,CAAC;EAC1C,OAAOR,aAAa,CAACU,GAAG,IAAI;IAC1B,IAAIP,aAAa,CAACO,GAAG,CAAC,IAAIX,GAAG,CAAC,MAAM,EAAEW,GAAG,CAAC,IAAIR,aAAa,CAACE,QAAQ,EAAE,MAAM,EAAEM,GAAG,CAAC,EAAE;MAClF,MAAMC,IAAI,GAAGV,IAAI,CAAC,CAAC,MAAM,CAAC,EAAES,GAAG,CAAC;MAChC;MACA,MAAME,OAAO,GAAGP,cAAc,CAAC,IAAI,EAAEM,IAAI,CAAC;MAC1C,OAAOV,IAAI,CAACW,OAAO,CAACC,KAAK,CAAC,GAAG,CAAC,EAAEJ,UAAU,CAAC;IAC7C;IACA,IAAIN,aAAa,CAACO,GAAG,CAAC,EAAE;MACtB,OAAOJ,WAAW,CAACI,GAAG,EAAED,UAAU,CAAC;IACrC;IACA,OAAOC,GAAG;EACZ,CAAC,EAAEH,MAAM,CAAC;AACZ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}