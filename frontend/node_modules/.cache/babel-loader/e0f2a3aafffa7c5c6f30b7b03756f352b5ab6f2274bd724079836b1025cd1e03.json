{"ast":null,"code":"import { last, pathOr } from 'ramda';\nimport { isNumber } from 'ramda-adjunct';\nimport { hasElementSourceMap } from \"../predicates/index.mjs\";\nimport { visit } from \"./visitor.mjs\";\nimport toValue from \"../transformers/serializers/value/index.mjs\";\nclass Visitor {\n  result;\n  offset;\n  includeRightBound;\n  constructor({\n    offset = 0,\n    includeRightBound = false\n  } = {}) {\n    this.result = [];\n    this.offset = offset;\n    this.includeRightBound = includeRightBound;\n  }\n  enter(element) {\n    if (!hasElementSourceMap(element)) {\n      return undefined; // dive in\n    }\n    const sourceMapElement = element.getMetaProperty('sourceMap');\n    const charStart = toValue(sourceMapElement.positionStart.get(2));\n    const charEnd = toValue(sourceMapElement.positionEnd.get(2));\n    const isWithinOffsetRange = this.offset >= charStart && (this.offset < charEnd || this.includeRightBound && this.offset <= charEnd);\n    if (isWithinOffsetRange) {\n      this.result.push(element);\n      return undefined; // push to stack and dive in\n    }\n    return false; // skip entire sub-tree\n  }\n}\n// Finds the most inner node at the given offset.\n// If includeRightBound is set, also finds nodes that end at the given offset.\n// findAtOffset :: Number -> Element -> Element | Undefined\nconst findAtOffset = (options, element) => {\n  let offset;\n  let includeRightBound;\n  if (isNumber(options)) {\n    offset = options;\n    includeRightBound = false;\n  } else {\n    offset = pathOr(0, ['offset'], options);\n    includeRightBound = pathOr(false, ['includeRightBound'], options);\n  }\n  const visitor = new Visitor({\n    offset,\n    includeRightBound\n  });\n  visit(element, visitor);\n  return last(visitor.result);\n};\nexport default findAtOffset;","map":{"version":3,"names":["last","pathOr","isNumber","hasElementSourceMap","visit","toValue","Visitor","result","offset","includeRightBound","constructor","enter","element","undefined","sourceMapElement","getMetaProperty","charStart","positionStart","get","charEnd","positionEnd","isWithinOffsetRange","push","findAtOffset","options","visitor"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-core/es/traversal/findAtOffset.mjs"],"sourcesContent":["import { last, pathOr } from 'ramda';\nimport { isNumber } from 'ramda-adjunct';\nimport { hasElementSourceMap } from \"../predicates/index.mjs\";\nimport { visit } from \"./visitor.mjs\";\nimport toValue from \"../transformers/serializers/value/index.mjs\";\nclass Visitor {\n  result;\n  offset;\n  includeRightBound;\n  constructor({\n    offset = 0,\n    includeRightBound = false\n  } = {}) {\n    this.result = [];\n    this.offset = offset;\n    this.includeRightBound = includeRightBound;\n  }\n  enter(element) {\n    if (!hasElementSourceMap(element)) {\n      return undefined; // dive in\n    }\n    const sourceMapElement = element.getMetaProperty('sourceMap');\n    const charStart = toValue(sourceMapElement.positionStart.get(2));\n    const charEnd = toValue(sourceMapElement.positionEnd.get(2));\n    const isWithinOffsetRange = this.offset >= charStart && (this.offset < charEnd || this.includeRightBound && this.offset <= charEnd);\n    if (isWithinOffsetRange) {\n      this.result.push(element);\n      return undefined; // push to stack and dive in\n    }\n    return false; // skip entire sub-tree\n  }\n}\n// Finds the most inner node at the given offset.\n// If includeRightBound is set, also finds nodes that end at the given offset.\n// findAtOffset :: Number -> Element -> Element | Undefined\nconst findAtOffset = (options, element) => {\n  let offset;\n  let includeRightBound;\n  if (isNumber(options)) {\n    offset = options;\n    includeRightBound = false;\n  } else {\n    offset = pathOr(0, ['offset'], options);\n    includeRightBound = pathOr(false, ['includeRightBound'], options);\n  }\n  const visitor = new Visitor({\n    offset,\n    includeRightBound\n  });\n  visit(element, visitor);\n  return last(visitor.result);\n};\nexport default findAtOffset;"],"mappings":"AAAA,SAASA,IAAI,EAAEC,MAAM,QAAQ,OAAO;AACpC,SAASC,QAAQ,QAAQ,eAAe;AACxC,SAASC,mBAAmB,QAAQ,yBAAyB;AAC7D,SAASC,KAAK,QAAQ,eAAe;AACrC,OAAOC,OAAO,MAAM,6CAA6C;AACjE,MAAMC,OAAO,CAAC;EACZC,MAAM;EACNC,MAAM;EACNC,iBAAiB;EACjBC,WAAWA,CAAC;IACVF,MAAM,GAAG,CAAC;IACVC,iBAAiB,GAAG;EACtB,CAAC,GAAG,CAAC,CAAC,EAAE;IACN,IAAI,CAACF,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;EAC5C;EACAE,KAAKA,CAACC,OAAO,EAAE;IACb,IAAI,CAACT,mBAAmB,CAACS,OAAO,CAAC,EAAE;MACjC,OAAOC,SAAS,CAAC,CAAC;IACpB;IACA,MAAMC,gBAAgB,GAAGF,OAAO,CAACG,eAAe,CAAC,WAAW,CAAC;IAC7D,MAAMC,SAAS,GAAGX,OAAO,CAACS,gBAAgB,CAACG,aAAa,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC;IAChE,MAAMC,OAAO,GAAGd,OAAO,CAACS,gBAAgB,CAACM,WAAW,CAACF,GAAG,CAAC,CAAC,CAAC,CAAC;IAC5D,MAAMG,mBAAmB,GAAG,IAAI,CAACb,MAAM,IAAIQ,SAAS,KAAK,IAAI,CAACR,MAAM,GAAGW,OAAO,IAAI,IAAI,CAACV,iBAAiB,IAAI,IAAI,CAACD,MAAM,IAAIW,OAAO,CAAC;IACnI,IAAIE,mBAAmB,EAAE;MACvB,IAAI,CAACd,MAAM,CAACe,IAAI,CAACV,OAAO,CAAC;MACzB,OAAOC,SAAS,CAAC,CAAC;IACpB;IACA,OAAO,KAAK,CAAC,CAAC;EAChB;AACF;AACA;AACA;AACA;AACA,MAAMU,YAAY,GAAGA,CAACC,OAAO,EAAEZ,OAAO,KAAK;EACzC,IAAIJ,MAAM;EACV,IAAIC,iBAAiB;EACrB,IAAIP,QAAQ,CAACsB,OAAO,CAAC,EAAE;IACrBhB,MAAM,GAAGgB,OAAO;IAChBf,iBAAiB,GAAG,KAAK;EAC3B,CAAC,MAAM;IACLD,MAAM,GAAGP,MAAM,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,EAAEuB,OAAO,CAAC;IACvCf,iBAAiB,GAAGR,MAAM,CAAC,KAAK,EAAE,CAAC,mBAAmB,CAAC,EAAEuB,OAAO,CAAC;EACnE;EACA,MAAMC,OAAO,GAAG,IAAInB,OAAO,CAAC;IAC1BE,MAAM;IACNC;EACF,CAAC,CAAC;EACFL,KAAK,CAACQ,OAAO,EAAEa,OAAO,CAAC;EACvB,OAAOzB,IAAI,CAACyB,OAAO,CAAClB,MAAM,CAAC;AAC7B,CAAC;AACD,eAAegB,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}