{"ast":null,"code":"import { keyMap as keyMapBase, isElement } from '@swagger-api/apidom-core';\n\n// getNodeType :: Node -> String\nexport const getNodeType = element => {\n  if (!isElement(element)) {\n    return undefined;\n  }\n  return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;\n};\n\n/**\n * There are unfortunately two `LinkElement` types. One is from base namespace\n * and the other one if from this namespace. `LinkElement` from base namespace\n * is used extremely rarely, so it's almost always safe during traversing\n * to assume that `LinkElement` is element from this namespace.\n *\n * To be 100% sure that currently visiting `LinkElement` is from this namespace\n * use `isLinkElement` predicate from this namespace to assert for it.\n */\n\nexport const keyMap = {\n  CallbackElement: ['content'],\n  ComponentsElement: ['content'],\n  ContactElement: ['content'],\n  DiscriminatorElement: ['content'],\n  Encoding: ['content'],\n  Example: ['content'],\n  ExternalDocumentationElement: ['content'],\n  HeaderElement: ['content'],\n  InfoElement: ['content'],\n  LicenseElement: ['content'],\n  MediaTypeElement: ['content'],\n  OAuthFlowElement: ['content'],\n  OAuthFlowsElement: ['content'],\n  OpenApi3_0Element: ['content'],\n  OperationElement: ['content'],\n  ParameterElement: ['content'],\n  PathItemElement: ['content'],\n  PathsElement: ['content'],\n  ReferenceElement: ['content'],\n  RequestBodyElement: ['content'],\n  ResponseElement: ['content'],\n  ResponsesElement: ['content'],\n  SchemaElement: ['content'],\n  SecurityRequirementElement: ['content'],\n  SecuritySchemeElement: ['content'],\n  ServerElement: ['content'],\n  ServerVariableElement: ['content'],\n  TagElement: ['content'],\n  ...keyMapBase\n};","map":{"version":3,"names":["keyMap","keyMapBase","isElement","getNodeType","element","undefined","charAt","toUpperCase","slice","CallbackElement","ComponentsElement","ContactElement","DiscriminatorElement","Encoding","Example","ExternalDocumentationElement","HeaderElement","InfoElement","LicenseElement","MediaTypeElement","OAuthFlowElement","OAuthFlowsElement","OpenApi3_0Element","OperationElement","ParameterElement","PathItemElement","PathsElement","ReferenceElement","RequestBodyElement","ResponseElement","ResponsesElement","SchemaElement","SecurityRequirementElement","SecuritySchemeElement","ServerElement","ServerVariableElement","TagElement"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-ns-openapi-3-0/es/traversal/visitor.mjs"],"sourcesContent":["import { keyMap as keyMapBase, isElement } from '@swagger-api/apidom-core';\n\n// getNodeType :: Node -> String\nexport const getNodeType = element => {\n  if (!isElement(element)) {\n    return undefined;\n  }\n  return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;\n};\n\n/**\n * There are unfortunately two `LinkElement` types. One is from base namespace\n * and the other one if from this namespace. `LinkElement` from base namespace\n * is used extremely rarely, so it's almost always safe during traversing\n * to assume that `LinkElement` is element from this namespace.\n *\n * To be 100% sure that currently visiting `LinkElement` is from this namespace\n * use `isLinkElement` predicate from this namespace to assert for it.\n */\n\nexport const keyMap = {\n  CallbackElement: ['content'],\n  ComponentsElement: ['content'],\n  ContactElement: ['content'],\n  DiscriminatorElement: ['content'],\n  Encoding: ['content'],\n  Example: ['content'],\n  ExternalDocumentationElement: ['content'],\n  HeaderElement: ['content'],\n  InfoElement: ['content'],\n  LicenseElement: ['content'],\n  MediaTypeElement: ['content'],\n  OAuthFlowElement: ['content'],\n  OAuthFlowsElement: ['content'],\n  OpenApi3_0Element: ['content'],\n  OperationElement: ['content'],\n  ParameterElement: ['content'],\n  PathItemElement: ['content'],\n  PathsElement: ['content'],\n  ReferenceElement: ['content'],\n  RequestBodyElement: ['content'],\n  ResponseElement: ['content'],\n  ResponsesElement: ['content'],\n  SchemaElement: ['content'],\n  SecurityRequirementElement: ['content'],\n  SecuritySchemeElement: ['content'],\n  ServerElement: ['content'],\n  ServerVariableElement: ['content'],\n  TagElement: ['content'],\n  ...keyMapBase\n};"],"mappings":"AAAA,SAASA,MAAM,IAAIC,UAAU,EAAEC,SAAS,QAAQ,0BAA0B;;AAE1E;AACA,OAAO,MAAMC,WAAW,GAAGC,OAAO,IAAI;EACpC,IAAI,CAACF,SAAS,CAACE,OAAO,CAAC,EAAE;IACvB,OAAOC,SAAS;EAClB;EACA,OAAO,GAAGD,OAAO,CAACA,OAAO,CAACE,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGH,OAAO,CAACA,OAAO,CAACI,KAAK,CAAC,CAAC,CAAC,SAAS;AACvF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMR,MAAM,GAAG;EACpBS,eAAe,EAAE,CAAC,SAAS,CAAC;EAC5BC,iBAAiB,EAAE,CAAC,SAAS,CAAC;EAC9BC,cAAc,EAAE,CAAC,SAAS,CAAC;EAC3BC,oBAAoB,EAAE,CAAC,SAAS,CAAC;EACjCC,QAAQ,EAAE,CAAC,SAAS,CAAC;EACrBC,OAAO,EAAE,CAAC,SAAS,CAAC;EACpBC,4BAA4B,EAAE,CAAC,SAAS,CAAC;EACzCC,aAAa,EAAE,CAAC,SAAS,CAAC;EAC1BC,WAAW,EAAE,CAAC,SAAS,CAAC;EACxBC,cAAc,EAAE,CAAC,SAAS,CAAC;EAC3BC,gBAAgB,EAAE,CAAC,SAAS,CAAC;EAC7BC,gBAAgB,EAAE,CAAC,SAAS,CAAC;EAC7BC,iBAAiB,EAAE,CAAC,SAAS,CAAC;EAC9BC,iBAAiB,EAAE,CAAC,SAAS,CAAC;EAC9BC,gBAAgB,EAAE,CAAC,SAAS,CAAC;EAC7BC,gBAAgB,EAAE,CAAC,SAAS,CAAC;EAC7BC,eAAe,EAAE,CAAC,SAAS,CAAC;EAC5BC,YAAY,EAAE,CAAC,SAAS,CAAC;EACzBC,gBAAgB,EAAE,CAAC,SAAS,CAAC;EAC7BC,kBAAkB,EAAE,CAAC,SAAS,CAAC;EAC/BC,eAAe,EAAE,CAAC,SAAS,CAAC;EAC5BC,gBAAgB,EAAE,CAAC,SAAS,CAAC;EAC7BC,aAAa,EAAE,CAAC,SAAS,CAAC;EAC1BC,0BAA0B,EAAE,CAAC,SAAS,CAAC;EACvCC,qBAAqB,EAAE,CAAC,SAAS,CAAC;EAClCC,aAAa,EAAE,CAAC,SAAS,CAAC;EAC1BC,qBAAqB,EAAE,CAAC,SAAS,CAAC;EAClCC,UAAU,EAAE,CAAC,SAAS,CAAC;EACvB,GAAGnC;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}