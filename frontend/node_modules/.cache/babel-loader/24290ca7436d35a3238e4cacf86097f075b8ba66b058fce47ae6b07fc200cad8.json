{"ast":null,"code":"import jsYaml from 'js-yaml';\nimport { ApiDOMStructuredError } from '@swagger-api/apidom-error';\nimport { url } from '@swagger-api/apidom-reference/configuration/empty';\nimport '../../../helpers/fetch-polyfill.node.js';\nimport lib from './index.js';\nimport { isFreelyNamed, absolutifyPointer } from '../helpers.js';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from '../../../constants.js';\nconst ABSOLUTE_URL_REGEXP = /^([a-z]+:\\/\\/|\\/\\/)/i;\nclass JSONRefError extends ApiDOMStructuredError {}\nconst docCache = {};\nconst specmapRefs = new WeakMap();\nconst skipResolutionTestFns = [\n// OpenAPI 2.0 response examples\npath =>\n// [\"paths\", *, *, \"responses\", *, \"examples\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'examples',\n// OpenAPI 3.0 Response Media Type Examples\npath =>\n// [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'example', path =>\n// [\"paths\", *, *, \"responses\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value',\n// OpenAPI 3.0 Request Body Media Type Examples\npath =>\n// [\"paths\", *, *, \"requestBody\", \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'example', path =>\n// [\"paths\", *, *, \"requestBody\", \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value',\n// OAS 3.0 Parameter Examples\npath =>\n// [\"paths\", *, \"parameters\", *, \"example\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'example', path =>\n// [\"paths\", *, *, \"parameters\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'example', path =>\n// [\"paths\", *, \"parameters\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'examples' && path[6] === 'value', path =>\n// [\"paths\", *, *, \"parameters\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'examples' && path[7] === 'value', path =>\n// [\"paths\", *, \"parameters\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'example', path =>\n// [\"paths\", *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value', path =>\n// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[4] === 'content' && path[7] === 'example', path =>\n// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'];\nconst shouldSkipResolution = path => skipResolutionTestFns.some(fn => fn(path));\n\n// =========================\n// Core\n// =========================\n\n/**\n * This plugin resolves the JSON pointers.\n * A major part of this plugin deals with cyclic references via 2 mechanisms.\n * 1. If a pointer was already resolved before in this path, halt.\n * 2. If the patch value points to one of the ancestors in this path, halt.\n *\n * Note that either one of these mechanism is sufficient, both must be in place.\n * For examples:\n *\n * Given the following spec, #1 alone is insufficient because after the 2nd\n * application, there will be a cyclic object reference.\n *   a.b.c: $ref-d\n *   d.e.f: $ref-a (per #1, safe to return patch as no immediate cycle)\n *\n * Given the following spec, #2 alone is insufficient because although there will\n * never be any cyclic object reference, the plugin will keep producing patches.\n *   a: $ref-b\n *   b: $ref-a\n */\nconst plugin = {\n  key: '$ref',\n  plugin: (ref, key, fullPath, specmap) => {\n    const specmapInstance = specmap.getInstance();\n    const parent = fullPath.slice(0, -1);\n    if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {\n      return undefined;\n    }\n    const {\n      baseDoc\n    } = specmap.getContext(fullPath);\n    if (typeof ref !== 'string') {\n      return new JSONRefError('$ref: must be a string (JSON-Ref)', {\n        $ref: ref,\n        baseDoc,\n        fullPath\n      });\n    }\n    const splitString = split(ref);\n    const refPath = splitString[0];\n    const pointer = splitString[1] || '';\n    let basePath;\n    try {\n      basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;\n    } catch (e) {\n      return wrapError(e, {\n        pointer,\n        $ref: ref,\n        basePath,\n        fullPath\n      });\n    }\n    let promOrVal;\n    let tokens;\n    if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {\n      // Cyclic reference!\n      // if `useCircularStructures` is not set, just leave the reference\n      // unresolved, but absolutify it so that we don't leave an invalid $ref\n      // path in the content\n      if (!specmapInstance.useCircularStructures) {\n        const absolutifiedRef = absolutifyPointer(ref, basePath);\n        if (ref === absolutifiedRef) {\n          // avoids endless looping\n          // without this, the ref plugin never stops seeing this $ref\n          return null;\n        }\n        return lib.replace(fullPath, absolutifiedRef);\n      }\n    }\n    if (basePath == null) {\n      tokens = jsonPointerToArray(pointer);\n      promOrVal = specmap.get(tokens);\n      if (typeof promOrVal === 'undefined') {\n        promOrVal = new JSONRefError(`Could not resolve reference: ${ref}`, {\n          pointer,\n          $ref: ref,\n          baseDoc,\n          fullPath\n        });\n      }\n    } else {\n      promOrVal = extractFromDoc(basePath, pointer);\n      // eslint-disable-next-line no-underscore-dangle\n      if (promOrVal.__value != null) {\n        promOrVal = promOrVal.__value; // eslint-disable-line no-underscore-dangle\n      } else {\n        promOrVal = promOrVal.catch(e => {\n          throw wrapError(e, {\n            pointer,\n            $ref: ref,\n            baseDoc,\n            fullPath\n          });\n        });\n      }\n    }\n    if (promOrVal instanceof Error) {\n      return [lib.remove(fullPath), promOrVal];\n    }\n    const absolutifiedRef = absolutifyPointer(ref, basePath);\n    const patch = lib.replace(parent, promOrVal, {\n      $$ref: absolutifiedRef\n    });\n    if (basePath && basePath !== baseDoc) {\n      return [patch, lib.context(parent, {\n        baseDoc: basePath\n      })];\n    }\n    try {\n      // prevents circular values from being constructed, unless we specifically\n      // want that to happen\n      if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {\n        return patch;\n      }\n    } catch (e) {\n      // if we're catching here, path traversal failed, so we should\n      // ditch without sending any patches back up.\n      //\n      // this is a narrow fix for the larger problem of patches being queued\n      // and then having the state they were generated against be modified\n      // before they are applied.\n      //\n      // TODO: re-engineer specmap patch/state management to avoid this\n      return null;\n    }\n    return undefined;\n  }\n};\nconst mod = Object.assign(plugin, {\n  docCache,\n  absoluteify,\n  clearCache,\n  JSONRefError,\n  wrapError,\n  getDoc,\n  split,\n  extractFromDoc,\n  fetchJSON,\n  extract,\n  jsonPointerToArray,\n  unescapeJsonPointerToken\n});\nexport default mod;\n\n// =========================\n// Utilities\n// =========================\n\n/**\n * Resolves a path and its base to an abolute URL.\n * @api public\n */\nfunction absoluteify(path, basePath) {\n  if (!ABSOLUTE_URL_REGEXP.test(path)) {\n    if (!basePath) {\n      throw new JSONRefError(`Tried to resolve a relative URL, without having a basePath. path: '${path}' basePath: '${basePath}'`);\n    }\n    return url.resolve(basePath, path);\n  }\n  return path;\n}\n\n/**\n * Wraps an error as JSONRefError.\n * @param  {Error} e      the error.\n * @param  {Object} extra (optional) optional data.\n * @return {Error}        an instance of JSONRefError.\n * @api public\n */\nfunction wrapError(e, extra) {\n  let message;\n  if (e && e.response && e.response.body) {\n    message = `${e.response.body.code} ${e.response.body.message}`;\n  } else {\n    message = e.message;\n  }\n  return new JSONRefError(`Could not resolve reference: ${message}`, {\n    ...extra,\n    cause: e\n  });\n}\n\n/**\n * Splits a pointer by the hash delimiter.\n * @api public\n */\nfunction split(ref) {\n  return (ref + '').split('#'); // eslint-disable-line prefer-template\n}\n\n/**\n * Extracts a pointer from its document.\n * @param  {String} docPath the absolute document URL.\n * @param  {String} pointer the pointer whose value is to be extracted.\n * @return {Promise}        a promise of the pointer value.\n * @api public\n */\nfunction extractFromDoc(docPath, pointer) {\n  const doc = docCache[docPath];\n  if (doc && !lib.isPromise(doc)) {\n    // If doc is already available, return __value together with the promise.\n    // __value is for special handling in cycle check:\n    // pointerAlreadyInPath() won't work if patch.value is a promise,\n    // thus when that promise is finally resolved, cycle might happen (because\n    // `spec` and `docCache[basePath]` refer to the exact same object).\n    // See test \"should resolve a cyclic spec when baseDoc is specified\".\n    try {\n      const v = extract(pointer, doc);\n      return Object.assign(Promise.resolve(v), {\n        __value: v\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  return getDoc(docPath).then(_doc => extract(pointer, _doc));\n}\n\n/**\n * Clears all document caches.\n * @param  {String} item (optional) the name of the cache item to be cleared.\n * @api public\n */\nfunction clearCache(item) {\n  if (typeof item !== 'undefined') {\n    delete docCache[item];\n  } else {\n    Object.keys(docCache).forEach(key => {\n      delete docCache[key];\n    });\n  }\n}\n\n/**\n * Fetches and caches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\nfunction getDoc(docPath) {\n  const val = docCache[docPath];\n  if (val) {\n    return lib.isPromise(val) ? val : Promise.resolve(val);\n  }\n\n  // NOTE: we need to use `mod.fetchJSON` in order to be able to overwrite it.\n  // Any tips on how to make this cleaner, please ping!\n  docCache[docPath] = mod.fetchJSON(docPath).then(doc => {\n    docCache[docPath] = doc;\n    return doc;\n  });\n  return docCache[docPath];\n}\n\n/**\n * Fetches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\nfunction fetchJSON(docPath) {\n  return fetch(docPath, {\n    headers: {\n      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n    },\n    loadSpec: true\n  }).then(res => res.text()).then(text => jsYaml.load(text));\n}\n\n/**\n * Extracts a pointer from an object.\n * @param  {String[]} pointer the JSON pointer.\n * @param  {Object} obj       an object whose value is to be extracted.\n * @return {Object}           the value to be extracted.\n * @api public\n */\nfunction extract(pointer, obj) {\n  const tokens = jsonPointerToArray(pointer);\n  if (tokens.length < 1) {\n    return obj;\n  }\n  const val = lib.getIn(obj, tokens);\n  if (typeof val === 'undefined') {\n    throw new JSONRefError(`Could not resolve pointer: ${pointer} does not exist in document`, {\n      pointer\n    });\n  }\n  return val;\n}\n\n/**\n * Converts a JSON pointer to array.\n * @api public\n */\nfunction jsonPointerToArray(pointer) {\n  if (typeof pointer !== 'string') {\n    throw new TypeError(`Expected a string, got a ${typeof pointer}`);\n  }\n  if (pointer[0] === '/') {\n    pointer = pointer.substr(1);\n  }\n  if (pointer === '') {\n    return [];\n  }\n  return pointer.split('/').map(unescapeJsonPointerToken);\n}\n\n/**\n * Unescapes a JSON pointer.\n * @api public\n */\nfunction unescapeJsonPointerToken(token) {\n  if (typeof token !== 'string') {\n    return token;\n  }\n  const params = new URLSearchParams(`=${token.replace(/~1/g, '/').replace(/~0/g, '~')}`);\n  return params.get('');\n}\n\n/**\n * Escapes a JSON pointer.\n * @api public\n */\nfunction escapeJsonPointerToken(token) {\n  const params = new URLSearchParams([['', token.replace(/~/g, '~0').replace(/\\//g, '~1')]]);\n  return params.toString().slice(1);\n}\nfunction arrayToJsonPointer(arr) {\n  if (arr.length === 0) {\n    return '';\n  }\n  return `/${arr.map(escapeJsonPointerToken).join('/')}`;\n}\nconst pointerBoundaryChar = c => !c || c === '/' || c === '#';\nfunction pointerIsAParent(pointer, parentPointer) {\n  if (pointerBoundaryChar(parentPointer)) {\n    // This is the root of the document, so its naturally a parent\n    return true;\n  }\n  const nextChar = pointer.charAt(parentPointer.length);\n  const lastParentChar = parentPointer.slice(-1);\n  return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === '/' || nextChar === '#') && lastParentChar !== '#';\n}\n\n// =========================\n// Private\n// =========================\n\n/**\n * Checks if this pointer points back to one or more pointers along the path.\n */\nfunction pointerAlreadyInPath(pointer, basePath, parent, specmap) {\n  let refs = specmapRefs.get(specmap);\n  if (!refs) {\n    // Stores all resolved references of a specmap instance.\n    // Schema: path -> pointer (path's $ref value).\n    refs = {};\n    specmapRefs.set(specmap, refs);\n  }\n  const parentPointer = arrayToJsonPointer(parent);\n  const fullyQualifiedPointer = `${basePath || '<specmap-base>'}#${pointer}`;\n\n  // dirty hack to strip `allof/[index]` from the path, in order to avoid cases\n  // where we get false negatives because:\n  // - we resolve a path, then\n  // - allOf plugin collapsed `allOf/[index]` out of the path, then\n  // - we try to work on a child $ref within that collapsed path.\n  //\n  // because of the path collapse, we lose track of it in our specmapRefs hash\n  // solution: always throw the allOf constructs out of paths we store\n  // TODO: solve this with a global register, or by writing more metadata in\n  // either allOf or refs plugin\n  const safeParentPointer = parentPointer.replace(/allOf\\/\\d+\\/?/g, '');\n\n  // Case 1: direct cycle, e.g. a.b.c.$ref: '/a.b'\n  // Detect by checking that the parent path doesn't start with pointer.\n  // This only applies if the pointer is internal, i.e. basePath === rootPath (could be null)\n  const rootDoc = specmap.contextTree.get([]).baseDoc;\n  if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {\n    // eslint-disable-line\n    return true;\n  }\n\n  // Case 2: indirect cycle\n  //  ex1: a.$ref: '/b'  &  b.c.$ref: '/b/c'\n  //  ex2: a.$ref: '/b/c'  &  b.c.$ref: '/b'\n  // Detect by retrieving all the $refs along the path of parent\n  // and checking if any starts with pointer or vice versa.\n  let currPath = '';\n  const hasIndirectCycle = parent.some(token => {\n    currPath = `${currPath}/${escapeJsonPointerToken(token)}`;\n    return refs[currPath] && refs[currPath].some(ref => pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref));\n  });\n  if (hasIndirectCycle) {\n    return true;\n  }\n\n  // No cycle, this ref will be resolved, so stores it now for future detection.\n  // No need to store if has cycle, as parent path is a dead-end and won't be checked again.\n\n  refs[safeParentPointer] = (refs[safeParentPointer] || []).concat(fullyQualifiedPointer);\n  return undefined;\n}\n\n/**\n * Checks if the value of this patch ends up pointing to an ancestor along the path.\n */\nfunction patchValueAlreadyInPath(root, patch) {\n  const ancestors = [root];\n  patch.path.reduce((parent, p) => {\n    ancestors.push(parent[p]);\n    return parent[p];\n  }, root);\n  return pointToAncestor(patch.value);\n  function pointToAncestor(obj) {\n    return lib.isObject(obj) && (ancestors.indexOf(obj) >= 0 || Object.keys(obj).some(k => pointToAncestor(obj[k])));\n  }\n}","map":{"version":3,"names":["jsYaml","ApiDOMStructuredError","url","lib","isFreelyNamed","absolutifyPointer","ACCEPT_HEADER_VALUE_FOR_DOCUMENTS","ABSOLUTE_URL_REGEXP","JSONRefError","docCache","specmapRefs","WeakMap","skipResolutionTestFns","path","shouldSkipResolution","some","fn","plugin","key","ref","fullPath","specmap","specmapInstance","getInstance","parent","slice","undefined","baseDoc","getContext","$ref","splitString","split","refPath","pointer","basePath","absoluteify","e","wrapError","promOrVal","tokens","pointerAlreadyInPath","useCircularStructures","absolutifiedRef","replace","jsonPointerToArray","get","extractFromDoc","__value","catch","Error","remove","patch","$$ref","context","patchValueAlreadyInPath","state","mod","Object","assign","clearCache","getDoc","fetchJSON","extract","unescapeJsonPointerToken","test","resolve","extra","message","response","body","code","cause","docPath","doc","isPromise","v","Promise","reject","then","_doc","item","keys","forEach","val","fetch","headers","Accept","loadSpec","res","text","load","obj","length","getIn","TypeError","substr","map","token","params","URLSearchParams","escapeJsonPointerToken","toString","arrayToJsonPointer","arr","join","pointerBoundaryChar","c","pointerIsAParent","parentPointer","nextChar","charAt","lastParentChar","indexOf","refs","set","fullyQualifiedPointer","safeParentPointer","rootDoc","contextTree","currPath","hasIndirectCycle","concat","root","ancestors","reduce","p","push","pointToAncestor","value","isObject","k"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/resolver/specmap/lib/refs.js"],"sourcesContent":["import jsYaml from 'js-yaml';\nimport { ApiDOMStructuredError } from '@swagger-api/apidom-error';\nimport { url } from '@swagger-api/apidom-reference/configuration/empty';\nimport '../../../helpers/fetch-polyfill.node.js';\nimport lib from './index.js';\nimport { isFreelyNamed, absolutifyPointer } from '../helpers.js';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from '../../../constants.js';\nconst ABSOLUTE_URL_REGEXP = /^([a-z]+:\\/\\/|\\/\\/)/i;\nclass JSONRefError extends ApiDOMStructuredError {}\nconst docCache = {};\nconst specmapRefs = new WeakMap();\nconst skipResolutionTestFns = [\n// OpenAPI 2.0 response examples\npath =>\n// [\"paths\", *, *, \"responses\", *, \"examples\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'examples',\n// OpenAPI 3.0 Response Media Type Examples\npath =>\n// [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'example', path =>\n// [\"paths\", *, *, \"responses\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value',\n// OpenAPI 3.0 Request Body Media Type Examples\npath =>\n// [\"paths\", *, *, \"requestBody\", \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'example', path =>\n// [\"paths\", *, *, \"requestBody\", \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value',\n// OAS 3.0 Parameter Examples\npath =>\n// [\"paths\", *, \"parameters\", *, \"example\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'example', path =>\n// [\"paths\", *, *, \"parameters\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'example', path =>\n// [\"paths\", *, \"parameters\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'examples' && path[6] === 'value', path =>\n// [\"paths\", *, *, \"parameters\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'examples' && path[7] === 'value', path =>\n// [\"paths\", *, \"parameters\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'example', path =>\n// [\"paths\", *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value', path =>\n// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"example\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[4] === 'content' && path[7] === 'example', path =>\n// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\npath[0] === 'paths' && path[3] === 'parameters' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'];\nconst shouldSkipResolution = path => skipResolutionTestFns.some(fn => fn(path));\n\n// =========================\n// Core\n// =========================\n\n/**\n * This plugin resolves the JSON pointers.\n * A major part of this plugin deals with cyclic references via 2 mechanisms.\n * 1. If a pointer was already resolved before in this path, halt.\n * 2. If the patch value points to one of the ancestors in this path, halt.\n *\n * Note that either one of these mechanism is sufficient, both must be in place.\n * For examples:\n *\n * Given the following spec, #1 alone is insufficient because after the 2nd\n * application, there will be a cyclic object reference.\n *   a.b.c: $ref-d\n *   d.e.f: $ref-a (per #1, safe to return patch as no immediate cycle)\n *\n * Given the following spec, #2 alone is insufficient because although there will\n * never be any cyclic object reference, the plugin will keep producing patches.\n *   a: $ref-b\n *   b: $ref-a\n */\nconst plugin = {\n  key: '$ref',\n  plugin: (ref, key, fullPath, specmap) => {\n    const specmapInstance = specmap.getInstance();\n    const parent = fullPath.slice(0, -1);\n    if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {\n      return undefined;\n    }\n    const {\n      baseDoc\n    } = specmap.getContext(fullPath);\n    if (typeof ref !== 'string') {\n      return new JSONRefError('$ref: must be a string (JSON-Ref)', {\n        $ref: ref,\n        baseDoc,\n        fullPath\n      });\n    }\n    const splitString = split(ref);\n    const refPath = splitString[0];\n    const pointer = splitString[1] || '';\n    let basePath;\n    try {\n      basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;\n    } catch (e) {\n      return wrapError(e, {\n        pointer,\n        $ref: ref,\n        basePath,\n        fullPath\n      });\n    }\n    let promOrVal;\n    let tokens;\n    if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {\n      // Cyclic reference!\n      // if `useCircularStructures` is not set, just leave the reference\n      // unresolved, but absolutify it so that we don't leave an invalid $ref\n      // path in the content\n      if (!specmapInstance.useCircularStructures) {\n        const absolutifiedRef = absolutifyPointer(ref, basePath);\n        if (ref === absolutifiedRef) {\n          // avoids endless looping\n          // without this, the ref plugin never stops seeing this $ref\n          return null;\n        }\n        return lib.replace(fullPath, absolutifiedRef);\n      }\n    }\n    if (basePath == null) {\n      tokens = jsonPointerToArray(pointer);\n      promOrVal = specmap.get(tokens);\n      if (typeof promOrVal === 'undefined') {\n        promOrVal = new JSONRefError(`Could not resolve reference: ${ref}`, {\n          pointer,\n          $ref: ref,\n          baseDoc,\n          fullPath\n        });\n      }\n    } else {\n      promOrVal = extractFromDoc(basePath, pointer);\n      // eslint-disable-next-line no-underscore-dangle\n      if (promOrVal.__value != null) {\n        promOrVal = promOrVal.__value; // eslint-disable-line no-underscore-dangle\n      } else {\n        promOrVal = promOrVal.catch(e => {\n          throw wrapError(e, {\n            pointer,\n            $ref: ref,\n            baseDoc,\n            fullPath\n          });\n        });\n      }\n    }\n    if (promOrVal instanceof Error) {\n      return [lib.remove(fullPath), promOrVal];\n    }\n    const absolutifiedRef = absolutifyPointer(ref, basePath);\n    const patch = lib.replace(parent, promOrVal, {\n      $$ref: absolutifiedRef\n    });\n    if (basePath && basePath !== baseDoc) {\n      return [patch, lib.context(parent, {\n        baseDoc: basePath\n      })];\n    }\n    try {\n      // prevents circular values from being constructed, unless we specifically\n      // want that to happen\n      if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {\n        return patch;\n      }\n    } catch (e) {\n      // if we're catching here, path traversal failed, so we should\n      // ditch without sending any patches back up.\n      //\n      // this is a narrow fix for the larger problem of patches being queued\n      // and then having the state they were generated against be modified\n      // before they are applied.\n      //\n      // TODO: re-engineer specmap patch/state management to avoid this\n      return null;\n    }\n    return undefined;\n  }\n};\nconst mod = Object.assign(plugin, {\n  docCache,\n  absoluteify,\n  clearCache,\n  JSONRefError,\n  wrapError,\n  getDoc,\n  split,\n  extractFromDoc,\n  fetchJSON,\n  extract,\n  jsonPointerToArray,\n  unescapeJsonPointerToken\n});\nexport default mod;\n\n// =========================\n// Utilities\n// =========================\n\n/**\n * Resolves a path and its base to an abolute URL.\n * @api public\n */\nfunction absoluteify(path, basePath) {\n  if (!ABSOLUTE_URL_REGEXP.test(path)) {\n    if (!basePath) {\n      throw new JSONRefError(`Tried to resolve a relative URL, without having a basePath. path: '${path}' basePath: '${basePath}'`);\n    }\n    return url.resolve(basePath, path);\n  }\n  return path;\n}\n\n/**\n * Wraps an error as JSONRefError.\n * @param  {Error} e      the error.\n * @param  {Object} extra (optional) optional data.\n * @return {Error}        an instance of JSONRefError.\n * @api public\n */\nfunction wrapError(e, extra) {\n  let message;\n  if (e && e.response && e.response.body) {\n    message = `${e.response.body.code} ${e.response.body.message}`;\n  } else {\n    message = e.message;\n  }\n  return new JSONRefError(`Could not resolve reference: ${message}`, {\n    ...extra,\n    cause: e\n  });\n}\n\n/**\n * Splits a pointer by the hash delimiter.\n * @api public\n */\nfunction split(ref) {\n  return (ref + '').split('#'); // eslint-disable-line prefer-template\n}\n\n/**\n * Extracts a pointer from its document.\n * @param  {String} docPath the absolute document URL.\n * @param  {String} pointer the pointer whose value is to be extracted.\n * @return {Promise}        a promise of the pointer value.\n * @api public\n */\nfunction extractFromDoc(docPath, pointer) {\n  const doc = docCache[docPath];\n  if (doc && !lib.isPromise(doc)) {\n    // If doc is already available, return __value together with the promise.\n    // __value is for special handling in cycle check:\n    // pointerAlreadyInPath() won't work if patch.value is a promise,\n    // thus when that promise is finally resolved, cycle might happen (because\n    // `spec` and `docCache[basePath]` refer to the exact same object).\n    // See test \"should resolve a cyclic spec when baseDoc is specified\".\n    try {\n      const v = extract(pointer, doc);\n      return Object.assign(Promise.resolve(v), {\n        __value: v\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  return getDoc(docPath).then(_doc => extract(pointer, _doc));\n}\n\n/**\n * Clears all document caches.\n * @param  {String} item (optional) the name of the cache item to be cleared.\n * @api public\n */\nfunction clearCache(item) {\n  if (typeof item !== 'undefined') {\n    delete docCache[item];\n  } else {\n    Object.keys(docCache).forEach(key => {\n      delete docCache[key];\n    });\n  }\n}\n\n/**\n * Fetches and caches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\nfunction getDoc(docPath) {\n  const val = docCache[docPath];\n  if (val) {\n    return lib.isPromise(val) ? val : Promise.resolve(val);\n  }\n\n  // NOTE: we need to use `mod.fetchJSON` in order to be able to overwrite it.\n  // Any tips on how to make this cleaner, please ping!\n  docCache[docPath] = mod.fetchJSON(docPath).then(doc => {\n    docCache[docPath] = doc;\n    return doc;\n  });\n  return docCache[docPath];\n}\n\n/**\n * Fetches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\nfunction fetchJSON(docPath) {\n  return fetch(docPath, {\n    headers: {\n      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n    },\n    loadSpec: true\n  }).then(res => res.text()).then(text => jsYaml.load(text));\n}\n\n/**\n * Extracts a pointer from an object.\n * @param  {String[]} pointer the JSON pointer.\n * @param  {Object} obj       an object whose value is to be extracted.\n * @return {Object}           the value to be extracted.\n * @api public\n */\nfunction extract(pointer, obj) {\n  const tokens = jsonPointerToArray(pointer);\n  if (tokens.length < 1) {\n    return obj;\n  }\n  const val = lib.getIn(obj, tokens);\n  if (typeof val === 'undefined') {\n    throw new JSONRefError(`Could not resolve pointer: ${pointer} does not exist in document`, {\n      pointer\n    });\n  }\n  return val;\n}\n\n/**\n * Converts a JSON pointer to array.\n * @api public\n */\nfunction jsonPointerToArray(pointer) {\n  if (typeof pointer !== 'string') {\n    throw new TypeError(`Expected a string, got a ${typeof pointer}`);\n  }\n  if (pointer[0] === '/') {\n    pointer = pointer.substr(1);\n  }\n  if (pointer === '') {\n    return [];\n  }\n  return pointer.split('/').map(unescapeJsonPointerToken);\n}\n\n/**\n * Unescapes a JSON pointer.\n * @api public\n */\nfunction unescapeJsonPointerToken(token) {\n  if (typeof token !== 'string') {\n    return token;\n  }\n  const params = new URLSearchParams(`=${token.replace(/~1/g, '/').replace(/~0/g, '~')}`);\n  return params.get('');\n}\n\n/**\n * Escapes a JSON pointer.\n * @api public\n */\nfunction escapeJsonPointerToken(token) {\n  const params = new URLSearchParams([['', token.replace(/~/g, '~0').replace(/\\//g, '~1')]]);\n  return params.toString().slice(1);\n}\nfunction arrayToJsonPointer(arr) {\n  if (arr.length === 0) {\n    return '';\n  }\n  return `/${arr.map(escapeJsonPointerToken).join('/')}`;\n}\nconst pointerBoundaryChar = c => !c || c === '/' || c === '#';\nfunction pointerIsAParent(pointer, parentPointer) {\n  if (pointerBoundaryChar(parentPointer)) {\n    // This is the root of the document, so its naturally a parent\n    return true;\n  }\n  const nextChar = pointer.charAt(parentPointer.length);\n  const lastParentChar = parentPointer.slice(-1);\n  return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === '/' || nextChar === '#') && lastParentChar !== '#';\n}\n\n// =========================\n// Private\n// =========================\n\n/**\n * Checks if this pointer points back to one or more pointers along the path.\n */\nfunction pointerAlreadyInPath(pointer, basePath, parent, specmap) {\n  let refs = specmapRefs.get(specmap);\n  if (!refs) {\n    // Stores all resolved references of a specmap instance.\n    // Schema: path -> pointer (path's $ref value).\n    refs = {};\n    specmapRefs.set(specmap, refs);\n  }\n  const parentPointer = arrayToJsonPointer(parent);\n  const fullyQualifiedPointer = `${basePath || '<specmap-base>'}#${pointer}`;\n\n  // dirty hack to strip `allof/[index]` from the path, in order to avoid cases\n  // where we get false negatives because:\n  // - we resolve a path, then\n  // - allOf plugin collapsed `allOf/[index]` out of the path, then\n  // - we try to work on a child $ref within that collapsed path.\n  //\n  // because of the path collapse, we lose track of it in our specmapRefs hash\n  // solution: always throw the allOf constructs out of paths we store\n  // TODO: solve this with a global register, or by writing more metadata in\n  // either allOf or refs plugin\n  const safeParentPointer = parentPointer.replace(/allOf\\/\\d+\\/?/g, '');\n\n  // Case 1: direct cycle, e.g. a.b.c.$ref: '/a.b'\n  // Detect by checking that the parent path doesn't start with pointer.\n  // This only applies if the pointer is internal, i.e. basePath === rootPath (could be null)\n  const rootDoc = specmap.contextTree.get([]).baseDoc;\n  if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {\n    // eslint-disable-line\n    return true;\n  }\n\n  // Case 2: indirect cycle\n  //  ex1: a.$ref: '/b'  &  b.c.$ref: '/b/c'\n  //  ex2: a.$ref: '/b/c'  &  b.c.$ref: '/b'\n  // Detect by retrieving all the $refs along the path of parent\n  // and checking if any starts with pointer or vice versa.\n  let currPath = '';\n  const hasIndirectCycle = parent.some(token => {\n    currPath = `${currPath}/${escapeJsonPointerToken(token)}`;\n    return refs[currPath] && refs[currPath].some(ref => pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref));\n  });\n  if (hasIndirectCycle) {\n    return true;\n  }\n\n  // No cycle, this ref will be resolved, so stores it now for future detection.\n  // No need to store if has cycle, as parent path is a dead-end and won't be checked again.\n\n  refs[safeParentPointer] = (refs[safeParentPointer] || []).concat(fullyQualifiedPointer);\n  return undefined;\n}\n\n/**\n * Checks if the value of this patch ends up pointing to an ancestor along the path.\n */\nfunction patchValueAlreadyInPath(root, patch) {\n  const ancestors = [root];\n  patch.path.reduce((parent, p) => {\n    ancestors.push(parent[p]);\n    return parent[p];\n  }, root);\n  return pointToAncestor(patch.value);\n  function pointToAncestor(obj) {\n    return lib.isObject(obj) && (ancestors.indexOf(obj) >= 0 || Object.keys(obj).some(k => pointToAncestor(obj[k])));\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}