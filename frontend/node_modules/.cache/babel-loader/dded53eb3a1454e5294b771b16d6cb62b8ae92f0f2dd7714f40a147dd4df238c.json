{"ast":null,"code":"import { ObjectElement } from 'minim';\nimport { isObjectElement, isArrayElement } from \"../predicates/index.mjs\";\nimport { cloneDeep, cloneShallow } from \"../clone/index.mjs\";\nimport toValue from \"../transformers/serializers/value/index.mjs\";\n/* eslint-disable @typescript-eslint/no-use-before-define */\nexport const emptyElement = element => {\n  const meta = element.meta.length > 0 ? cloneDeep(element.meta) : undefined;\n  const attributes = element.attributes.length > 0 ? cloneDeep(element.attributes) : undefined;\n\n  // @ts-ignore\n  return new element.constructor(undefined, meta, attributes);\n};\nconst cloneUnlessOtherwiseSpecified = (element, options) => options.clone && options.isMergeableElement(element) ? deepmerge(emptyElement(element), element, options) : element;\nconst getMergeFunction = (keyElement, options) => {\n  if (typeof options.customMerge !== 'function') {\n    return deepmerge;\n  }\n  const customMerge = options.customMerge(keyElement, options);\n  return typeof customMerge === 'function' ? customMerge : deepmerge;\n};\nconst getMetaMergeFunction = options => {\n  if (typeof options.customMetaMerge !== 'function') {\n    return targetMeta => cloneDeep(targetMeta);\n  }\n  return options.customMetaMerge;\n};\nconst getAttributesMergeFunction = options => {\n  if (typeof options.customAttributesMerge !== 'function') {\n    return targetAttributes => cloneDeep(targetAttributes);\n  }\n  return options.customAttributesMerge;\n};\nconst mergeArrayElement = (targetElement, sourceElement, options) => targetElement.concat(sourceElement)['fantasy-land/map'](item => cloneUnlessOtherwiseSpecified(item, options));\nconst mergeObjectElement = (targetElement, sourceElement, options) => {\n  const destination = isObjectElement(targetElement) ? emptyElement(targetElement) : emptyElement(sourceElement);\n  if (isObjectElement(targetElement)) {\n    targetElement.forEach((value, key, member) => {\n      const clonedMember = cloneShallow(member);\n      clonedMember.value = cloneUnlessOtherwiseSpecified(value, options);\n      destination.content.push(clonedMember);\n    });\n  }\n  sourceElement.forEach((value, key, member) => {\n    const keyValue = toValue(key);\n    let clonedMember;\n    if (isObjectElement(targetElement) && targetElement.hasKey(keyValue) && options.isMergeableElement(value)) {\n      const targetValue = targetElement.get(keyValue);\n      clonedMember = cloneShallow(member);\n      clonedMember.value = getMergeFunction(key, options)(targetValue, value);\n    } else {\n      clonedMember = cloneShallow(member);\n      clonedMember.value = cloneUnlessOtherwiseSpecified(value, options);\n    }\n    destination.remove(keyValue);\n    destination.content.push(clonedMember);\n  });\n  return destination;\n};\nexport const defaultOptions = {\n  clone: true,\n  isMergeableElement: element => isObjectElement(element) || isArrayElement(element),\n  arrayElementMerge: mergeArrayElement,\n  objectElementMerge: mergeObjectElement,\n  customMerge: undefined,\n  customMetaMerge: undefined,\n  customAttributesMerge: undefined\n};\nexport default function deepmerge(targetElement, sourceElement, options) {\n  var _mergedOptions$isMerg, _mergedOptions$arrayE, _mergedOptions$object;\n  const mergedOptions = {\n    ...defaultOptions,\n    ...options\n  };\n  mergedOptions.isMergeableElement = (_mergedOptions$isMerg = mergedOptions.isMergeableElement) !== null && _mergedOptions$isMerg !== void 0 ? _mergedOptions$isMerg : defaultOptions.isMergeableElement;\n  mergedOptions.arrayElementMerge = (_mergedOptions$arrayE = mergedOptions.arrayElementMerge) !== null && _mergedOptions$arrayE !== void 0 ? _mergedOptions$arrayE : defaultOptions.arrayElementMerge;\n  mergedOptions.objectElementMerge = (_mergedOptions$object = mergedOptions.objectElementMerge) !== null && _mergedOptions$object !== void 0 ? _mergedOptions$object : defaultOptions.objectElementMerge;\n  const sourceIsArrayElement = isArrayElement(sourceElement);\n  const targetIsArrayElement = isArrayElement(targetElement);\n  const sourceAndTargetTypesMatch = sourceIsArrayElement === targetIsArrayElement;\n  if (!sourceAndTargetTypesMatch) {\n    return cloneUnlessOtherwiseSpecified(sourceElement, mergedOptions);\n  }\n\n  // merging two elements\n  const mergedElement = sourceIsArrayElement && typeof mergedOptions.arrayElementMerge === 'function' ? mergedOptions.arrayElementMerge(targetElement, sourceElement, mergedOptions) : mergedOptions.objectElementMerge(targetElement, sourceElement, mergedOptions);\n\n  // merging meta & attributes\n  mergedElement.meta = getMetaMergeFunction(mergedOptions)(targetElement.meta, sourceElement.meta);\n  mergedElement.attributes = getAttributesMergeFunction(mergedOptions)(targetElement.attributes, sourceElement.attributes);\n  return mergedElement;\n}\ndeepmerge.all = (list, options) => {\n  if (!Array.isArray(list)) {\n    throw new TypeError('First argument of deepmerge should be an array.');\n  }\n  if (list.length === 0) {\n    return new ObjectElement();\n  }\n  return list.reduce((target, source) => {\n    return deepmerge(target, source, options);\n  }, emptyElement(list[0]));\n};\n/* eslint-enable @typescript-eslint/no-use-before-define */","map":{"version":3,"names":["ObjectElement","isObjectElement","isArrayElement","cloneDeep","cloneShallow","toValue","emptyElement","element","meta","length","undefined","attributes","constructor","cloneUnlessOtherwiseSpecified","options","clone","isMergeableElement","deepmerge","getMergeFunction","keyElement","customMerge","getMetaMergeFunction","customMetaMerge","targetMeta","getAttributesMergeFunction","customAttributesMerge","targetAttributes","mergeArrayElement","targetElement","sourceElement","concat","item","mergeObjectElement","destination","forEach","value","key","member","clonedMember","content","push","keyValue","hasKey","targetValue","get","remove","defaultOptions","arrayElementMerge","objectElementMerge","_mergedOptions$isMerg","_mergedOptions$arrayE","_mergedOptions$object","mergedOptions","sourceIsArrayElement","targetIsArrayElement","sourceAndTargetTypesMatch","mergedElement","all","list","Array","isArray","TypeError","reduce","target","source"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-core/es/merge/deepmerge.mjs"],"sourcesContent":["import { ObjectElement } from 'minim';\nimport { isObjectElement, isArrayElement } from \"../predicates/index.mjs\";\nimport { cloneDeep, cloneShallow } from \"../clone/index.mjs\";\nimport toValue from \"../transformers/serializers/value/index.mjs\";\n/* eslint-disable @typescript-eslint/no-use-before-define */\nexport const emptyElement = element => {\n  const meta = element.meta.length > 0 ? cloneDeep(element.meta) : undefined;\n  const attributes = element.attributes.length > 0 ? cloneDeep(element.attributes) : undefined;\n\n  // @ts-ignore\n  return new element.constructor(undefined, meta, attributes);\n};\nconst cloneUnlessOtherwiseSpecified = (element, options) => options.clone && options.isMergeableElement(element) ? deepmerge(emptyElement(element), element, options) : element;\nconst getMergeFunction = (keyElement, options) => {\n  if (typeof options.customMerge !== 'function') {\n    return deepmerge;\n  }\n  const customMerge = options.customMerge(keyElement, options);\n  return typeof customMerge === 'function' ? customMerge : deepmerge;\n};\nconst getMetaMergeFunction = options => {\n  if (typeof options.customMetaMerge !== 'function') {\n    return targetMeta => cloneDeep(targetMeta);\n  }\n  return options.customMetaMerge;\n};\nconst getAttributesMergeFunction = options => {\n  if (typeof options.customAttributesMerge !== 'function') {\n    return targetAttributes => cloneDeep(targetAttributes);\n  }\n  return options.customAttributesMerge;\n};\nconst mergeArrayElement = (targetElement, sourceElement, options) => targetElement.concat(sourceElement)['fantasy-land/map'](item => cloneUnlessOtherwiseSpecified(item, options));\nconst mergeObjectElement = (targetElement, sourceElement, options) => {\n  const destination = isObjectElement(targetElement) ? emptyElement(targetElement) : emptyElement(sourceElement);\n  if (isObjectElement(targetElement)) {\n    targetElement.forEach((value, key, member) => {\n      const clonedMember = cloneShallow(member);\n      clonedMember.value = cloneUnlessOtherwiseSpecified(value, options);\n      destination.content.push(clonedMember);\n    });\n  }\n  sourceElement.forEach((value, key, member) => {\n    const keyValue = toValue(key);\n    let clonedMember;\n    if (isObjectElement(targetElement) && targetElement.hasKey(keyValue) && options.isMergeableElement(value)) {\n      const targetValue = targetElement.get(keyValue);\n      clonedMember = cloneShallow(member);\n      clonedMember.value = getMergeFunction(key, options)(targetValue, value);\n    } else {\n      clonedMember = cloneShallow(member);\n      clonedMember.value = cloneUnlessOtherwiseSpecified(value, options);\n    }\n    destination.remove(keyValue);\n    destination.content.push(clonedMember);\n  });\n  return destination;\n};\nexport const defaultOptions = {\n  clone: true,\n  isMergeableElement: element => isObjectElement(element) || isArrayElement(element),\n  arrayElementMerge: mergeArrayElement,\n  objectElementMerge: mergeObjectElement,\n  customMerge: undefined,\n  customMetaMerge: undefined,\n  customAttributesMerge: undefined\n};\nexport default function deepmerge(targetElement, sourceElement, options) {\n  var _mergedOptions$isMerg, _mergedOptions$arrayE, _mergedOptions$object;\n  const mergedOptions = {\n    ...defaultOptions,\n    ...options\n  };\n  mergedOptions.isMergeableElement = (_mergedOptions$isMerg = mergedOptions.isMergeableElement) !== null && _mergedOptions$isMerg !== void 0 ? _mergedOptions$isMerg : defaultOptions.isMergeableElement;\n  mergedOptions.arrayElementMerge = (_mergedOptions$arrayE = mergedOptions.arrayElementMerge) !== null && _mergedOptions$arrayE !== void 0 ? _mergedOptions$arrayE : defaultOptions.arrayElementMerge;\n  mergedOptions.objectElementMerge = (_mergedOptions$object = mergedOptions.objectElementMerge) !== null && _mergedOptions$object !== void 0 ? _mergedOptions$object : defaultOptions.objectElementMerge;\n  const sourceIsArrayElement = isArrayElement(sourceElement);\n  const targetIsArrayElement = isArrayElement(targetElement);\n  const sourceAndTargetTypesMatch = sourceIsArrayElement === targetIsArrayElement;\n  if (!sourceAndTargetTypesMatch) {\n    return cloneUnlessOtherwiseSpecified(sourceElement, mergedOptions);\n  }\n\n  // merging two elements\n  const mergedElement = sourceIsArrayElement && typeof mergedOptions.arrayElementMerge === 'function' ? mergedOptions.arrayElementMerge(targetElement, sourceElement, mergedOptions) : mergedOptions.objectElementMerge(targetElement, sourceElement, mergedOptions);\n\n  // merging meta & attributes\n  mergedElement.meta = getMetaMergeFunction(mergedOptions)(targetElement.meta, sourceElement.meta);\n  mergedElement.attributes = getAttributesMergeFunction(mergedOptions)(targetElement.attributes, sourceElement.attributes);\n  return mergedElement;\n}\ndeepmerge.all = (list, options) => {\n  if (!Array.isArray(list)) {\n    throw new TypeError('First argument of deepmerge should be an array.');\n  }\n  if (list.length === 0) {\n    return new ObjectElement();\n  }\n  return list.reduce((target, source) => {\n    return deepmerge(target, source, options);\n  }, emptyElement(list[0]));\n};\n/* eslint-enable @typescript-eslint/no-use-before-define */"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}