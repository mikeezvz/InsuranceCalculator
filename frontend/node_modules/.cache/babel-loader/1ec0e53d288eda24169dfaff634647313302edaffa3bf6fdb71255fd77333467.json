{"ast":null,"code":"export default class ContextTree {\n  constructor(value) {\n    this.root = createNode(value || {});\n  }\n  set(path, value) {\n    const parent = this.getParent(path, true);\n    if (!parent) {\n      updateNode(this.root, value, null);\n      return;\n    }\n    const key = path[path.length - 1];\n    const {\n      children\n    } = parent;\n    if (children[key]) {\n      updateNode(children[key], value, parent);\n      return;\n    }\n    children[key] = createNode(value, parent);\n  }\n\n  // Get the \"best\" node (node or nearest parent) and return its value.\n  get(path) {\n    path = path || [];\n    if (path.length < 1) {\n      return this.root.value;\n    }\n    let branch = this.root;\n    let child;\n    let token;\n    for (let i = 0; i < path.length; i += 1) {\n      token = path[i];\n      child = branch.children;\n      if (!child[token]) {\n        break;\n      }\n      branch = child[token];\n    }\n    return branch && branch.protoValue;\n  }\n  getParent(path, ensureExists) {\n    if (!path || path.length < 1) {\n      return null;\n    }\n    if (path.length < 2) {\n      return this.root;\n    }\n    return path.slice(0, -1).reduce((branch, token) => {\n      if (!branch) {\n        return branch;\n      }\n      const {\n        children\n      } = branch;\n      if (!children[token] && ensureExists) {\n        children[token] = createNode(null, branch);\n      }\n      return children[token];\n    }, this.root);\n  }\n}\n\n// =========================\n// Utilities\n// =========================\n\nfunction createNode(value, parent) {\n  return updateNode({\n    children: {}\n  }, value, parent);\n}\nfunction updateNode(node, value, parent) {\n  node.value = value || {};\n  node.protoValue = parent ? {\n    ...parent.protoValue,\n    ...node.value\n  } : node.value;\n  Object.keys(node.children).forEach(prop => {\n    const child = node.children[prop];\n    node.children[prop] = updateNode(child, child.value, node);\n  });\n  return node;\n}","map":{"version":3,"names":["ContextTree","constructor","value","root","createNode","set","path","parent","getParent","updateNode","key","length","children","get","branch","child","token","i","protoValue","ensureExists","slice","reduce","node","Object","keys","forEach","prop"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/resolver/specmap/lib/context-tree.js"],"sourcesContent":["export default class ContextTree {\n  constructor(value) {\n    this.root = createNode(value || {});\n  }\n  set(path, value) {\n    const parent = this.getParent(path, true);\n    if (!parent) {\n      updateNode(this.root, value, null);\n      return;\n    }\n    const key = path[path.length - 1];\n    const {\n      children\n    } = parent;\n    if (children[key]) {\n      updateNode(children[key], value, parent);\n      return;\n    }\n    children[key] = createNode(value, parent);\n  }\n\n  // Get the \"best\" node (node or nearest parent) and return its value.\n  get(path) {\n    path = path || [];\n    if (path.length < 1) {\n      return this.root.value;\n    }\n    let branch = this.root;\n    let child;\n    let token;\n    for (let i = 0; i < path.length; i += 1) {\n      token = path[i];\n      child = branch.children;\n      if (!child[token]) {\n        break;\n      }\n      branch = child[token];\n    }\n    return branch && branch.protoValue;\n  }\n  getParent(path, ensureExists) {\n    if (!path || path.length < 1) {\n      return null;\n    }\n    if (path.length < 2) {\n      return this.root;\n    }\n    return path.slice(0, -1).reduce((branch, token) => {\n      if (!branch) {\n        return branch;\n      }\n      const {\n        children\n      } = branch;\n      if (!children[token] && ensureExists) {\n        children[token] = createNode(null, branch);\n      }\n      return children[token];\n    }, this.root);\n  }\n}\n\n// =========================\n// Utilities\n// =========================\n\nfunction createNode(value, parent) {\n  return updateNode({\n    children: {}\n  }, value, parent);\n}\nfunction updateNode(node, value, parent) {\n  node.value = value || {};\n  node.protoValue = parent ? {\n    ...parent.protoValue,\n    ...node.value\n  } : node.value;\n  Object.keys(node.children).forEach(prop => {\n    const child = node.children[prop];\n    node.children[prop] = updateNode(child, child.value, node);\n  });\n  return node;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}