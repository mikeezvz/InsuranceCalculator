{"ast":null,"code":"// The subtree resolver is a higher-level interface that allows you to\n// get the same result that you would from `Swagger.resolve`, but focuses on\n// a subtree of your object.\n//\n// It makes several assumptions that allow you to think less about what resolve,\n// specmap, and normalizeSwagger are doing: if this is not suitable for you,\n// you can emulate `resolveSubtree`'s behavior by talking to the traditional\n// resolver directly.\n//\n// By providing a top-level `obj` and a `path` to resolve within, the subtree\n// at `path` will be resolved and normalized in the context of your top-level\n// `obj`. You'll get the resolved subtree you're interest in as a return value\n// (or, you can use `returnEntireTree` to get everything back).\n//\n// This is useful for cases where resolving your entire object is unnecessary\n// and/or non-performant; we use this interface for lazily resolving operations\n// and models in Swagger-UI, which allows us to handle larger definitions.\n//\n// It's likely that Swagger-Client will rely entirely on lazy resolving in\n// future versions.\n//\n// TODO: move the remarks above into project documentation\nimport resolve from '../resolver/index.js';\nimport genericResolverStrategy from '../resolver/strategies/generic/index.js';\nimport openApi2ResolverStrategy from '../resolver/strategies/openapi-2/index.js';\nimport openApi30ResolverStrategy from '../resolver/strategies/openapi-3-0/index.js';\nconst resolveSubtree = async (obj, path, options = {}) => {\n  const {\n    returnEntireTree,\n    baseDoc,\n    requestInterceptor,\n    responseInterceptor,\n    parameterMacro,\n    modelPropertyMacro,\n    useCircularStructures,\n    strategies\n  } = options;\n  const resolveOptions = {\n    spec: obj,\n    pathDiscriminator: path,\n    baseDoc,\n    requestInterceptor,\n    responseInterceptor,\n    parameterMacro,\n    modelPropertyMacro,\n    useCircularStructures,\n    strategies\n  };\n  const strategy = strategies.find(strg => strg.match(resolveOptions));\n  const normalized = strategy.normalize(resolveOptions);\n  const result = await resolve({\n    ...resolveOptions,\n    spec: normalized,\n    allowMetaPatches: true,\n    skipNormalization: true\n  });\n  if (!returnEntireTree && Array.isArray(path) && path.length) {\n    result.spec = path.reduce((acc, pathSegment) => acc === null || acc === void 0 ? void 0 : acc[pathSegment], result.spec) || null;\n  }\n  return result;\n};\nexport const makeResolveSubtree = defaultOptions => async (obj, path, options = {}) => {\n  const mergedOptions = {\n    ...defaultOptions,\n    ...options\n  };\n  return resolveSubtree(obj, path, mergedOptions);\n};\nexport default makeResolveSubtree({\n  strategies: [openApi30ResolverStrategy, openApi2ResolverStrategy, genericResolverStrategy]\n});","map":{"version":3,"names":["resolve","genericResolverStrategy","openApi2ResolverStrategy","openApi30ResolverStrategy","resolveSubtree","obj","path","options","returnEntireTree","baseDoc","requestInterceptor","responseInterceptor","parameterMacro","modelPropertyMacro","useCircularStructures","strategies","resolveOptions","spec","pathDiscriminator","strategy","find","strg","match","normalized","normalize","result","allowMetaPatches","skipNormalization","Array","isArray","length","reduce","acc","pathSegment","makeResolveSubtree","defaultOptions","mergedOptions"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/subtree-resolver/index.js"],"sourcesContent":["// The subtree resolver is a higher-level interface that allows you to\n// get the same result that you would from `Swagger.resolve`, but focuses on\n// a subtree of your object.\n//\n// It makes several assumptions that allow you to think less about what resolve,\n// specmap, and normalizeSwagger are doing: if this is not suitable for you,\n// you can emulate `resolveSubtree`'s behavior by talking to the traditional\n// resolver directly.\n//\n// By providing a top-level `obj` and a `path` to resolve within, the subtree\n// at `path` will be resolved and normalized in the context of your top-level\n// `obj`. You'll get the resolved subtree you're interest in as a return value\n// (or, you can use `returnEntireTree` to get everything back).\n//\n// This is useful for cases where resolving your entire object is unnecessary\n// and/or non-performant; we use this interface for lazily resolving operations\n// and models in Swagger-UI, which allows us to handle larger definitions.\n//\n// It's likely that Swagger-Client will rely entirely on lazy resolving in\n// future versions.\n//\n// TODO: move the remarks above into project documentation\nimport resolve from '../resolver/index.js';\nimport genericResolverStrategy from '../resolver/strategies/generic/index.js';\nimport openApi2ResolverStrategy from '../resolver/strategies/openapi-2/index.js';\nimport openApi30ResolverStrategy from '../resolver/strategies/openapi-3-0/index.js';\nconst resolveSubtree = async (obj, path, options = {}) => {\n  const {\n    returnEntireTree,\n    baseDoc,\n    requestInterceptor,\n    responseInterceptor,\n    parameterMacro,\n    modelPropertyMacro,\n    useCircularStructures,\n    strategies\n  } = options;\n  const resolveOptions = {\n    spec: obj,\n    pathDiscriminator: path,\n    baseDoc,\n    requestInterceptor,\n    responseInterceptor,\n    parameterMacro,\n    modelPropertyMacro,\n    useCircularStructures,\n    strategies\n  };\n  const strategy = strategies.find(strg => strg.match(resolveOptions));\n  const normalized = strategy.normalize(resolveOptions);\n  const result = await resolve({\n    ...resolveOptions,\n    spec: normalized,\n    allowMetaPatches: true,\n    skipNormalization: true\n  });\n  if (!returnEntireTree && Array.isArray(path) && path.length) {\n    result.spec = path.reduce((acc, pathSegment) => acc === null || acc === void 0 ? void 0 : acc[pathSegment], result.spec) || null;\n  }\n  return result;\n};\nexport const makeResolveSubtree = defaultOptions => async (obj, path, options = {}) => {\n  const mergedOptions = {\n    ...defaultOptions,\n    ...options\n  };\n  return resolveSubtree(obj, path, mergedOptions);\n};\nexport default makeResolveSubtree({\n  strategies: [openApi30ResolverStrategy, openApi2ResolverStrategy, genericResolverStrategy]\n});"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,OAAO,MAAM,sBAAsB;AAC1C,OAAOC,uBAAuB,MAAM,yCAAyC;AAC7E,OAAOC,wBAAwB,MAAM,2CAA2C;AAChF,OAAOC,yBAAyB,MAAM,6CAA6C;AACnF,MAAMC,cAAc,GAAG,MAAAA,CAAOC,GAAG,EAAEC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAK;EACxD,MAAM;IACJC,gBAAgB;IAChBC,OAAO;IACPC,kBAAkB;IAClBC,mBAAmB;IACnBC,cAAc;IACdC,kBAAkB;IAClBC,qBAAqB;IACrBC;EACF,CAAC,GAAGR,OAAO;EACX,MAAMS,cAAc,GAAG;IACrBC,IAAI,EAAEZ,GAAG;IACTa,iBAAiB,EAAEZ,IAAI;IACvBG,OAAO;IACPC,kBAAkB;IAClBC,mBAAmB;IACnBC,cAAc;IACdC,kBAAkB;IAClBC,qBAAqB;IACrBC;EACF,CAAC;EACD,MAAMI,QAAQ,GAAGJ,UAAU,CAACK,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACC,KAAK,CAACN,cAAc,CAAC,CAAC;EACpE,MAAMO,UAAU,GAAGJ,QAAQ,CAACK,SAAS,CAACR,cAAc,CAAC;EACrD,MAAMS,MAAM,GAAG,MAAMzB,OAAO,CAAC;IAC3B,GAAGgB,cAAc;IACjBC,IAAI,EAAEM,UAAU;IAChBG,gBAAgB,EAAE,IAAI;IACtBC,iBAAiB,EAAE;EACrB,CAAC,CAAC;EACF,IAAI,CAACnB,gBAAgB,IAAIoB,KAAK,CAACC,OAAO,CAACvB,IAAI,CAAC,IAAIA,IAAI,CAACwB,MAAM,EAAE;IAC3DL,MAAM,CAACR,IAAI,GAAGX,IAAI,CAACyB,MAAM,CAAC,CAACC,GAAG,EAAEC,WAAW,KAAKD,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACC,WAAW,CAAC,EAAER,MAAM,CAACR,IAAI,CAAC,IAAI,IAAI;EAClI;EACA,OAAOQ,MAAM;AACf,CAAC;AACD,OAAO,MAAMS,kBAAkB,GAAGC,cAAc,IAAI,OAAO9B,GAAG,EAAEC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAK;EACrF,MAAM6B,aAAa,GAAG;IACpB,GAAGD,cAAc;IACjB,GAAG5B;EACL,CAAC;EACD,OAAOH,cAAc,CAACC,GAAG,EAAEC,IAAI,EAAE8B,aAAa,CAAC;AACjD,CAAC;AACD,eAAeF,kBAAkB,CAAC;EAChCnB,UAAU,EAAE,CAACZ,yBAAyB,EAAED,wBAAwB,EAAED,uBAAuB;AAC3F,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}