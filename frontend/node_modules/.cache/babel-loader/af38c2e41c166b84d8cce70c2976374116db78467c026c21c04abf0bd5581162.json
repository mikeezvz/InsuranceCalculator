{"ast":null,"code":"import mapSpec, { plugins } from '../../specmap/index.js';\nimport normalize from './normalize.js';\nimport { makeFetchJSON } from '../../utils/index.js';\nimport * as optionsUtil from '../../utils/options.js';\nexport default async function resolveGenericStrategy(options) {\n  const {\n    spec,\n    mode,\n    allowMetaPatches = true,\n    pathDiscriminator,\n    modelPropertyMacro,\n    parameterMacro,\n    requestInterceptor,\n    responseInterceptor,\n    skipNormalization,\n    useCircularStructures\n  } = options;\n  const retrievalURI = optionsUtil.retrievalURI(options);\n  const httpClient = optionsUtil.httpClient(options);\n  return doResolve(spec);\n  function doResolve(_spec) {\n    if (retrievalURI) {\n      plugins.refs.docCache[retrievalURI] = _spec;\n    }\n\n    // Build a json-fetcher ( ie: give it a URL and get json out )\n    plugins.refs.fetchJSON = makeFetchJSON(httpClient, {\n      requestInterceptor,\n      responseInterceptor\n    });\n    const plugs = [plugins.refs];\n    if (typeof parameterMacro === 'function') {\n      plugs.push(plugins.parameters);\n    }\n    if (typeof modelPropertyMacro === 'function') {\n      plugs.push(plugins.properties);\n    }\n    if (mode !== 'strict') {\n      plugs.push(plugins.allOf);\n    }\n\n    // mapSpec is where the hard work happens\n    return mapSpec({\n      spec: _spec,\n      context: {\n        baseDoc: retrievalURI\n      },\n      plugins: plugs,\n      allowMetaPatches,\n      // allows adding .meta patches, which include adding `$$ref`s to the spec\n      pathDiscriminator,\n      // for lazy resolution\n      parameterMacro,\n      modelPropertyMacro,\n      useCircularStructures\n      // eslint-disable-next-line camelcase\n    }).then(skipNormalization ? async a => a : normalize);\n  }\n}","map":{"version":3,"names":["mapSpec","plugins","normalize","makeFetchJSON","optionsUtil","resolveGenericStrategy","options","spec","mode","allowMetaPatches","pathDiscriminator","modelPropertyMacro","parameterMacro","requestInterceptor","responseInterceptor","skipNormalization","useCircularStructures","retrievalURI","httpClient","doResolve","_spec","refs","docCache","fetchJSON","plugs","push","parameters","properties","allOf","context","baseDoc","then","a"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/resolver/strategies/generic/resolve.js"],"sourcesContent":["import mapSpec, { plugins } from '../../specmap/index.js';\nimport normalize from './normalize.js';\nimport { makeFetchJSON } from '../../utils/index.js';\nimport * as optionsUtil from '../../utils/options.js';\nexport default async function resolveGenericStrategy(options) {\n  const {\n    spec,\n    mode,\n    allowMetaPatches = true,\n    pathDiscriminator,\n    modelPropertyMacro,\n    parameterMacro,\n    requestInterceptor,\n    responseInterceptor,\n    skipNormalization,\n    useCircularStructures\n  } = options;\n  const retrievalURI = optionsUtil.retrievalURI(options);\n  const httpClient = optionsUtil.httpClient(options);\n  return doResolve(spec);\n  function doResolve(_spec) {\n    if (retrievalURI) {\n      plugins.refs.docCache[retrievalURI] = _spec;\n    }\n\n    // Build a json-fetcher ( ie: give it a URL and get json out )\n    plugins.refs.fetchJSON = makeFetchJSON(httpClient, {\n      requestInterceptor,\n      responseInterceptor\n    });\n    const plugs = [plugins.refs];\n    if (typeof parameterMacro === 'function') {\n      plugs.push(plugins.parameters);\n    }\n    if (typeof modelPropertyMacro === 'function') {\n      plugs.push(plugins.properties);\n    }\n    if (mode !== 'strict') {\n      plugs.push(plugins.allOf);\n    }\n\n    // mapSpec is where the hard work happens\n    return mapSpec({\n      spec: _spec,\n      context: {\n        baseDoc: retrievalURI\n      },\n      plugins: plugs,\n      allowMetaPatches,\n      // allows adding .meta patches, which include adding `$$ref`s to the spec\n      pathDiscriminator,\n      // for lazy resolution\n      parameterMacro,\n      modelPropertyMacro,\n      useCircularStructures\n      // eslint-disable-next-line camelcase\n    }).then(skipNormalization ? async a => a : normalize);\n  }\n}"],"mappings":"AAAA,OAAOA,OAAO,IAAIC,OAAO,QAAQ,wBAAwB;AACzD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,SAASC,aAAa,QAAQ,sBAAsB;AACpD,OAAO,KAAKC,WAAW,MAAM,wBAAwB;AACrD,eAAe,eAAeC,sBAAsBA,CAACC,OAAO,EAAE;EAC5D,MAAM;IACJC,IAAI;IACJC,IAAI;IACJC,gBAAgB,GAAG,IAAI;IACvBC,iBAAiB;IACjBC,kBAAkB;IAClBC,cAAc;IACdC,kBAAkB;IAClBC,mBAAmB;IACnBC,iBAAiB;IACjBC;EACF,CAAC,GAAGV,OAAO;EACX,MAAMW,YAAY,GAAGb,WAAW,CAACa,YAAY,CAACX,OAAO,CAAC;EACtD,MAAMY,UAAU,GAAGd,WAAW,CAACc,UAAU,CAACZ,OAAO,CAAC;EAClD,OAAOa,SAAS,CAACZ,IAAI,CAAC;EACtB,SAASY,SAASA,CAACC,KAAK,EAAE;IACxB,IAAIH,YAAY,EAAE;MAChBhB,OAAO,CAACoB,IAAI,CAACC,QAAQ,CAACL,YAAY,CAAC,GAAGG,KAAK;IAC7C;;IAEA;IACAnB,OAAO,CAACoB,IAAI,CAACE,SAAS,GAAGpB,aAAa,CAACe,UAAU,EAAE;MACjDL,kBAAkB;MAClBC;IACF,CAAC,CAAC;IACF,MAAMU,KAAK,GAAG,CAACvB,OAAO,CAACoB,IAAI,CAAC;IAC5B,IAAI,OAAOT,cAAc,KAAK,UAAU,EAAE;MACxCY,KAAK,CAACC,IAAI,CAACxB,OAAO,CAACyB,UAAU,CAAC;IAChC;IACA,IAAI,OAAOf,kBAAkB,KAAK,UAAU,EAAE;MAC5Ca,KAAK,CAACC,IAAI,CAACxB,OAAO,CAAC0B,UAAU,CAAC;IAChC;IACA,IAAInB,IAAI,KAAK,QAAQ,EAAE;MACrBgB,KAAK,CAACC,IAAI,CAACxB,OAAO,CAAC2B,KAAK,CAAC;IAC3B;;IAEA;IACA,OAAO5B,OAAO,CAAC;MACbO,IAAI,EAAEa,KAAK;MACXS,OAAO,EAAE;QACPC,OAAO,EAAEb;MACX,CAAC;MACDhB,OAAO,EAAEuB,KAAK;MACdf,gBAAgB;MAChB;MACAC,iBAAiB;MACjB;MACAE,cAAc;MACdD,kBAAkB;MAClBK;MACA;IACF,CAAC,CAAC,CAACe,IAAI,CAAChB,iBAAiB,GAAG,MAAMiB,CAAC,IAAIA,CAAC,GAAG9B,SAAS,CAAC;EACvD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}