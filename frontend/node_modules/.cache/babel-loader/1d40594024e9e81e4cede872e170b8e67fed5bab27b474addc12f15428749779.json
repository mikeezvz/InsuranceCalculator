{"ast":null,"code":"const isEqual = require('lodash/isEqual');\nconst KeyValuePair = require('../KeyValuePair');\nconst ArraySlice = require('../ArraySlice.js');\n\n/**\n * @class\n *\n * @param content\n * @param meta\n * @param attributes\n *\n * @property {string} element\n */\nclass Element {\n  constructor(content, meta, attributes) {\n    // Lazy load this.meta and this.attributes because it's a Minim element\n    // Otherwise, we get into circuluar calls\n    if (meta) {\n      this.meta = meta;\n    }\n    if (attributes) {\n      this.attributes = attributes;\n    }\n    this.content = content;\n  }\n\n  /**\n   * Freezes the element to prevent any mutation.\n   * A frozen element will add `parent` property to every child element\n   * to allow traversing up the element tree.\n   */\n  freeze() {\n    if (Object.isFrozen(this)) {\n      return;\n    }\n    if (this._meta) {\n      this.meta.parent = this;\n      this.meta.freeze();\n    }\n    if (this._attributes) {\n      this.attributes.parent = this;\n      this.attributes.freeze();\n    }\n    this.children.forEach(element => {\n      element.parent = this;\n      element.freeze();\n    }, this);\n    if (this.content && Array.isArray(this.content)) {\n      Object.freeze(this.content);\n    }\n    Object.freeze(this);\n  }\n  primitive() {}\n\n  /**\n   * Creates a deep clone of the instance\n   */\n  clone() {\n    const copy = new this.constructor();\n    copy.element = this.element;\n    if (this.meta.length) {\n      copy._meta = this.meta.clone();\n    }\n    if (this.attributes.length) {\n      copy._attributes = this.attributes.clone();\n    }\n    if (this.content) {\n      if (this.content.clone) {\n        copy.content = this.content.clone();\n      } else if (Array.isArray(this.content)) {\n        copy.content = this.content.map(element => element.clone());\n      } else {\n        copy.content = this.content;\n      }\n    } else {\n      copy.content = this.content;\n    }\n    return copy;\n  }\n\n  /**\n   */\n  toValue() {\n    if (this.content instanceof Element) {\n      return this.content.toValue();\n    }\n    if (this.content instanceof KeyValuePair) {\n      return {\n        key: this.content.key.toValue(),\n        value: this.content.value ? this.content.value.toValue() : undefined\n      };\n    }\n    if (this.content && this.content.map) {\n      return this.content.map(element => element.toValue(), this);\n    }\n    return this.content;\n  }\n\n  /**\n   * Creates a reference pointing at the Element\n   * @returns {RefElement}\n   * @memberof Element.prototype\n   */\n  toRef(path) {\n    if (this.id.toValue() === '') {\n      throw Error('Cannot create reference to an element that does not contain an ID');\n    }\n    const ref = new this.RefElement(this.id.toValue());\n    if (path) {\n      ref.path = path;\n    }\n    return ref;\n  }\n\n  /**\n   * Finds the given elements in the element tree.\n   * When providing multiple element names, you must first freeze the element.\n   *\n   * @param names {...elementNames}\n   * @returns {ArraySlice}\n   */\n  findRecursive(...elementNames) {\n    if (arguments.length > 1 && !this.isFrozen) {\n      throw new Error('Cannot find recursive with multiple element names without first freezing the element. Call `element.freeze()`');\n    }\n    const elementName = elementNames.pop();\n    let elements = new ArraySlice();\n    const append = (array, element) => {\n      array.push(element);\n      return array;\n    };\n\n    // Checks the given element and appends element/sub-elements\n    // that match element name to given array\n    const checkElement = (array, element) => {\n      if (element.element === elementName) {\n        array.push(element);\n      }\n      const items = element.findRecursive(elementName);\n      if (items) {\n        items.reduce(append, array);\n      }\n      if (element.content instanceof KeyValuePair) {\n        if (element.content.key) {\n          checkElement(array, element.content.key);\n        }\n        if (element.content.value) {\n          checkElement(array, element.content.value);\n        }\n      }\n      return array;\n    };\n    if (this.content) {\n      // Direct Element\n      if (this.content.element) {\n        checkElement(elements, this.content);\n      }\n\n      // Element Array\n      if (Array.isArray(this.content)) {\n        this.content.reduce(checkElement, elements);\n      }\n    }\n    if (!elementNames.isEmpty) {\n      elements = elements.filter(element => {\n        let parentElements = element.parents.map(e => e.element);\n\n        // eslint-disable-next-line no-restricted-syntax\n        for (const namesIndex in elementNames) {\n          const name = elementNames[namesIndex];\n          const index = parentElements.indexOf(name);\n          if (index !== -1) {\n            parentElements = parentElements.splice(0, index);\n          } else {\n            return false;\n          }\n        }\n        return true;\n      });\n    }\n    return elements;\n  }\n  set(content) {\n    this.content = content;\n    return this;\n  }\n  equals(value) {\n    return isEqual(this.toValue(), value);\n  }\n  getMetaProperty(name, value) {\n    if (!this.meta.hasKey(name)) {\n      if (this.isFrozen) {\n        const element = this.refract(value);\n        element.freeze();\n        return element;\n      }\n      this.meta.set(name, value);\n    }\n    return this.meta.get(name);\n  }\n  setMetaProperty(name, value) {\n    this.meta.set(name, value);\n  }\n\n  /**\n   * @type String\n   */\n  get element() {\n    // Returns 'element' so we don't have undefined as element\n    return this._storedElement || 'element';\n  }\n  set element(element) {\n    this._storedElement = element;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value) {\n    if (value instanceof Element) {\n      this._content = value;\n    } else if (value instanceof ArraySlice) {\n      this.content = value.elements;\n    } else if (typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean' || value === 'null' || value == undefined) {\n      // Primitive Values\n      this._content = value;\n    } else if (value instanceof KeyValuePair) {\n      this._content = value;\n    } else if (Array.isArray(value)) {\n      this._content = value.map(this.refract);\n    } else if (typeof value === 'object') {\n      this._content = Object.keys(value).map(key => new this.MemberElement(key, value[key]));\n    } else {\n      throw new Error('Cannot set content to given value');\n    }\n  }\n\n  /**\n   * @type ObjectElement\n   */\n  get meta() {\n    if (!this._meta) {\n      if (this.isFrozen) {\n        const meta = new this.ObjectElement();\n        meta.freeze();\n        return meta;\n      }\n      this._meta = new this.ObjectElement();\n    }\n    return this._meta;\n  }\n  set meta(value) {\n    if (value instanceof this.ObjectElement) {\n      this._meta = value;\n    } else {\n      this.meta.set(value || {});\n    }\n  }\n\n  /**\n   * The attributes property defines attributes about the given instance\n   * of the element, as specified by the element property.\n   *\n   * @type ObjectElement\n   */\n  get attributes() {\n    if (!this._attributes) {\n      if (this.isFrozen) {\n        const meta = new this.ObjectElement();\n        meta.freeze();\n        return meta;\n      }\n      this._attributes = new this.ObjectElement();\n    }\n    return this._attributes;\n  }\n  set attributes(value) {\n    if (value instanceof this.ObjectElement) {\n      this._attributes = value;\n    } else {\n      this.attributes.set(value || {});\n    }\n  }\n\n  /**\n   * Unique Identifier, MUST be unique throughout an entire element tree.\n   * @type StringElement\n   */\n  get id() {\n    return this.getMetaProperty('id', '');\n  }\n  set id(element) {\n    this.setMetaProperty('id', element);\n  }\n\n  /**\n   * @type ArrayElement\n   */\n  get classes() {\n    return this.getMetaProperty('classes', []);\n  }\n  set classes(element) {\n    this.setMetaProperty('classes', element);\n  }\n\n  /**\n   * Human-readable title of element\n   * @type StringElement\n   */\n  get title() {\n    return this.getMetaProperty('title', '');\n  }\n  set title(element) {\n    this.setMetaProperty('title', element);\n  }\n\n  /**\n   * Human-readable description of element\n   * @type StringElement\n   */\n  get description() {\n    return this.getMetaProperty('description', '');\n  }\n  set description(element) {\n    this.setMetaProperty('description', element);\n  }\n\n  /**\n   * @type ArrayElement\n   */\n  get links() {\n    return this.getMetaProperty('links', []);\n  }\n  set links(element) {\n    this.setMetaProperty('links', element);\n  }\n\n  /**\n   * Returns whether the element is frozen.\n   * @type boolean\n   * @see freeze\n   */\n  get isFrozen() {\n    return Object.isFrozen(this);\n  }\n\n  /**\n   * Returns all of the parent elements.\n   * @type ArraySlice\n   */\n  get parents() {\n    let {\n      parent\n    } = this;\n    const parents = new ArraySlice();\n    while (parent) {\n      parents.push(parent);\n\n      // eslint-disable-next-line prefer-destructuring\n      parent = parent.parent;\n    }\n    return parents;\n  }\n\n  /**\n   * Returns all of the children elements found within the element.\n   * @type ArraySlice\n   * @see recursiveChildren\n   */\n  get children() {\n    if (Array.isArray(this.content)) {\n      return new ArraySlice(this.content);\n    }\n    if (this.content instanceof KeyValuePair) {\n      const children = new ArraySlice([this.content.key]);\n      if (this.content.value) {\n        children.push(this.content.value);\n      }\n      return children;\n    }\n    if (this.content instanceof Element) {\n      return new ArraySlice([this.content]);\n    }\n    return new ArraySlice();\n  }\n\n  /**\n  * Returns all of the children elements found within the element recursively.\n  * @type ArraySlice\n  * @see children\n  */\n  get recursiveChildren() {\n    const children = new ArraySlice();\n    this.children.forEach(element => {\n      children.push(element);\n      element.recursiveChildren.forEach(child => {\n        children.push(child);\n      });\n    });\n    return children;\n  }\n}\nmodule.exports = Element;","map":{"version":3,"names":["isEqual","require","KeyValuePair","ArraySlice","Element","constructor","content","meta","attributes","freeze","Object","isFrozen","_meta","parent","_attributes","children","forEach","element","Array","isArray","primitive","clone","copy","length","map","toValue","key","value","undefined","toRef","path","id","Error","ref","RefElement","findRecursive","elementNames","arguments","elementName","pop","elements","append","array","push","checkElement","items","reduce","isEmpty","filter","parentElements","parents","e","namesIndex","name","index","indexOf","splice","set","equals","getMetaProperty","hasKey","refract","get","setMetaProperty","_storedElement","_content","keys","MemberElement","ObjectElement","classes","title","description","links","recursiveChildren","child","module","exports"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/minim/lib/primitives/Element.js"],"sourcesContent":["const isEqual = require('lodash/isEqual');\nconst KeyValuePair = require('../KeyValuePair');\nconst ArraySlice = require('../ArraySlice.js');\n\n/**\n * @class\n *\n * @param content\n * @param meta\n * @param attributes\n *\n * @property {string} element\n */\nclass Element {\n  constructor(content, meta, attributes) {\n    // Lazy load this.meta and this.attributes because it's a Minim element\n    // Otherwise, we get into circuluar calls\n    if (meta) {\n      this.meta = meta;\n    }\n\n    if (attributes) {\n      this.attributes = attributes;\n    }\n\n    this.content = content;\n  }\n\n  /**\n   * Freezes the element to prevent any mutation.\n   * A frozen element will add `parent` property to every child element\n   * to allow traversing up the element tree.\n   */\n  freeze() {\n    if (Object.isFrozen(this)) {\n      return;\n    }\n\n    if (this._meta) {\n      this.meta.parent = this;\n      this.meta.freeze();\n    }\n\n    if (this._attributes) {\n      this.attributes.parent = this;\n      this.attributes.freeze();\n    }\n\n    this.children.forEach((element) => {\n      element.parent = this;\n      element.freeze();\n    }, this);\n\n    if (this.content && Array.isArray(this.content)) {\n      Object.freeze(this.content);\n    }\n\n    Object.freeze(this);\n  }\n\n  primitive() {\n\n  }\n\n  /**\n   * Creates a deep clone of the instance\n   */\n  clone() {\n    const copy = new this.constructor();\n\n    copy.element = this.element;\n\n    if (this.meta.length) {\n      copy._meta = this.meta.clone();\n    }\n\n    if (this.attributes.length) {\n      copy._attributes = this.attributes.clone();\n    }\n\n    if (this.content) {\n      if (this.content.clone) {\n        copy.content = this.content.clone();\n      } else if (Array.isArray(this.content)) {\n        copy.content = this.content.map(element => element.clone());\n      } else {\n        copy.content = this.content;\n      }\n    } else {\n      copy.content = this.content;\n    }\n\n    return copy;\n  }\n\n  /**\n   */\n  toValue() {\n    if (this.content instanceof Element) {\n      return this.content.toValue();\n    }\n\n    if (this.content instanceof KeyValuePair) {\n      return {\n        key: this.content.key.toValue(),\n        value: this.content.value ? this.content.value.toValue() : undefined,\n      };\n    }\n\n    if (this.content && this.content.map) {\n      return this.content.map(element => element.toValue(), this);\n    }\n\n    return this.content;\n  }\n\n  /**\n   * Creates a reference pointing at the Element\n   * @returns {RefElement}\n   * @memberof Element.prototype\n   */\n  toRef(path) {\n    if (this.id.toValue() === '') {\n      throw Error('Cannot create reference to an element that does not contain an ID');\n    }\n\n    const ref = new this.RefElement(this.id.toValue());\n\n    if (path) {\n      ref.path = path;\n    }\n\n    return ref;\n  }\n\n  /**\n   * Finds the given elements in the element tree.\n   * When providing multiple element names, you must first freeze the element.\n   *\n   * @param names {...elementNames}\n   * @returns {ArraySlice}\n   */\n  findRecursive(...elementNames) {\n    if (arguments.length > 1 && !this.isFrozen) {\n      throw new Error('Cannot find recursive with multiple element names without first freezing the element. Call `element.freeze()`');\n    }\n\n    const elementName = elementNames.pop();\n    let elements = new ArraySlice();\n\n    const append = (array, element) => {\n      array.push(element);\n      return array;\n    };\n\n    // Checks the given element and appends element/sub-elements\n    // that match element name to given array\n    const checkElement = (array, element) => {\n      if (element.element === elementName) {\n        array.push(element);\n      }\n\n      const items = element.findRecursive(elementName);\n      if (items) {\n        items.reduce(append, array);\n      }\n\n      if (element.content instanceof KeyValuePair) {\n        if (element.content.key) {\n          checkElement(array, element.content.key);\n        }\n\n        if (element.content.value) {\n          checkElement(array, element.content.value);\n        }\n      }\n\n      return array;\n    };\n\n    if (this.content) {\n      // Direct Element\n      if (this.content.element) {\n        checkElement(elements, this.content);\n      }\n\n      // Element Array\n      if (Array.isArray(this.content)) {\n        this.content.reduce(checkElement, elements);\n      }\n    }\n\n    if (!elementNames.isEmpty) {\n      elements = elements.filter((element) => {\n        let parentElements = element.parents.map(e => e.element);\n\n        // eslint-disable-next-line no-restricted-syntax\n        for (const namesIndex in elementNames) {\n          const name = elementNames[namesIndex];\n          const index = parentElements.indexOf(name);\n\n          if (index !== -1) {\n            parentElements = parentElements.splice(0, index);\n          } else {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n\n    return elements;\n  }\n\n  set(content) {\n    this.content = content;\n    return this;\n  }\n\n  equals(value) {\n    return isEqual(this.toValue(), value);\n  }\n\n  getMetaProperty(name, value) {\n    if (!this.meta.hasKey(name)) {\n      if (this.isFrozen) {\n        const element = this.refract(value);\n        element.freeze();\n        return element;\n      }\n\n      this.meta.set(name, value);\n    }\n\n    return this.meta.get(name);\n  }\n\n  setMetaProperty(name, value) {\n    this.meta.set(name, value);\n  }\n\n  /**\n   * @type String\n   */\n  get element() {\n    // Returns 'element' so we don't have undefined as element\n    return this._storedElement || 'element';\n  }\n\n  set element(element) {\n    this._storedElement = element;\n  }\n\n  get content() {\n    return this._content;\n  }\n\n  set content(value) {\n    if (value instanceof Element) {\n      this._content = value;\n    } else if (value instanceof ArraySlice) {\n      this.content = value.elements;\n    } else if (\n      typeof value == 'string'\n      || typeof value == 'number'\n      || typeof value == 'boolean'\n      || value === 'null'\n      || value == undefined\n    ) {\n      // Primitive Values\n      this._content = value;\n    } else if (value instanceof KeyValuePair) {\n      this._content = value;\n    } else if (Array.isArray(value)) {\n      this._content = value.map(this.refract);\n    } else if (typeof value === 'object') {\n      this._content = Object.keys(value).map(key => new this.MemberElement(key, value[key]));\n    } else {\n      throw new Error('Cannot set content to given value');\n    }\n  }\n\n  /**\n   * @type ObjectElement\n   */\n  get meta() {\n    if (!this._meta) {\n      if (this.isFrozen) {\n        const meta = new this.ObjectElement();\n        meta.freeze();\n        return meta;\n      }\n\n      this._meta = new this.ObjectElement();\n    }\n\n    return this._meta;\n  }\n\n  set meta(value) {\n    if (value instanceof this.ObjectElement) {\n      this._meta = value;\n    } else {\n      this.meta.set(value || {});\n    }\n  }\n\n  /**\n   * The attributes property defines attributes about the given instance\n   * of the element, as specified by the element property.\n   *\n   * @type ObjectElement\n   */\n  get attributes() {\n    if (!this._attributes) {\n      if (this.isFrozen) {\n        const meta = new this.ObjectElement();\n        meta.freeze();\n        return meta;\n      }\n\n      this._attributes = new this.ObjectElement();\n    }\n\n    return this._attributes;\n  }\n\n  set attributes(value) {\n    if (value instanceof this.ObjectElement) {\n      this._attributes = value;\n    } else {\n      this.attributes.set(value || {});\n    }\n  }\n\n  /**\n   * Unique Identifier, MUST be unique throughout an entire element tree.\n   * @type StringElement\n   */\n  get id() {\n    return this.getMetaProperty('id', '');\n  }\n\n  set id(element) {\n    this.setMetaProperty('id', element);\n  }\n\n  /**\n   * @type ArrayElement\n   */\n  get classes() {\n    return this.getMetaProperty('classes', []);\n  }\n\n  set classes(element) {\n    this.setMetaProperty('classes', element);\n  }\n\n  /**\n   * Human-readable title of element\n   * @type StringElement\n   */\n  get title() {\n    return this.getMetaProperty('title', '');\n  }\n\n  set title(element) {\n    this.setMetaProperty('title', element);\n  }\n\n  /**\n   * Human-readable description of element\n   * @type StringElement\n   */\n  get description() {\n    return this.getMetaProperty('description', '');\n  }\n\n  set description(element) {\n    this.setMetaProperty('description', element);\n  }\n\n  /**\n   * @type ArrayElement\n   */\n  get links() {\n    return this.getMetaProperty('links', []);\n  }\n\n  set links(element) {\n    this.setMetaProperty('links', element);\n  }\n\n  /**\n   * Returns whether the element is frozen.\n   * @type boolean\n   * @see freeze\n   */\n  get isFrozen() {\n    return Object.isFrozen(this);\n  }\n\n  /**\n   * Returns all of the parent elements.\n   * @type ArraySlice\n   */\n  get parents() {\n    let { parent } = this;\n    const parents = new ArraySlice();\n\n    while (parent) {\n      parents.push(parent);\n\n      // eslint-disable-next-line prefer-destructuring\n      parent = parent.parent;\n    }\n\n    return parents;\n  }\n\n  /**\n   * Returns all of the children elements found within the element.\n   * @type ArraySlice\n   * @see recursiveChildren\n   */\n  get children() {\n    if (Array.isArray(this.content)) {\n      return new ArraySlice(this.content);\n    }\n\n    if (this.content instanceof KeyValuePair) {\n      const children = new ArraySlice([this.content.key]);\n\n      if (this.content.value) {\n        children.push(this.content.value);\n      }\n\n      return children;\n    }\n\n    if (this.content instanceof Element) {\n      return new ArraySlice([this.content]);\n    }\n\n    return new ArraySlice();\n  }\n\n  /**\n  * Returns all of the children elements found within the element recursively.\n  * @type ArraySlice\n  * @see children\n  */\n  get recursiveChildren() {\n    const children = new ArraySlice();\n\n    this.children.forEach((element) => {\n      children.push(element);\n\n      element.recursiveChildren.forEach((child) => {\n        children.push(child);\n      });\n    });\n\n    return children;\n  }\n}\n\nmodule.exports = Element;\n"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AACzC,MAAMC,YAAY,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAC/C,MAAME,UAAU,GAAGF,OAAO,CAAC,kBAAkB,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,OAAO,CAAC;EACZC,WAAWA,CAACC,OAAO,EAAEC,IAAI,EAAEC,UAAU,EAAE;IACrC;IACA;IACA,IAAID,IAAI,EAAE;MACR,IAAI,CAACA,IAAI,GAAGA,IAAI;IAClB;IAEA,IAAIC,UAAU,EAAE;MACd,IAAI,CAACA,UAAU,GAAGA,UAAU;IAC9B;IAEA,IAAI,CAACF,OAAO,GAAGA,OAAO;EACxB;;EAEA;AACF;AACA;AACA;AACA;EACEG,MAAMA,CAAA,EAAG;IACP,IAAIC,MAAM,CAACC,QAAQ,CAAC,IAAI,CAAC,EAAE;MACzB;IACF;IAEA,IAAI,IAAI,CAACC,KAAK,EAAE;MACd,IAAI,CAACL,IAAI,CAACM,MAAM,GAAG,IAAI;MACvB,IAAI,CAACN,IAAI,CAACE,MAAM,CAAC,CAAC;IACpB;IAEA,IAAI,IAAI,CAACK,WAAW,EAAE;MACpB,IAAI,CAACN,UAAU,CAACK,MAAM,GAAG,IAAI;MAC7B,IAAI,CAACL,UAAU,CAACC,MAAM,CAAC,CAAC;IAC1B;IAEA,IAAI,CAACM,QAAQ,CAACC,OAAO,CAAEC,OAAO,IAAK;MACjCA,OAAO,CAACJ,MAAM,GAAG,IAAI;MACrBI,OAAO,CAACR,MAAM,CAAC,CAAC;IAClB,CAAC,EAAE,IAAI,CAAC;IAER,IAAI,IAAI,CAACH,OAAO,IAAIY,KAAK,CAACC,OAAO,CAAC,IAAI,CAACb,OAAO,CAAC,EAAE;MAC/CI,MAAM,CAACD,MAAM,CAAC,IAAI,CAACH,OAAO,CAAC;IAC7B;IAEAI,MAAM,CAACD,MAAM,CAAC,IAAI,CAAC;EACrB;EAEAW,SAASA,CAAA,EAAG,CAEZ;;EAEA;AACF;AACA;EACEC,KAAKA,CAAA,EAAG;IACN,MAAMC,IAAI,GAAG,IAAI,IAAI,CAACjB,WAAW,CAAC,CAAC;IAEnCiB,IAAI,CAACL,OAAO,GAAG,IAAI,CAACA,OAAO;IAE3B,IAAI,IAAI,CAACV,IAAI,CAACgB,MAAM,EAAE;MACpBD,IAAI,CAACV,KAAK,GAAG,IAAI,CAACL,IAAI,CAACc,KAAK,CAAC,CAAC;IAChC;IAEA,IAAI,IAAI,CAACb,UAAU,CAACe,MAAM,EAAE;MAC1BD,IAAI,CAACR,WAAW,GAAG,IAAI,CAACN,UAAU,CAACa,KAAK,CAAC,CAAC;IAC5C;IAEA,IAAI,IAAI,CAACf,OAAO,EAAE;MAChB,IAAI,IAAI,CAACA,OAAO,CAACe,KAAK,EAAE;QACtBC,IAAI,CAAChB,OAAO,GAAG,IAAI,CAACA,OAAO,CAACe,KAAK,CAAC,CAAC;MACrC,CAAC,MAAM,IAAIH,KAAK,CAACC,OAAO,CAAC,IAAI,CAACb,OAAO,CAAC,EAAE;QACtCgB,IAAI,CAAChB,OAAO,GAAG,IAAI,CAACA,OAAO,CAACkB,GAAG,CAACP,OAAO,IAAIA,OAAO,CAACI,KAAK,CAAC,CAAC,CAAC;MAC7D,CAAC,MAAM;QACLC,IAAI,CAAChB,OAAO,GAAG,IAAI,CAACA,OAAO;MAC7B;IACF,CAAC,MAAM;MACLgB,IAAI,CAAChB,OAAO,GAAG,IAAI,CAACA,OAAO;IAC7B;IAEA,OAAOgB,IAAI;EACb;;EAEA;AACF;EACEG,OAAOA,CAAA,EAAG;IACR,IAAI,IAAI,CAACnB,OAAO,YAAYF,OAAO,EAAE;MACnC,OAAO,IAAI,CAACE,OAAO,CAACmB,OAAO,CAAC,CAAC;IAC/B;IAEA,IAAI,IAAI,CAACnB,OAAO,YAAYJ,YAAY,EAAE;MACxC,OAAO;QACLwB,GAAG,EAAE,IAAI,CAACpB,OAAO,CAACoB,GAAG,CAACD,OAAO,CAAC,CAAC;QAC/BE,KAAK,EAAE,IAAI,CAACrB,OAAO,CAACqB,KAAK,GAAG,IAAI,CAACrB,OAAO,CAACqB,KAAK,CAACF,OAAO,CAAC,CAAC,GAAGG;MAC7D,CAAC;IACH;IAEA,IAAI,IAAI,CAACtB,OAAO,IAAI,IAAI,CAACA,OAAO,CAACkB,GAAG,EAAE;MACpC,OAAO,IAAI,CAAClB,OAAO,CAACkB,GAAG,CAACP,OAAO,IAAIA,OAAO,CAACQ,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC;IAC7D;IAEA,OAAO,IAAI,CAACnB,OAAO;EACrB;;EAEA;AACF;AACA;AACA;AACA;EACEuB,KAAKA,CAACC,IAAI,EAAE;IACV,IAAI,IAAI,CAACC,EAAE,CAACN,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;MAC5B,MAAMO,KAAK,CAAC,mEAAmE,CAAC;IAClF;IAEA,MAAMC,GAAG,GAAG,IAAI,IAAI,CAACC,UAAU,CAAC,IAAI,CAACH,EAAE,CAACN,OAAO,CAAC,CAAC,CAAC;IAElD,IAAIK,IAAI,EAAE;MACRG,GAAG,CAACH,IAAI,GAAGA,IAAI;IACjB;IAEA,OAAOG,GAAG;EACZ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,aAAaA,CAAC,GAAGC,YAAY,EAAE;IAC7B,IAAIC,SAAS,CAACd,MAAM,GAAG,CAAC,IAAI,CAAC,IAAI,CAACZ,QAAQ,EAAE;MAC1C,MAAM,IAAIqB,KAAK,CAAC,+GAA+G,CAAC;IAClI;IAEA,MAAMM,WAAW,GAAGF,YAAY,CAACG,GAAG,CAAC,CAAC;IACtC,IAAIC,QAAQ,GAAG,IAAIrC,UAAU,CAAC,CAAC;IAE/B,MAAMsC,MAAM,GAAGA,CAACC,KAAK,EAAEzB,OAAO,KAAK;MACjCyB,KAAK,CAACC,IAAI,CAAC1B,OAAO,CAAC;MACnB,OAAOyB,KAAK;IACd,CAAC;;IAED;IACA;IACA,MAAME,YAAY,GAAGA,CAACF,KAAK,EAAEzB,OAAO,KAAK;MACvC,IAAIA,OAAO,CAACA,OAAO,KAAKqB,WAAW,EAAE;QACnCI,KAAK,CAACC,IAAI,CAAC1B,OAAO,CAAC;MACrB;MAEA,MAAM4B,KAAK,GAAG5B,OAAO,CAACkB,aAAa,CAACG,WAAW,CAAC;MAChD,IAAIO,KAAK,EAAE;QACTA,KAAK,CAACC,MAAM,CAACL,MAAM,EAAEC,KAAK,CAAC;MAC7B;MAEA,IAAIzB,OAAO,CAACX,OAAO,YAAYJ,YAAY,EAAE;QAC3C,IAAIe,OAAO,CAACX,OAAO,CAACoB,GAAG,EAAE;UACvBkB,YAAY,CAACF,KAAK,EAAEzB,OAAO,CAACX,OAAO,CAACoB,GAAG,CAAC;QAC1C;QAEA,IAAIT,OAAO,CAACX,OAAO,CAACqB,KAAK,EAAE;UACzBiB,YAAY,CAACF,KAAK,EAAEzB,OAAO,CAACX,OAAO,CAACqB,KAAK,CAAC;QAC5C;MACF;MAEA,OAAOe,KAAK;IACd,CAAC;IAED,IAAI,IAAI,CAACpC,OAAO,EAAE;MAChB;MACA,IAAI,IAAI,CAACA,OAAO,CAACW,OAAO,EAAE;QACxB2B,YAAY,CAACJ,QAAQ,EAAE,IAAI,CAAClC,OAAO,CAAC;MACtC;;MAEA;MACA,IAAIY,KAAK,CAACC,OAAO,CAAC,IAAI,CAACb,OAAO,CAAC,EAAE;QAC/B,IAAI,CAACA,OAAO,CAACwC,MAAM,CAACF,YAAY,EAAEJ,QAAQ,CAAC;MAC7C;IACF;IAEA,IAAI,CAACJ,YAAY,CAACW,OAAO,EAAE;MACzBP,QAAQ,GAAGA,QAAQ,CAACQ,MAAM,CAAE/B,OAAO,IAAK;QACtC,IAAIgC,cAAc,GAAGhC,OAAO,CAACiC,OAAO,CAAC1B,GAAG,CAAC2B,CAAC,IAAIA,CAAC,CAAClC,OAAO,CAAC;;QAExD;QACA,KAAK,MAAMmC,UAAU,IAAIhB,YAAY,EAAE;UACrC,MAAMiB,IAAI,GAAGjB,YAAY,CAACgB,UAAU,CAAC;UACrC,MAAME,KAAK,GAAGL,cAAc,CAACM,OAAO,CAACF,IAAI,CAAC;UAE1C,IAAIC,KAAK,KAAK,CAAC,CAAC,EAAE;YAChBL,cAAc,GAAGA,cAAc,CAACO,MAAM,CAAC,CAAC,EAAEF,KAAK,CAAC;UAClD,CAAC,MAAM;YACL,OAAO,KAAK;UACd;QACF;QAEA,OAAO,IAAI;MACb,CAAC,CAAC;IACJ;IAEA,OAAOd,QAAQ;EACjB;EAEAiB,GAAGA,CAACnD,OAAO,EAAE;IACX,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,OAAO,IAAI;EACb;EAEAoD,MAAMA,CAAC/B,KAAK,EAAE;IACZ,OAAO3B,OAAO,CAAC,IAAI,CAACyB,OAAO,CAAC,CAAC,EAAEE,KAAK,CAAC;EACvC;EAEAgC,eAAeA,CAACN,IAAI,EAAE1B,KAAK,EAAE;IAC3B,IAAI,CAAC,IAAI,CAACpB,IAAI,CAACqD,MAAM,CAACP,IAAI,CAAC,EAAE;MAC3B,IAAI,IAAI,CAAC1C,QAAQ,EAAE;QACjB,MAAMM,OAAO,GAAG,IAAI,CAAC4C,OAAO,CAAClC,KAAK,CAAC;QACnCV,OAAO,CAACR,MAAM,CAAC,CAAC;QAChB,OAAOQ,OAAO;MAChB;MAEA,IAAI,CAACV,IAAI,CAACkD,GAAG,CAACJ,IAAI,EAAE1B,KAAK,CAAC;IAC5B;IAEA,OAAO,IAAI,CAACpB,IAAI,CAACuD,GAAG,CAACT,IAAI,CAAC;EAC5B;EAEAU,eAAeA,CAACV,IAAI,EAAE1B,KAAK,EAAE;IAC3B,IAAI,CAACpB,IAAI,CAACkD,GAAG,CAACJ,IAAI,EAAE1B,KAAK,CAAC;EAC5B;;EAEA;AACF;AACA;EACE,IAAIV,OAAOA,CAAA,EAAG;IACZ;IACA,OAAO,IAAI,CAAC+C,cAAc,IAAI,SAAS;EACzC;EAEA,IAAI/C,OAAOA,CAACA,OAAO,EAAE;IACnB,IAAI,CAAC+C,cAAc,GAAG/C,OAAO;EAC/B;EAEA,IAAIX,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAAC2D,QAAQ;EACtB;EAEA,IAAI3D,OAAOA,CAACqB,KAAK,EAAE;IACjB,IAAIA,KAAK,YAAYvB,OAAO,EAAE;MAC5B,IAAI,CAAC6D,QAAQ,GAAGtC,KAAK;IACvB,CAAC,MAAM,IAAIA,KAAK,YAAYxB,UAAU,EAAE;MACtC,IAAI,CAACG,OAAO,GAAGqB,KAAK,CAACa,QAAQ;IAC/B,CAAC,MAAM,IACL,OAAOb,KAAK,IAAI,QAAQ,IACrB,OAAOA,KAAK,IAAI,QAAQ,IACxB,OAAOA,KAAK,IAAI,SAAS,IACzBA,KAAK,KAAK,MAAM,IAChBA,KAAK,IAAIC,SAAS,EACrB;MACA;MACA,IAAI,CAACqC,QAAQ,GAAGtC,KAAK;IACvB,CAAC,MAAM,IAAIA,KAAK,YAAYzB,YAAY,EAAE;MACxC,IAAI,CAAC+D,QAAQ,GAAGtC,KAAK;IACvB,CAAC,MAAM,IAAIT,KAAK,CAACC,OAAO,CAACQ,KAAK,CAAC,EAAE;MAC/B,IAAI,CAACsC,QAAQ,GAAGtC,KAAK,CAACH,GAAG,CAAC,IAAI,CAACqC,OAAO,CAAC;IACzC,CAAC,MAAM,IAAI,OAAOlC,KAAK,KAAK,QAAQ,EAAE;MACpC,IAAI,CAACsC,QAAQ,GAAGvD,MAAM,CAACwD,IAAI,CAACvC,KAAK,CAAC,CAACH,GAAG,CAACE,GAAG,IAAI,IAAI,IAAI,CAACyC,aAAa,CAACzC,GAAG,EAAEC,KAAK,CAACD,GAAG,CAAC,CAAC,CAAC;IACxF,CAAC,MAAM;MACL,MAAM,IAAIM,KAAK,CAAC,mCAAmC,CAAC;IACtD;EACF;;EAEA;AACF;AACA;EACE,IAAIzB,IAAIA,CAAA,EAAG;IACT,IAAI,CAAC,IAAI,CAACK,KAAK,EAAE;MACf,IAAI,IAAI,CAACD,QAAQ,EAAE;QACjB,MAAMJ,IAAI,GAAG,IAAI,IAAI,CAAC6D,aAAa,CAAC,CAAC;QACrC7D,IAAI,CAACE,MAAM,CAAC,CAAC;QACb,OAAOF,IAAI;MACb;MAEA,IAAI,CAACK,KAAK,GAAG,IAAI,IAAI,CAACwD,aAAa,CAAC,CAAC;IACvC;IAEA,OAAO,IAAI,CAACxD,KAAK;EACnB;EAEA,IAAIL,IAAIA,CAACoB,KAAK,EAAE;IACd,IAAIA,KAAK,YAAY,IAAI,CAACyC,aAAa,EAAE;MACvC,IAAI,CAACxD,KAAK,GAAGe,KAAK;IACpB,CAAC,MAAM;MACL,IAAI,CAACpB,IAAI,CAACkD,GAAG,CAAC9B,KAAK,IAAI,CAAC,CAAC,CAAC;IAC5B;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,IAAInB,UAAUA,CAAA,EAAG;IACf,IAAI,CAAC,IAAI,CAACM,WAAW,EAAE;MACrB,IAAI,IAAI,CAACH,QAAQ,EAAE;QACjB,MAAMJ,IAAI,GAAG,IAAI,IAAI,CAAC6D,aAAa,CAAC,CAAC;QACrC7D,IAAI,CAACE,MAAM,CAAC,CAAC;QACb,OAAOF,IAAI;MACb;MAEA,IAAI,CAACO,WAAW,GAAG,IAAI,IAAI,CAACsD,aAAa,CAAC,CAAC;IAC7C;IAEA,OAAO,IAAI,CAACtD,WAAW;EACzB;EAEA,IAAIN,UAAUA,CAACmB,KAAK,EAAE;IACpB,IAAIA,KAAK,YAAY,IAAI,CAACyC,aAAa,EAAE;MACvC,IAAI,CAACtD,WAAW,GAAGa,KAAK;IAC1B,CAAC,MAAM;MACL,IAAI,CAACnB,UAAU,CAACiD,GAAG,CAAC9B,KAAK,IAAI,CAAC,CAAC,CAAC;IAClC;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAII,EAAEA,CAAA,EAAG;IACP,OAAO,IAAI,CAAC4B,eAAe,CAAC,IAAI,EAAE,EAAE,CAAC;EACvC;EAEA,IAAI5B,EAAEA,CAACd,OAAO,EAAE;IACd,IAAI,CAAC8C,eAAe,CAAC,IAAI,EAAE9C,OAAO,CAAC;EACrC;;EAEA;AACF;AACA;EACE,IAAIoD,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACV,eAAe,CAAC,SAAS,EAAE,EAAE,CAAC;EAC5C;EAEA,IAAIU,OAAOA,CAACpD,OAAO,EAAE;IACnB,IAAI,CAAC8C,eAAe,CAAC,SAAS,EAAE9C,OAAO,CAAC;EAC1C;;EAEA;AACF;AACA;AACA;EACE,IAAIqD,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACX,eAAe,CAAC,OAAO,EAAE,EAAE,CAAC;EAC1C;EAEA,IAAIW,KAAKA,CAACrD,OAAO,EAAE;IACjB,IAAI,CAAC8C,eAAe,CAAC,OAAO,EAAE9C,OAAO,CAAC;EACxC;;EAEA;AACF;AACA;AACA;EACE,IAAIsD,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACZ,eAAe,CAAC,aAAa,EAAE,EAAE,CAAC;EAChD;EAEA,IAAIY,WAAWA,CAACtD,OAAO,EAAE;IACvB,IAAI,CAAC8C,eAAe,CAAC,aAAa,EAAE9C,OAAO,CAAC;EAC9C;;EAEA;AACF;AACA;EACE,IAAIuD,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACb,eAAe,CAAC,OAAO,EAAE,EAAE,CAAC;EAC1C;EAEA,IAAIa,KAAKA,CAACvD,OAAO,EAAE;IACjB,IAAI,CAAC8C,eAAe,CAAC,OAAO,EAAE9C,OAAO,CAAC;EACxC;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIN,QAAQA,CAAA,EAAG;IACb,OAAOD,MAAM,CAACC,QAAQ,CAAC,IAAI,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;EACE,IAAIuC,OAAOA,CAAA,EAAG;IACZ,IAAI;MAAErC;IAAO,CAAC,GAAG,IAAI;IACrB,MAAMqC,OAAO,GAAG,IAAI/C,UAAU,CAAC,CAAC;IAEhC,OAAOU,MAAM,EAAE;MACbqC,OAAO,CAACP,IAAI,CAAC9B,MAAM,CAAC;;MAEpB;MACAA,MAAM,GAAGA,MAAM,CAACA,MAAM;IACxB;IAEA,OAAOqC,OAAO;EAChB;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAInC,QAAQA,CAAA,EAAG;IACb,IAAIG,KAAK,CAACC,OAAO,CAAC,IAAI,CAACb,OAAO,CAAC,EAAE;MAC/B,OAAO,IAAIH,UAAU,CAAC,IAAI,CAACG,OAAO,CAAC;IACrC;IAEA,IAAI,IAAI,CAACA,OAAO,YAAYJ,YAAY,EAAE;MACxC,MAAMa,QAAQ,GAAG,IAAIZ,UAAU,CAAC,CAAC,IAAI,CAACG,OAAO,CAACoB,GAAG,CAAC,CAAC;MAEnD,IAAI,IAAI,CAACpB,OAAO,CAACqB,KAAK,EAAE;QACtBZ,QAAQ,CAAC4B,IAAI,CAAC,IAAI,CAACrC,OAAO,CAACqB,KAAK,CAAC;MACnC;MAEA,OAAOZ,QAAQ;IACjB;IAEA,IAAI,IAAI,CAACT,OAAO,YAAYF,OAAO,EAAE;MACnC,OAAO,IAAID,UAAU,CAAC,CAAC,IAAI,CAACG,OAAO,CAAC,CAAC;IACvC;IAEA,OAAO,IAAIH,UAAU,CAAC,CAAC;EACzB;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIsE,iBAAiBA,CAAA,EAAG;IACtB,MAAM1D,QAAQ,GAAG,IAAIZ,UAAU,CAAC,CAAC;IAEjC,IAAI,CAACY,QAAQ,CAACC,OAAO,CAAEC,OAAO,IAAK;MACjCF,QAAQ,CAAC4B,IAAI,CAAC1B,OAAO,CAAC;MAEtBA,OAAO,CAACwD,iBAAiB,CAACzD,OAAO,CAAE0D,KAAK,IAAK;QAC3C3D,QAAQ,CAAC4B,IAAI,CAAC+B,KAAK,CAAC;MACtB,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,OAAO3D,QAAQ;EACjB;AACF;AAEA4D,MAAM,CAACC,OAAO,GAAGxE,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}