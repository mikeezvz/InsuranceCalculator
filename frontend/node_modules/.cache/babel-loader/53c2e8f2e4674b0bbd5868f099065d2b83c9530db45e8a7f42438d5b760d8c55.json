{"ast":null,"code":"import { F as stubFalse, pipe } from 'ramda';\nimport { isString } from 'ramda-adjunct';\nimport { visit as astVisit, BREAK, mergeAllVisitors, cloneNode as cloneNodeDefault } from '@swagger-api/apidom-ast';\nimport { isElement, isMemberElement, isArrayElement, isStringElement, isBooleanElement, isLinkElement, isRefElement, isObjectElement, isNullElement, isNumberElement } from \"../predicates/index.mjs\";\nimport { cloneShallow } from \"../clone/index.mjs\";\nexport { BREAK, mergeAllVisitors };\n\n// getNodeType :: Node -> String\nexport const getNodeType = element => {\n  /*\n   * We're translating every possible higher element type to primitive minim type here.\n   * We're using polymorphism to recognize any higher element type as ObjectElement or ArrayElement.\n   * Using polymorphism allows us to assume any namespace.\n   *\n   * There is a problem with naming visitor methods described here: https://github.com/babel/babel/discussions/12874\n   */\n  return isObjectElement(element) ? 'ObjectElement' : isArrayElement(element) ? 'ArrayElement' : isMemberElement(element) ? 'MemberElement' : isStringElement(element) ? 'StringElement' : isBooleanElement(element) ? 'BooleanElement' : isNumberElement(element) ? 'NumberElement' : isNullElement(element) ? 'NullElement' : isLinkElement(element) ? 'LinkElement' : isRefElement(element) ? 'RefElement' : undefined;\n};\n\n// cloneNode :: a -> a\nexport const cloneNode = node => {\n  if (isElement(node)) {\n    return cloneShallow(node);\n  }\n  return cloneNodeDefault(node);\n};\n\n// isNode :: Node -> Boolean\nexport const isNode = pipe(getNodeType, isString);\nexport const keyMapDefault = {\n  ObjectElement: ['content'],\n  ArrayElement: ['content'],\n  MemberElement: ['key', 'value'],\n  StringElement: [],\n  BooleanElement: [],\n  NumberElement: [],\n  NullElement: [],\n  RefElement: [],\n  LinkElement: [],\n  Annotation: [],\n  Comment: [],\n  ParseResultElement: ['content'],\n  SourceMap: ['content']\n};\nexport class PredicateVisitor {\n  result;\n  predicate;\n  returnOnTrue;\n  returnOnFalse;\n  constructor({\n    predicate = stubFalse,\n    returnOnTrue,\n    returnOnFalse\n  } = {}) {\n    this.result = [];\n    this.predicate = predicate;\n    this.returnOnTrue = returnOnTrue;\n    this.returnOnFalse = returnOnFalse;\n  }\n  enter(element) {\n    if (this.predicate(element)) {\n      this.result.push(element);\n      return this.returnOnTrue;\n    }\n    return this.returnOnFalse;\n  }\n}\nexport const visit = (root,\n// @ts-ignore\nvisitor, {\n  keyMap = keyMapDefault,\n  ...rest\n} = {}) => {\n  // @ts-ignore\n  return astVisit(root, visitor, {\n    // @ts-ignore\n    keyMap,\n    // @ts-ignore\n    nodeTypeGetter: getNodeType,\n    nodePredicate: isNode,\n    nodeCloneFn: cloneNode,\n    ...rest\n  });\n};\n\n// @ts-ignore\nvisit[Symbol.for('nodejs.util.promisify.custom')] = async (root,\n// @ts-ignore\nvisitor, {\n  keyMap = keyMapDefault,\n  ...rest\n} = {}) => {\n  // @ts-ignore\n  return astVisit[Symbol.for('nodejs.util.promisify.custom')](root, visitor, {\n    // @ts-ignore\n    keyMap,\n    // @ts-ignore\n    nodeTypeGetter: getNodeType,\n    nodePredicate: isNode,\n    nodeCloneFn: cloneNode,\n    ...rest\n  });\n};","map":{"version":3,"names":["F","stubFalse","pipe","isString","visit","astVisit","BREAK","mergeAllVisitors","cloneNode","cloneNodeDefault","isElement","isMemberElement","isArrayElement","isStringElement","isBooleanElement","isLinkElement","isRefElement","isObjectElement","isNullElement","isNumberElement","cloneShallow","getNodeType","element","undefined","node","isNode","keyMapDefault","ObjectElement","ArrayElement","MemberElement","StringElement","BooleanElement","NumberElement","NullElement","RefElement","LinkElement","Annotation","Comment","ParseResultElement","SourceMap","PredicateVisitor","result","predicate","returnOnTrue","returnOnFalse","constructor","enter","push","root","visitor","keyMap","rest","nodeTypeGetter","nodePredicate","nodeCloneFn","Symbol","for"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-core/es/traversal/visitor.mjs"],"sourcesContent":["import { F as stubFalse, pipe } from 'ramda';\nimport { isString } from 'ramda-adjunct';\nimport { visit as astVisit, BREAK, mergeAllVisitors, cloneNode as cloneNodeDefault } from '@swagger-api/apidom-ast';\nimport { isElement, isMemberElement, isArrayElement, isStringElement, isBooleanElement, isLinkElement, isRefElement, isObjectElement, isNullElement, isNumberElement } from \"../predicates/index.mjs\";\nimport { cloneShallow } from \"../clone/index.mjs\";\nexport { BREAK, mergeAllVisitors };\n\n// getNodeType :: Node -> String\nexport const getNodeType = element => {\n  /*\n   * We're translating every possible higher element type to primitive minim type here.\n   * We're using polymorphism to recognize any higher element type as ObjectElement or ArrayElement.\n   * Using polymorphism allows us to assume any namespace.\n   *\n   * There is a problem with naming visitor methods described here: https://github.com/babel/babel/discussions/12874\n   */\n  return isObjectElement(element) ? 'ObjectElement' : isArrayElement(element) ? 'ArrayElement' : isMemberElement(element) ? 'MemberElement' : isStringElement(element) ? 'StringElement' : isBooleanElement(element) ? 'BooleanElement' : isNumberElement(element) ? 'NumberElement' : isNullElement(element) ? 'NullElement' : isLinkElement(element) ? 'LinkElement' : isRefElement(element) ? 'RefElement' : undefined;\n};\n\n// cloneNode :: a -> a\nexport const cloneNode = node => {\n  if (isElement(node)) {\n    return cloneShallow(node);\n  }\n  return cloneNodeDefault(node);\n};\n\n// isNode :: Node -> Boolean\nexport const isNode = pipe(getNodeType, isString);\nexport const keyMapDefault = {\n  ObjectElement: ['content'],\n  ArrayElement: ['content'],\n  MemberElement: ['key', 'value'],\n  StringElement: [],\n  BooleanElement: [],\n  NumberElement: [],\n  NullElement: [],\n  RefElement: [],\n  LinkElement: [],\n  Annotation: [],\n  Comment: [],\n  ParseResultElement: ['content'],\n  SourceMap: ['content']\n};\nexport class PredicateVisitor {\n  result;\n  predicate;\n  returnOnTrue;\n  returnOnFalse;\n  constructor({\n    predicate = stubFalse,\n    returnOnTrue,\n    returnOnFalse\n  } = {}) {\n    this.result = [];\n    this.predicate = predicate;\n    this.returnOnTrue = returnOnTrue;\n    this.returnOnFalse = returnOnFalse;\n  }\n  enter(element) {\n    if (this.predicate(element)) {\n      this.result.push(element);\n      return this.returnOnTrue;\n    }\n    return this.returnOnFalse;\n  }\n}\nexport const visit = (root,\n// @ts-ignore\nvisitor, {\n  keyMap = keyMapDefault,\n  ...rest\n} = {}) => {\n  // @ts-ignore\n  return astVisit(root, visitor, {\n    // @ts-ignore\n    keyMap,\n    // @ts-ignore\n    nodeTypeGetter: getNodeType,\n    nodePredicate: isNode,\n    nodeCloneFn: cloneNode,\n    ...rest\n  });\n};\n\n// @ts-ignore\nvisit[Symbol.for('nodejs.util.promisify.custom')] = async (root,\n// @ts-ignore\nvisitor, {\n  keyMap = keyMapDefault,\n  ...rest\n} = {}) => {\n  // @ts-ignore\n  return astVisit[Symbol.for('nodejs.util.promisify.custom')](root, visitor, {\n    // @ts-ignore\n    keyMap,\n    // @ts-ignore\n    nodeTypeGetter: getNodeType,\n    nodePredicate: isNode,\n    nodeCloneFn: cloneNode,\n    ...rest\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}