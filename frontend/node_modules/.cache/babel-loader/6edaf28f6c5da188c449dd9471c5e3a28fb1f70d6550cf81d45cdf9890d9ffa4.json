{"ast":null,"code":"import { map, pipe, split, startsWith, tail } from 'ramda';\nimport { isEmptyString, trimCharsStart } from 'ramda-adjunct';\nimport unescape from \"./unescape.mjs\";\nimport InvalidJsonPointerError from \"./errors/InvalidJsonPointerError.mjs\"; // parse :: String -> String[]\nconst parse = pointer => {\n  if (isEmptyString(pointer)) {\n    return [];\n  }\n  if (!startsWith('/', pointer)) {\n    throw new InvalidJsonPointerError(`Invalid JSON Pointer \"${pointer}\". JSON Pointers must begin with \"/\"`, {\n      pointer\n    });\n  }\n  try {\n    const tokens = pipe(split('/'), map(unescape))(pointer);\n    return tail(tokens);\n  } catch (error) {\n    throw new InvalidJsonPointerError(`JSON Pointer parsing of \"${pointer}\" encountered an error.`, {\n      pointer,\n      cause: error\n    });\n  }\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n */\nconst getHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  if (hashIndex !== -1) {\n    return uri.substring(hashIndex);\n  }\n  return '#';\n};\n\n// uriToPointer :: String -> String\nexport const uriToPointer = uri => {\n  const hash = getHash(uri);\n  return trimCharsStart('#', hash);\n};\nexport default parse;","map":{"version":3,"names":["map","pipe","split","startsWith","tail","isEmptyString","trimCharsStart","unescape","InvalidJsonPointerError","parse","pointer","tokens","error","cause","getHash","uri","hashIndex","indexOf","substring","uriToPointer","hash"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-json-pointer/es/parse.mjs"],"sourcesContent":["import { map, pipe, split, startsWith, tail } from 'ramda';\nimport { isEmptyString, trimCharsStart } from 'ramda-adjunct';\nimport unescape from \"./unescape.mjs\";\nimport InvalidJsonPointerError from \"./errors/InvalidJsonPointerError.mjs\"; // parse :: String -> String[]\nconst parse = pointer => {\n  if (isEmptyString(pointer)) {\n    return [];\n  }\n  if (!startsWith('/', pointer)) {\n    throw new InvalidJsonPointerError(`Invalid JSON Pointer \"${pointer}\". JSON Pointers must begin with \"/\"`, {\n      pointer\n    });\n  }\n  try {\n    const tokens = pipe(split('/'), map(unescape))(pointer);\n    return tail(tokens);\n  } catch (error) {\n    throw new InvalidJsonPointerError(`JSON Pointer parsing of \"${pointer}\" encountered an error.`, {\n      pointer,\n      cause: error\n    });\n  }\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n */\nconst getHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  if (hashIndex !== -1) {\n    return uri.substring(hashIndex);\n  }\n  return '#';\n};\n\n// uriToPointer :: String -> String\nexport const uriToPointer = uri => {\n  const hash = getHash(uri);\n  return trimCharsStart('#', hash);\n};\nexport default parse;"],"mappings":"AAAA,SAASA,GAAG,EAAEC,IAAI,EAAEC,KAAK,EAAEC,UAAU,EAAEC,IAAI,QAAQ,OAAO;AAC1D,SAASC,aAAa,EAAEC,cAAc,QAAQ,eAAe;AAC7D,OAAOC,QAAQ,MAAM,gBAAgB;AACrC,OAAOC,uBAAuB,MAAM,sCAAsC,CAAC,CAAC;AAC5E,MAAMC,KAAK,GAAGC,OAAO,IAAI;EACvB,IAAIL,aAAa,CAACK,OAAO,CAAC,EAAE;IAC1B,OAAO,EAAE;EACX;EACA,IAAI,CAACP,UAAU,CAAC,GAAG,EAAEO,OAAO,CAAC,EAAE;IAC7B,MAAM,IAAIF,uBAAuB,CAAC,yBAAyBE,OAAO,sCAAsC,EAAE;MACxGA;IACF,CAAC,CAAC;EACJ;EACA,IAAI;IACF,MAAMC,MAAM,GAAGV,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,EAAEF,GAAG,CAACO,QAAQ,CAAC,CAAC,CAACG,OAAO,CAAC;IACvD,OAAON,IAAI,CAACO,MAAM,CAAC;EACrB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACd,MAAM,IAAIJ,uBAAuB,CAAC,4BAA4BE,OAAO,yBAAyB,EAAE;MAC9FA,OAAO;MACPG,KAAK,EAAED;IACT,CAAC,CAAC;EACJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAME,OAAO,GAAGC,GAAG,IAAI;EACrB,MAAMC,SAAS,GAAGD,GAAG,CAACE,OAAO,CAAC,GAAG,CAAC;EAClC,IAAID,SAAS,KAAK,CAAC,CAAC,EAAE;IACpB,OAAOD,GAAG,CAACG,SAAS,CAACF,SAAS,CAAC;EACjC;EACA,OAAO,GAAG;AACZ,CAAC;;AAED;AACA,OAAO,MAAMG,YAAY,GAAGJ,GAAG,IAAI;EACjC,MAAMK,IAAI,GAAGN,OAAO,CAACC,GAAG,CAAC;EACzB,OAAOT,cAAc,CAAC,GAAG,EAAEc,IAAI,CAAC;AAClC,CAAC;AACD,eAAeX,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}