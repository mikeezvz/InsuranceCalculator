{"ast":null,"code":"import _cloneRegExp from \"./_cloneRegExp.js\";\nimport type from \"../type.js\";\n\n/**\n * Copies an object.\n *\n * @private\n * @param {*} value The value to be copied\n * @param {Boolean} deep Whether or not to perform deep cloning.\n * @return {*} The copied value.\n */\nexport default function _clone(value, deep, map) {\n  map || (map = new _ObjectMap());\n\n  // this avoids the slower switch with a quick if decision removing some milliseconds in each run.\n  if (_isPrimitive(value)) {\n    return value;\n  }\n  var copy = function copy(copiedValue) {\n    // Check for circular and same references on the object graph and return its corresponding clone.\n    var cachedCopy = map.get(value);\n    if (cachedCopy) {\n      return cachedCopy;\n    }\n    map.set(value, copiedValue);\n    for (var key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        copiedValue[key] = deep ? _clone(value[key], true, map) : value[key];\n      }\n    }\n    return copiedValue;\n  };\n  switch (type(value)) {\n    case 'Object':\n      return copy(Object.create(Object.getPrototypeOf(value)));\n    case 'Array':\n      return copy(Array(value.length));\n    case 'Date':\n      return new Date(value.valueOf());\n    case 'RegExp':\n      return _cloneRegExp(value);\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'BigInt64Array':\n    case 'BigUint64Array':\n      return value.slice();\n    default:\n      return value;\n  }\n}\nfunction _isPrimitive(param) {\n  var type = typeof param;\n  return param == null || type != 'object' && type != 'function';\n}\nvar _ObjectMap = /*#__PURE__*/function () {\n  function _ObjectMap() {\n    this.map = {};\n    this.length = 0;\n  }\n  _ObjectMap.prototype.set = function (key, value) {\n    var hashedKey = this.hash(key);\n    var bucket = this.map[hashedKey];\n    if (!bucket) {\n      this.map[hashedKey] = bucket = [];\n    }\n    bucket.push([key, value]);\n    this.length += 1;\n  };\n  _ObjectMap.prototype.hash = function (key) {\n    var hashedKey = [];\n    for (var value in key) {\n      hashedKey.push(Object.prototype.toString.call(key[value]));\n    }\n    return hashedKey.join();\n  };\n  _ObjectMap.prototype.get = function (key) {\n    /**\n     * depending on the number of objects to be cloned is faster to just iterate over the items in the map just because the hash function is so costly,\n     * on my tests this number is 180, anything above that using the hash function is faster.\n     */\n    if (this.length <= 180) {\n      for (var p in this.map) {\n        var bucket = this.map[p];\n        for (var i = 0; i < bucket.length; i += 1) {\n          var element = bucket[i];\n          if (element[0] === key) {\n            return element[1];\n          }\n        }\n      }\n      return;\n    }\n    var hashedKey = this.hash(key);\n    var bucket = this.map[hashedKey];\n    if (!bucket) {\n      return;\n    }\n    for (var i = 0; i < bucket.length; i += 1) {\n      var element = bucket[i];\n      if (element[0] === key) {\n        return element[1];\n      }\n    }\n  };\n  return _ObjectMap;\n}();","map":{"version":3,"names":["_cloneRegExp","type","_clone","value","deep","map","_ObjectMap","_isPrimitive","copy","copiedValue","cachedCopy","get","set","key","Object","prototype","hasOwnProperty","call","create","getPrototypeOf","Array","length","Date","valueOf","slice","param","hashedKey","hash","bucket","push","toString","join","p","i","element"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/ramda/es/internal/_clone.js"],"sourcesContent":["import _cloneRegExp from \"./_cloneRegExp.js\";\nimport type from \"../type.js\";\n\n/**\n * Copies an object.\n *\n * @private\n * @param {*} value The value to be copied\n * @param {Boolean} deep Whether or not to perform deep cloning.\n * @return {*} The copied value.\n */\nexport default function _clone(value, deep, map) {\n  map || (map = new _ObjectMap());\n\n  // this avoids the slower switch with a quick if decision removing some milliseconds in each run.\n  if (_isPrimitive(value)) {\n    return value;\n  }\n  var copy = function copy(copiedValue) {\n    // Check for circular and same references on the object graph and return its corresponding clone.\n    var cachedCopy = map.get(value);\n    if (cachedCopy) {\n      return cachedCopy;\n    }\n    map.set(value, copiedValue);\n    for (var key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        copiedValue[key] = deep ? _clone(value[key], true, map) : value[key];\n      }\n    }\n    return copiedValue;\n  };\n  switch (type(value)) {\n    case 'Object':\n      return copy(Object.create(Object.getPrototypeOf(value)));\n    case 'Array':\n      return copy(Array(value.length));\n    case 'Date':\n      return new Date(value.valueOf());\n    case 'RegExp':\n      return _cloneRegExp(value);\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'BigInt64Array':\n    case 'BigUint64Array':\n      return value.slice();\n    default:\n      return value;\n  }\n}\nfunction _isPrimitive(param) {\n  var type = typeof param;\n  return param == null || type != 'object' && type != 'function';\n}\nvar _ObjectMap = /*#__PURE__*/function () {\n  function _ObjectMap() {\n    this.map = {};\n    this.length = 0;\n  }\n  _ObjectMap.prototype.set = function (key, value) {\n    var hashedKey = this.hash(key);\n    var bucket = this.map[hashedKey];\n    if (!bucket) {\n      this.map[hashedKey] = bucket = [];\n    }\n    bucket.push([key, value]);\n    this.length += 1;\n  };\n  _ObjectMap.prototype.hash = function (key) {\n    var hashedKey = [];\n    for (var value in key) {\n      hashedKey.push(Object.prototype.toString.call(key[value]));\n    }\n    return hashedKey.join();\n  };\n  _ObjectMap.prototype.get = function (key) {\n    /**\n     * depending on the number of objects to be cloned is faster to just iterate over the items in the map just because the hash function is so costly,\n     * on my tests this number is 180, anything above that using the hash function is faster.\n     */\n    if (this.length <= 180) {\n      for (var p in this.map) {\n        var bucket = this.map[p];\n        for (var i = 0; i < bucket.length; i += 1) {\n          var element = bucket[i];\n          if (element[0] === key) {\n            return element[1];\n          }\n        }\n      }\n      return;\n    }\n    var hashedKey = this.hash(key);\n    var bucket = this.map[hashedKey];\n    if (!bucket) {\n      return;\n    }\n    for (var i = 0; i < bucket.length; i += 1) {\n      var element = bucket[i];\n      if (element[0] === key) {\n        return element[1];\n      }\n    }\n  };\n  return _ObjectMap;\n}();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}