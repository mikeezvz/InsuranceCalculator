{"ast":null,"code":"import jsYaml from 'js-yaml';\nexport const shouldDownloadAsText = (contentType = '') => /(json|xml|yaml|text)\\b/.test(contentType);\nfunction parseBody(body, contentType) {\n  if (contentType && (contentType.indexOf('application/json') === 0 || contentType.indexOf('+json') > 0)) {\n    return JSON.parse(body);\n  }\n  return jsYaml.load(body);\n}\nfunction serializeHeaderValue(value) {\n  const isMulti = value.includes(', ');\n  return isMulti ? value.split(', ') : value;\n}\n\n// Serialize headers into a hash, where mutliple-headers result in an array.\n//\n// eg: Cookie: one\n//     Cookie: two\n//  =  { Cookie: [ \"one\", \"two\" ]\nexport function serializeHeaders(headers = {}) {\n  if (typeof headers.entries !== 'function') return {};\n  return Array.from(headers.entries()).reduce((acc, [header, value]) => {\n    acc[header] = serializeHeaderValue(value);\n    return acc;\n  }, {});\n}\n\n// Serialize the response, returns a promise with headers and the body part of the hash\nexport function serializeResponse(oriRes, url, {\n  loadSpec = false\n} = {}) {\n  const res = {\n    ok: oriRes.ok,\n    url: oriRes.url || url,\n    status: oriRes.status,\n    statusText: oriRes.statusText,\n    headers: serializeHeaders(oriRes.headers)\n  };\n  const contentType = res.headers['content-type'];\n  const useText = loadSpec || shouldDownloadAsText(contentType);\n  const getBody = useText ? oriRes.text : oriRes.blob || oriRes.buffer;\n  return getBody.call(oriRes).then(body => {\n    res.text = body;\n    res.data = body;\n    if (useText) {\n      try {\n        const obj = parseBody(body, contentType);\n        res.body = obj;\n        res.obj = obj;\n      } catch (e) {\n        res.parseError = e;\n      }\n    }\n    return res;\n  });\n}","map":{"version":3,"names":["jsYaml","shouldDownloadAsText","contentType","test","parseBody","body","indexOf","JSON","parse","load","serializeHeaderValue","value","isMulti","includes","split","serializeHeaders","headers","entries","Array","from","reduce","acc","header","serializeResponse","oriRes","url","loadSpec","res","ok","status","statusText","useText","getBody","text","blob","buffer","call","then","data","obj","e","parseError"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/http/serializers/response/index.js"],"sourcesContent":["import jsYaml from 'js-yaml';\nexport const shouldDownloadAsText = (contentType = '') => /(json|xml|yaml|text)\\b/.test(contentType);\nfunction parseBody(body, contentType) {\n  if (contentType && (contentType.indexOf('application/json') === 0 || contentType.indexOf('+json') > 0)) {\n    return JSON.parse(body);\n  }\n  return jsYaml.load(body);\n}\nfunction serializeHeaderValue(value) {\n  const isMulti = value.includes(', ');\n  return isMulti ? value.split(', ') : value;\n}\n\n// Serialize headers into a hash, where mutliple-headers result in an array.\n//\n// eg: Cookie: one\n//     Cookie: two\n//  =  { Cookie: [ \"one\", \"two\" ]\nexport function serializeHeaders(headers = {}) {\n  if (typeof headers.entries !== 'function') return {};\n  return Array.from(headers.entries()).reduce((acc, [header, value]) => {\n    acc[header] = serializeHeaderValue(value);\n    return acc;\n  }, {});\n}\n\n// Serialize the response, returns a promise with headers and the body part of the hash\nexport function serializeResponse(oriRes, url, {\n  loadSpec = false\n} = {}) {\n  const res = {\n    ok: oriRes.ok,\n    url: oriRes.url || url,\n    status: oriRes.status,\n    statusText: oriRes.statusText,\n    headers: serializeHeaders(oriRes.headers)\n  };\n  const contentType = res.headers['content-type'];\n  const useText = loadSpec || shouldDownloadAsText(contentType);\n  const getBody = useText ? oriRes.text : oriRes.blob || oriRes.buffer;\n  return getBody.call(oriRes).then(body => {\n    res.text = body;\n    res.data = body;\n    if (useText) {\n      try {\n        const obj = parseBody(body, contentType);\n        res.body = obj;\n        res.obj = obj;\n      } catch (e) {\n        res.parseError = e;\n      }\n    }\n    return res;\n  });\n}"],"mappings":"AAAA,OAAOA,MAAM,MAAM,SAAS;AAC5B,OAAO,MAAMC,oBAAoB,GAAGA,CAACC,WAAW,GAAG,EAAE,KAAK,wBAAwB,CAACC,IAAI,CAACD,WAAW,CAAC;AACpG,SAASE,SAASA,CAACC,IAAI,EAAEH,WAAW,EAAE;EACpC,IAAIA,WAAW,KAAKA,WAAW,CAACI,OAAO,CAAC,kBAAkB,CAAC,KAAK,CAAC,IAAIJ,WAAW,CAACI,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE;IACtG,OAAOC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;EACzB;EACA,OAAOL,MAAM,CAACS,IAAI,CAACJ,IAAI,CAAC;AAC1B;AACA,SAASK,oBAAoBA,CAACC,KAAK,EAAE;EACnC,MAAMC,OAAO,GAAGD,KAAK,CAACE,QAAQ,CAAC,IAAI,CAAC;EACpC,OAAOD,OAAO,GAAGD,KAAK,CAACG,KAAK,CAAC,IAAI,CAAC,GAAGH,KAAK;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,gBAAgBA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC7C,IAAI,OAAOA,OAAO,CAACC,OAAO,KAAK,UAAU,EAAE,OAAO,CAAC,CAAC;EACpD,OAAOC,KAAK,CAACC,IAAI,CAACH,OAAO,CAACC,OAAO,CAAC,CAAC,CAAC,CAACG,MAAM,CAAC,CAACC,GAAG,EAAE,CAACC,MAAM,EAAEX,KAAK,CAAC,KAAK;IACpEU,GAAG,CAACC,MAAM,CAAC,GAAGZ,oBAAoB,CAACC,KAAK,CAAC;IACzC,OAAOU,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;;AAEA;AACA,OAAO,SAASE,iBAAiBA,CAACC,MAAM,EAAEC,GAAG,EAAE;EAC7CC,QAAQ,GAAG;AACb,CAAC,GAAG,CAAC,CAAC,EAAE;EACN,MAAMC,GAAG,GAAG;IACVC,EAAE,EAAEJ,MAAM,CAACI,EAAE;IACbH,GAAG,EAAED,MAAM,CAACC,GAAG,IAAIA,GAAG;IACtBI,MAAM,EAAEL,MAAM,CAACK,MAAM;IACrBC,UAAU,EAAEN,MAAM,CAACM,UAAU;IAC7Bd,OAAO,EAAED,gBAAgB,CAACS,MAAM,CAACR,OAAO;EAC1C,CAAC;EACD,MAAMd,WAAW,GAAGyB,GAAG,CAACX,OAAO,CAAC,cAAc,CAAC;EAC/C,MAAMe,OAAO,GAAGL,QAAQ,IAAIzB,oBAAoB,CAACC,WAAW,CAAC;EAC7D,MAAM8B,OAAO,GAAGD,OAAO,GAAGP,MAAM,CAACS,IAAI,GAAGT,MAAM,CAACU,IAAI,IAAIV,MAAM,CAACW,MAAM;EACpE,OAAOH,OAAO,CAACI,IAAI,CAACZ,MAAM,CAAC,CAACa,IAAI,CAAChC,IAAI,IAAI;IACvCsB,GAAG,CAACM,IAAI,GAAG5B,IAAI;IACfsB,GAAG,CAACW,IAAI,GAAGjC,IAAI;IACf,IAAI0B,OAAO,EAAE;MACX,IAAI;QACF,MAAMQ,GAAG,GAAGnC,SAAS,CAACC,IAAI,EAAEH,WAAW,CAAC;QACxCyB,GAAG,CAACtB,IAAI,GAAGkC,GAAG;QACdZ,GAAG,CAACY,GAAG,GAAGA,GAAG;MACf,CAAC,CAAC,OAAOC,CAAC,EAAE;QACVb,GAAG,CAACc,UAAU,GAAGD,CAAC;MACpB;IACF;IACA,OAAOb,GAAG;EACZ,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}