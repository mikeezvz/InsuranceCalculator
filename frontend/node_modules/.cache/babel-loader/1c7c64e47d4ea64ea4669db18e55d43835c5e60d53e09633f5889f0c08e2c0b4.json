{"ast":null,"code":"/*  *************************************************************************************\n *   copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *\n *    Redistribution and use in source and binary forms, with or without\n *    modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this\n *       list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice,\n *       this list of conditions and the following disclaimer in the documentation\n *       and/or other materials provided with the distribution.\n *\n *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n *    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n *    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n *    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n *    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n *    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *   ********************************************************************************* */\nexport { Parser, Ast, Trace, Stats, utilities, identifiers };\nconst Parser = function fnparser() {\n  const id = identifiers;\n  const utils = utilities;\n  const p = this;\n  const thisFileName = 'parser.js: Parser(): ';\n  const systemData = function systemData() {\n    this.state = id.ACTIVE;\n    this.phraseLength = 0;\n    this.refresh = () => {\n      this.state = id.ACTIVE;\n      this.phraseLength = 0;\n    };\n  };\n  p.ast = undefined;\n  p.stats = undefined;\n  p.trace = undefined;\n  p.callbacks = [];\n  let lookAhead = 0;\n  let treeDepth = 0;\n  let maxTreeDepth = 0;\n  let nodeHits = 0;\n  let maxMatched = 0;\n  let rules = undefined;\n  let udts = undefined;\n  let opcodes = undefined;\n  let chars = undefined;\n  let sysData = new systemData();\n  let ruleCallbacks = undefined;\n  let udtCallbacks = undefined;\n  let userData = undefined;\n  const clear = () => {\n    lookAhead = 0;\n    treeDepth = 0;\n    maxTreeDepth = 0;\n    nodeHits = 0;\n    maxMatched = 0;\n    rules = undefined;\n    udts = undefined;\n    opcodes = undefined;\n    chars = undefined;\n    sysData.refresh();\n    ruleCallbacks = undefined;\n    udtCallbacks = undefined;\n    userData = undefined;\n  };\n  const initializeCallbacks = () => {\n    const functionName = `${thisFileName}initializeCallbacks(): `;\n    let i;\n    ruleCallbacks = [];\n    udtCallbacks = [];\n    for (i = 0; i < rules.length; i += 1) {\n      ruleCallbacks[i] = undefined;\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      udtCallbacks[i] = undefined;\n    }\n    let func;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    for (const index in p.callbacks) {\n      if (p.callbacks.hasOwnProperty(index)) {\n        i = list.indexOf(index.toLowerCase());\n        if (i < 0) {\n          throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\n        }\n        func = p.callbacks[index] ? p.callbacks[index] : undefined;\n        if (typeof func === 'function' || func === undefined) {\n          if (i < rules.length) {\n            ruleCallbacks[i] = func;\n          } else {\n            udtCallbacks[i - rules.length] = func;\n          }\n        } else {\n          throw new Error(`${functionName}syntax callback[${index}] must be function reference or falsy)`);\n        }\n      }\n    }\n  };\n  p.parse = (grammar, startName, inputString, callbackData) => {\n    const functionName = `${thisFileName}parse(): `;\n    clear();\n    chars = utils.stringToChars(inputString);\n    rules = grammar.rules;\n    udts = grammar.udts;\n    const lower = startName.toLowerCase();\n    let startIndex = undefined;\n    for (const i in rules) {\n      if (rules.hasOwnProperty(i)) {\n        if (lower === rules[i].lower) {\n          startIndex = rules[i].index;\n          break;\n        }\n      }\n    }\n    if (startIndex === undefined) {\n      throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\n    }\n    initializeCallbacks();\n    if (p.trace) {\n      p.trace.init(rules, udts, chars);\n    }\n    if (p.stats) {\n      p.stats.init(rules, udts);\n    }\n    if (p.ast) {\n      p.ast.init(rules, udts, chars);\n    }\n    userData = callbackData;\n    /* create a dummy opcode for the start rule */\n    opcodes = [{\n      type: id.RNM,\n      index: startIndex\n    }];\n    /* execute the start rule */\n    opExecute(0, 0);\n    opcodes = undefined;\n    /* test and return the sysData */\n    let success = false;\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${functionName}final state should never be 'ACTIVE'`);\n      case id.NOMATCH:\n        success = false;\n        break;\n      case id.EMPTY:\n      case id.MATCH:\n        if (sysData.phraseLength === chars.length) {\n          success = true;\n        } else {\n          success = false;\n        }\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    return {\n      success,\n      state: sysData.state,\n      stateName: id.idName(sysData.state),\n      length: chars.length,\n      matched: sysData.phraseLength,\n      maxMatched,\n      maxTreeDepth,\n      nodeHits\n    };\n  };\n  // The `ALT` operator.<br>\n  // Executes its child nodes, from left to right, until it finds a match.\n  // Fails if *all* of its child nodes fail.\n  const opALT = (opIndex, phraseIndex) => {\n    const op = opcodes[opIndex];\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], phraseIndex);\n      if (sysData.state !== id.NOMATCH) {\n        break;\n      }\n    }\n  };\n  // The `CAT` operator.<br>\n  // Executes all of its child nodes, from left to right,\n  // concatenating the matched phrases.\n  // Fails if *any* child nodes fail.\n  const opCAT = (opIndex, phraseIndex) => {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catPhrase;\n    const op = opcodes[opIndex];\n    if (p.ast) {\n      astLength = p.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catPhrase = 0;\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], catCharIndex);\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      } else {\n        catCharIndex += sysData.phraseLength;\n        catPhrase += sysData.phraseLength;\n      }\n    }\n    if (success) {\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      if (p.ast) {\n        p.ast.setLength(astLength);\n      }\n    }\n  };\n  // The `REP` operator.<br>\n  // Repeatedly executes its single child node,\n  // concatenating each of the matched phrases found.\n  // The number of repetitions executed and its final sysData depends\n  // on its `min` & `max` repetition values.\n  const opREP = (opIndex, phraseIndex) => {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    if (op.max === 0) {\n      // this is an empty-string acceptor\n      // deprecated: use the TLS empty string operator, \"\", instead\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    if (p.ast) {\n      astLength = p.ast.getLength();\n    }\n    while (1) {\n      if (repCharIndex >= chars.length) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex += sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      if (p.ast) {\n        p.ast.setLength(astLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get them right\n  // but `RNM` fails if not.\n  const validateRnmCallbackResult = (rule, sysData, charsLeft, down) => {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        if (!down) {\n          throw new Error(`${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`);\n        }\n        break;\n      case id.EMPTY:\n        sysData.phraseLength = 0;\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          sysData.state = id.EMPTY;\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(`${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`);\n    }\n  };\n  // The `RNM` operator.<br>\n  // This operator will acts as a root node for a parse tree branch below and\n  // returns the matched phrase to its parent.\n  // However, its larger responsibility is handling user-defined callback functions and `AST` nodes.\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n  const opRNM = (opIndex, phraseIndex) => {\n    let astLength;\n    let astDefined;\n    let savedOpcodes;\n    const op = opcodes[opIndex];\n    const rule = rules[op.index];\n    const callback = ruleCallbacks[rule.index];\n    /* ignore AST in look ahead (AND or NOT operator above) */\n    if (!lookAhead) {\n      astDefined = p.ast && p.ast.ruleDefined(op.index);\n      if (astDefined) {\n        astLength = p.ast.getLength();\n        p.ast.down(op.index, rules[op.index].name);\n      }\n    }\n    if (callback) {\n      /* call user's callback going down the parse tree*/\n      const charsLeft = chars.length - phraseIndex;\n      callback(sysData, chars, phraseIndex, userData);\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\n      if (sysData.state === id.ACTIVE) {\n        savedOpcodes = opcodes;\n        opcodes = rule.opcodes;\n        opExecute(0, phraseIndex);\n        opcodes = savedOpcodes;\n        /* call user's callback going up the parse tree*/\n        callback(sysData, chars, phraseIndex, userData);\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\n    } else {\n      /* no callback - just execute the rule */\n      savedOpcodes = opcodes;\n      opcodes = rule.opcodes;\n      opExecute(0, phraseIndex, sysData);\n      opcodes = savedOpcodes;\n    }\n    if (!lookAhead) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          p.ast.setLength(astLength);\n        } else {\n          p.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n    }\n  };\n  // The `TRG` operator.<br>\n  // Succeeds if the single first character of the phrase is\n  // within the `min - max` range.\n  const opTRG = (opIndex, phraseIndex) => {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (phraseIndex < chars.length) {\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The `TBS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // All characters must match exactly.\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n  // operators by `apg`.\n  // Phrase length of zero is not allowed.\n  // Empty phrases can only be defined with `TLS` operators.\n  const opTBS = (opIndex, phraseIndex) => {\n    const op = opcodes[opIndex];\n    const len = op.string.length;\n    sysData.state = id.NOMATCH;\n    if (phraseIndex + len <= chars.length) {\n      for (let i = 0; i < len; i += 1) {\n        if (chars[phraseIndex + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `TLS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\n  // `TLS` is the only operator that explicitly allows empty phrases.\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\n  const opTLS = (opIndex, phraseIndex) => {\n    let code;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= chars.length) {\n      for (let i = 0; i < len; i += 1) {\n        code = chars[phraseIndex + i];\n        if (code >= 65 && code <= 90) {\n          code += 32;\n        }\n        if (code !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get it right but `UDT` fails if not.\n  const validateUdtCallbackResult = (udt, sysData, charsLeft) => {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${thisFileName}opUDT(${udt.name}) ACTIVE state return not allowed.`);\n      case id.EMPTY:\n        if (udt.empty) {\n          sysData.phraseLength = 0;\n        } else {\n          throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);\n        }\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          if (udt.empty) {\n            sysData.state = id.EMPTY;\n          } else {\n            throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);\n          }\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`);\n    }\n  };\n  // The `UDT` operator.<br>\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n  // and back referencing.\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n  // for `AST` nodes and back referencing.\n  // See [`ast.js`](./ast.html) for usage.\n  const opUDT = (opIndex, phraseIndex) => {\n    let astLength;\n    let astIndex;\n    let astDefined;\n    const op = opcodes[opIndex];\n    const udt = udts[op.index];\n    sysData.UdtIndex = udt.index;\n    /* ignore AST in look ahead */\n    if (!lookAhead) {\n      astDefined = p.ast && p.ast.udtDefined(op.index);\n      if (astDefined) {\n        astIndex = rules.length + op.index;\n        astLength = p.ast.getLength();\n        p.ast.down(astIndex, udt.name);\n      }\n    }\n    /* call the UDT */\n    const charsLeft = chars.length - phraseIndex;\n    udtCallbacks[op.index](sysData, chars, phraseIndex, userData);\n    validateUdtCallbackResult(udt, sysData, charsLeft);\n    if (!lookAhead) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          p.ast.setLength(astLength);\n        } else {\n          p.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n    }\n  };\n  // The `AND` operator.<br>\n  // This is the positive `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it succeedsand NOMATCH if it fails.\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\n  const opAND = (opIndex, phraseIndex) => {\n    lookAhead += 1;\n    opExecute(opIndex + 1, phraseIndex);\n    lookAhead -= 1;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opAND: invalid state ${sysData.state}`);\n    }\n  };\n  // The `NOT` operator.<br>\n  // This is the negative `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it *fails* and NOMATCH if it succeeds.\n  // *Always* backtracks on any matched phrase and returns EMPTY\n  // on success (failure of its child node).\n  const opNOT = (opIndex, phraseIndex) => {\n    lookAhead += 1;\n    opExecute(opIndex + 1, phraseIndex);\n    lookAhead -= 1;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opNOT: invalid state ${sysData.state}`);\n    }\n  };\n  const opExecute = (opIndex, phraseIndex) => {\n    const functionName = `${thisFileName}opExecute(): `;\n    const op = opcodes[opIndex];\n    nodeHits += 1;\n    if (treeDepth > maxTreeDepth) {\n      maxTreeDepth = treeDepth;\n    }\n    treeDepth += 1;\n    sysData.refresh();\n    if (p.trace) {\n      p.trace.down(op, phraseIndex);\n    }\n    switch (op.type) {\n      case id.ALT:\n        opALT(opIndex, phraseIndex);\n        break;\n      case id.CAT:\n        opCAT(opIndex, phraseIndex);\n        break;\n      case id.REP:\n        opREP(opIndex, phraseIndex);\n        break;\n      case id.RNM:\n        opRNM(opIndex, phraseIndex);\n        break;\n      case id.TRG:\n        opTRG(opIndex, phraseIndex);\n        break;\n      case id.TBS:\n        opTBS(opIndex, phraseIndex);\n        break;\n      case id.TLS:\n        opTLS(opIndex, phraseIndex);\n        break;\n      case id.UDT:\n        opUDT(opIndex, phraseIndex);\n        break;\n      case id.AND:\n        opAND(opIndex, phraseIndex);\n        break;\n      case id.NOT:\n        opNOT(opIndex, phraseIndex);\n        break;\n      default:\n        throw new Error(`${functionName}unrecognized operator`);\n    }\n    if (!lookAhead) {\n      if (phraseIndex + sysData.phraseLength > maxMatched) {\n        maxMatched = phraseIndex + sysData.phraseLength;\n      }\n    }\n    if (p.stats) {\n      p.stats.collect(op, sysData);\n    }\n    if (p.trace) {\n      p.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength);\n    }\n    treeDepth -= 1;\n  };\n};\nconst Ast = function fnast() {\n  const thisFileName = 'parser.js: Ast()): ';\n  const id = identifiers;\n  const utils = utilities;\n  const a = this;\n  let rules = undefined;\n  let udts = undefined;\n  let chars = undefined;\n  let nodeCount = 0;\n  const nodeCallbacks = [];\n  const stack = [];\n  const records = [];\n  a.callbacks = [];\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\n  a.init = (rulesIn, udtsIn, charsIn) => {\n    stack.length = 0;\n    records.length = 0;\n    nodeCount = 0;\n    rules = rulesIn;\n    udts = udtsIn;\n    chars = charsIn;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    nodeCount = rules.length + udts.length;\n    for (i = 0; i < nodeCount; i += 1) {\n      nodeCallbacks[i] = undefined;\n    }\n    for (const index in a.callbacks) {\n      if (a.callbacks.hasOwnProperty(index)) {\n        const lower = index.toLowerCase();\n        i = list.indexOf(lower);\n        if (i < 0) {\n          throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\n        }\n        nodeCallbacks[i] = a.callbacks[index];\n      }\n    }\n  };\n  /* AST node rule callbacks - called by the parser's `RNM` operator */\n  a.ruleDefined = index => !!nodeCallbacks[index];\n  /* AST node UDT callbacks - called by the parser's `UDT` operator */\n  a.udtDefined = index => !!nodeCallbacks[rules.length + index];\n  /* called by the parser's `RNM` & `UDT` operators\n     builds a record for the downward traversal of the node */\n  a.down = (callbackIndex, name) => {\n    const thisIndex = records.length;\n    stack.push(thisIndex);\n    records.push({\n      name,\n      thisIndex,\n      thatIndex: undefined,\n      state: id.SEM_PRE,\n      callbackIndex,\n      phraseIndex: undefined,\n      phraseLength: undefined,\n      stack: stack.length\n    });\n    return thisIndex;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the upward traversal of the node */\n  a.up = (callbackIndex, name, phraseIndex, phraseLength) => {\n    const thisIndex = records.length;\n    const thatIndex = stack.pop();\n    records.push({\n      name,\n      thisIndex,\n      thatIndex,\n      state: id.SEM_POST,\n      callbackIndex,\n      phraseIndex,\n      phraseLength,\n      stack: stack.length\n    });\n    records[thatIndex].thatIndex = thisIndex;\n    records[thatIndex].phraseIndex = phraseIndex;\n    records[thatIndex].phraseLength = phraseLength;\n    return thisIndex;\n  };\n  // Called by the user to translate the AST.\n  // Translate means to associate or apply some semantic action to the\n  // phrases that were syntactically matched to the AST nodes according\n  // to the defining grammar.\n  // ```\n  // data - optional user-defined data\n  //        passed to the callback functions by the translator\n  // ```\n  a.translate = data => {\n    let ret;\n    let callback;\n    let record;\n    for (let i = 0; i < records.length; i += 1) {\n      record = records[i];\n      callback = nodeCallbacks[record.callbackIndex];\n      if (callback) {\n        if (record.state === id.SEM_PRE) {\n          callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n        } else if (callback) {\n          callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n        }\n      }\n    }\n  };\n  /* called by the parser to reset the length of the records array */\n  /* necessary on backtracking */\n  a.setLength = length => {\n    records.length = length;\n    if (length > 0) {\n      stack.length = records[length - 1].stack;\n    } else {\n      stack.length = 0;\n    }\n  };\n  /* called by the parser to get the length of the records array */\n  a.getLength = () => records.length;\n  /* helper for XML display */\n  function indent(n) {\n    let ret = '';\n    while (n-- > 0) {\n      ret += ' ';\n    }\n    return ret;\n  }\n  // Generate an `XML` version of the AST.\n  // Useful if you want to use a special or favorite XML parser to translate the\n  // AST. Node data are JavaScript strings.\n  a.toXml = () => {\n    let xml = '';\n    let depth = 0;\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n    xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\n    xml += `<!-- input string -->\\n`;\n    xml += indent(depth + 2);\n    xml += utils.charsToString(chars);\n    xml += '\\n';\n    records.forEach(rec => {\n      if (rec.state === id.SEM_PRE) {\n        depth += 1;\n        xml += indent(depth);\n        xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\n        xml += indent(depth + 2);\n        xml += utils.charsToString(chars, rec.phraseIndex, rec.phraseLength);\n        xml += '\\n';\n      } else {\n        xml += indent(depth);\n        xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\n        depth -= 1;\n      }\n    });\n    xml += '</root>\\n';\n    return xml;\n  };\n};\nconst Trace = function fntrace() {\n  const id = identifiers;\n  const utils = utilities;\n  const thisFile = 'parser.js: Trace(): ';\n  let chars = undefined;\n  let rules = undefined;\n  let udts = undefined;\n  let out = '';\n  let treeDepth = 0;\n  const MAX_PHRASE = 100;\n  const t = this;\n  const indent = n => {\n    let ret = '';\n    let count = 0;\n    if (n >= 0) {\n      while (n--) {\n        count += 1;\n        if (count === 5) {\n          ret += '|';\n          count = 0;\n        } else {\n          ret += '.';\n        }\n      }\n    }\n    return ret;\n  };\n  t.init = (r, u, c) => {\n    rules = r;\n    udts = u;\n    chars = c;\n  };\n  const opName = op => {\n    let name;\n    switch (op.type) {\n      case id.ALT:\n        name = 'ALT';\n        break;\n      case id.CAT:\n        name = 'CAT';\n        break;\n      case id.REP:\n        if (op.max === Infinity) {\n          name = `REP(${op.min},inf)`;\n        } else {\n          name = `REP(${op.min},${op.max})`;\n        }\n        break;\n      case id.RNM:\n        name = `RNM(${rules[op.index].name})`;\n        break;\n      case id.TRG:\n        name = `TRG(${op.min},${op.max})`;\n        break;\n      case id.TBS:\n        if (op.string.length > 6) {\n          name = `TBS(${utils.charsToString(op.string, 0, 3)}...)`;\n        } else {\n          name = `TBS(${utils.charsToString(op.string, 0, 6)})`;\n        }\n        break;\n      case id.TLS:\n        if (op.string.length > 6) {\n          name = `TLS(${utils.charsToString(op.string, 0, 3)}...)`;\n        } else {\n          name = `TLS(${utils.charsToString(op.string, 0, 6)})`;\n        }\n        break;\n      case id.UDT:\n        name = `UDT(${udts[op.index].name})`;\n        break;\n      case id.AND:\n        name = 'AND';\n        break;\n      case id.NOT:\n        name = 'NOT';\n        break;\n      default:\n        throw new Error(`${thisFile}Trace: opName: unrecognized opcode`);\n    }\n    return name;\n  };\n  t.down = (op, offset) => {\n    const lead = indent(treeDepth);\n    const len = Math.min(MAX_PHRASE, chars.length - offset);\n    let phrase = utils.charsToString(chars, offset, len);\n    if (len < chars.length - offset) {\n      phrase += '...';\n    }\n    phrase = `${lead}|-|[${opName(op)}]${phrase}\\n`;\n    out += phrase;\n    treeDepth += 1;\n  };\n  t.up = (op, state, offset, phraseLength) => {\n    const thisFunc = `${thisFile}trace.up: `;\n    treeDepth -= 1;\n    const lead = indent(treeDepth);\n    let len;\n    let phrase;\n    let st;\n    switch (state) {\n      case id.EMPTY:\n        st = '|E|';\n        phrase = `''`;\n        break;\n      case id.MATCH:\n        st = '|M|';\n        len = Math.min(MAX_PHRASE, phraseLength);\n        if (len < phraseLength) {\n          phrase = `'${utils.charsToString(chars, offset, len)}...'`;\n        } else {\n          phrase = `'${utils.charsToString(chars, offset, len)}'`;\n        }\n        break;\n      case id.NOMATCH:\n        st = '|N|';\n        phrase = '';\n        break;\n      default:\n        throw new Error(`${thisFunc} unrecognized state`);\n    }\n    phrase = `${lead}${st}[${opName(op)}]${phrase}\\n`;\n    out += phrase;\n  };\n  t.displayTrace = () => out;\n};\nconst Stats = function fnstats() {\n  const id = identifiers;\n  const thisFileName = 'parser.js: Stats(): ';\n  let rules;\n  let udts;\n  let totals;\n  const stats = [];\n  const ruleStats = [];\n  const udtStats = [];\n  /* called by parser to initialize the stats */\n  this.init = (r, u) => {\n    rules = r;\n    udts = u;\n    clear();\n  };\n  /* This function is the main interaction with the parser. */\n  /* The parser calls it after each node has been traversed. */\n  this.collect = (op, sys) => {\n    incStat(totals, sys.state, sys.phraseLength);\n    incStat(stats[op.type], sys.state, sys.phraseLength);\n    if (op.type === id.RNM) {\n      incStat(ruleStats[op.index], sys.state, sys.phraseLength);\n    }\n    if (op.type === id.UDT) {\n      incStat(udtStats[op.index], sys.state, sys.phraseLength);\n    }\n  };\n  this.displayStats = () => {\n    let out = '';\n    const totals = {\n      match: 0,\n      empty: 0,\n      nomatch: 0,\n      total: 0\n    };\n    const displayRow = (op, m, e, n, t) => {\n      totals.match += m;\n      totals.empty += e;\n      totals.nomatch += n;\n      totals.total += t;\n      const mm = normalize(m);\n      const ee = normalize(e);\n      const nn = normalize(n);\n      const tt = normalize(t);\n      return `${op} | ${mm} | ${ee} | ${nn} | ${tt} |\\n`;\n    };\n    out += '          OPERATOR STATS\\n';\n    out += '      |   MATCH |   EMPTY | NOMATCH |   TOTAL |\\n';\n    out += displayRow('  ALT', stats[id.ALT].match, stats[id.ALT].empty, stats[id.ALT].nomatch, stats[id.ALT].total);\n    out += displayRow('  CAT', stats[id.CAT].match, stats[id.CAT].empty, stats[id.CAT].nomatch, stats[id.CAT].total);\n    out += displayRow('  REP', stats[id.REP].match, stats[id.REP].empty, stats[id.REP].nomatch, stats[id.REP].total);\n    out += displayRow('  RNM', stats[id.RNM].match, stats[id.RNM].empty, stats[id.RNM].nomatch, stats[id.RNM].total);\n    out += displayRow('  TRG', stats[id.TRG].match, stats[id.TRG].empty, stats[id.TRG].nomatch, stats[id.TRG].total);\n    out += displayRow('  TBS', stats[id.TBS].match, stats[id.TBS].empty, stats[id.TBS].nomatch, stats[id.TBS].total);\n    out += displayRow('  TLS', stats[id.TLS].match, stats[id.TLS].empty, stats[id.TLS].nomatch, stats[id.TLS].total);\n    out += displayRow('  UDT', stats[id.UDT].match, stats[id.UDT].empty, stats[id.UDT].nomatch, stats[id.UDT].total);\n    out += displayRow('  AND', stats[id.AND].match, stats[id.AND].empty, stats[id.AND].nomatch, stats[id.AND].total);\n    out += displayRow('  NOT', stats[id.NOT].match, stats[id.NOT].empty, stats[id.NOT].nomatch, stats[id.NOT].total);\n    out += displayRow('TOTAL', totals.match, totals.empty, totals.nomatch, totals.total);\n    return out;\n  };\n  /*\n  Display rule/udt\n  */\n  this.displayHits = type => {\n    let out = '';\n    const displayRow = (m, e, n, t, name) => {\n      totals.match += m;\n      totals.empty += e;\n      totals.nomatch += n;\n      totals.total += t;\n      const mm = normalize(m);\n      const ee = normalize(e);\n      const nn = normalize(n);\n      const tt = normalize(t);\n      return `| ${mm} | ${ee} | ${nn} | ${tt} | ${name}\\n`;\n    };\n    if (typeof type === 'string' && type.toLowerCase()[0] === 'a') {\n      ruleStats.sort(sortAlpha);\n      udtStats.sort(sortAlpha);\n      out += '    RULES/UDTS ALPHABETICALLY\\n';\n    } else if (typeof type === 'string' && type.toLowerCase()[0] === 'i') {\n      ruleStats.sort(sortIndex);\n      udtStats.sort(sortIndex);\n      out += '    RULES/UDTS BY INDEX\\n';\n    } else {\n      ruleStats.sort(sortHits);\n      udtStats.sort(sortHits);\n      out += '    RULES/UDTS BY HIT COUNT\\n';\n    }\n    out += '|   MATCH |   EMPTY | NOMATCH |   TOTAL | NAME\\n';\n    for (let i = 0; i < ruleStats.length; i += 1) {\n      let r = ruleStats[i];\n      if (r.total) {\n        out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);\n      }\n    }\n    for (let i = 0; i < udtStats.length; i += 1) {\n      let r = udtStats[i];\n      if (r.total) {\n        out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);\n      }\n    }\n    return out;\n  };\n  const normalize = n => {\n    if (n < 10) {\n      return `      ${n}`;\n    }\n    if (n < 100) {\n      return `     ${n}`;\n    }\n    if (n < 1000) {\n      return `    ${n}`;\n    }\n    if (n < 10000) {\n      return `   ${n}`;\n    }\n    if (n < 100000) {\n      return `  ${n}`;\n    }\n    if (n < 1000000) {\n      return ` ${n}`;\n    }\n    return `${n}`;\n  };\n  const sortAlpha = (lhs, rhs) => {\n    if (lhs.lower < rhs.lower) {\n      return -1;\n    }\n    if (lhs.lower > rhs.lower) {\n      return 1;\n    }\n    return 0;\n  };\n  const sortHits = (lhs, rhs) => {\n    if (lhs.total < rhs.total) {\n      return 1;\n    }\n    if (lhs.total > rhs.total) {\n      return -1;\n    }\n    return sortAlpha(lhs, rhs);\n  };\n  const sortIndex = (lhs, rhs) => {\n    if (lhs.index < rhs.index) {\n      return -1;\n    }\n    if (lhs.index > rhs.index) {\n      return 1;\n    }\n    return 0;\n  };\n  const EmptyStat = function fnempty() {\n    this.empty = 0;\n    this.match = 0;\n    this.nomatch = 0;\n    this.total = 0;\n  };\n  /* Zero out all stats */\n  const clear = () => {\n    stats.length = 0;\n    totals = new EmptyStat();\n    stats[id.ALT] = new EmptyStat();\n    stats[id.CAT] = new EmptyStat();\n    stats[id.REP] = new EmptyStat();\n    stats[id.RNM] = new EmptyStat();\n    stats[id.TRG] = new EmptyStat();\n    stats[id.TBS] = new EmptyStat();\n    stats[id.TLS] = new EmptyStat();\n    stats[id.UDT] = new EmptyStat();\n    stats[id.AND] = new EmptyStat();\n    stats[id.NOT] = new EmptyStat();\n    ruleStats.length = 0;\n    for (let i = 0; i < rules.length; i += 1) {\n      ruleStats.push({\n        empty: 0,\n        match: 0,\n        nomatch: 0,\n        total: 0,\n        name: rules[i].name,\n        lower: rules[i].lower,\n        index: rules[i].index\n      });\n    }\n    if (udts.length > 0) {\n      udtStats.length = 0;\n      for (let i = 0; i < udts.length; i += 1) {\n        udtStats.push({\n          empty: 0,\n          match: 0,\n          nomatch: 0,\n          total: 0,\n          name: udts[i].name,\n          lower: udts[i].lower,\n          index: udts[i].index\n        });\n      }\n    }\n  };\n  /* increment the designated operator hit count by one */\n  const incStat = (stat, state) => {\n    stat.total += 1;\n    switch (state) {\n      case id.EMPTY:\n        stat.empty += 1;\n        break;\n      case id.MATCH:\n        stat.match += 1;\n        break;\n      case id.NOMATCH:\n        stat.nomatch += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\n    }\n  };\n};\nconst utilities = {\n  // utility functions\n  stringToChars: string => [...string].map(cp => cp.codePointAt(0)),\n  charsToString: (chars, beg, len) => {\n    let subChars = chars;\n    while (1) {\n      if (beg === undefined || beg < 0) {\n        break;\n      }\n      if (len === undefined) {\n        subChars = chars.slice(beg);\n        break;\n      }\n      if (len <= 0) {\n        // always an empty string\n        return '';\n      }\n      subChars = chars.slice(beg, beg + len);\n      break;\n    }\n    return String.fromCodePoint(...subChars);\n  }\n};\nconst identifiers = {\n  // Identifies the operator type.\n  // NB: These must match the values in apg-js 4.3.0, apg-lib/identifiers.\n  /* the original ABNF operators */\n  ALT: 1 /* alternation */,\n  CAT: 2 /* concatenation */,\n  REP: 3 /* repetition */,\n  RNM: 4 /* rule name */,\n  TRG: 5 /* terminal range */,\n  TBS: 6 /* terminal binary string, case sensitive */,\n  TLS: 7 /* terminal literal string, case insensitive */,\n\n  /* the super set, SABNF operators */\n  UDT: 11 /* user-defined terminal */,\n  AND: 12 /* positive look ahead */,\n  NOT: 13 /* negative look ahead */,\n\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\n  // Identifies the parser state as it traverses the parse tree nodes.\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n  ACTIVE: 100,\n  MATCH: 101,\n  EMPTY: 102,\n  NOMATCH: 103,\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n  // to indicate the direction of flow through the `AST` nodes.\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n  SEM_PRE: 200,\n  SEM_POST: 201,\n  // Ignored. Retained for backwords compatibility.\n  SEM_OK: 300,\n  idName: s => {\n    switch (s) {\n      case identifiers.ALT:\n        return 'ALT';\n      case identifiers.CAT:\n        return 'CAT';\n      case identifiers.REP:\n        return 'REP';\n      case identifiers.RNM:\n        return 'RNM';\n      case identifiers.TRG:\n        return 'TRG';\n      case identifiers.TBS:\n        return 'TBS';\n      case identifiers.TLS:\n        return 'TLS';\n      case identifiers.UDT:\n        return 'UDT';\n      case identifiers.AND:\n        return 'AND';\n      case identifiers.NOT:\n        return 'NOT';\n      case identifiers.ACTIVE:\n        return 'ACTIVE';\n      case identifiers.EMPTY:\n        return 'EMPTY';\n      case identifiers.MATCH:\n        return 'MATCH';\n      case identifiers.NOMATCH:\n        return 'NOMATCH';\n      case identifiers.SEM_PRE:\n        return 'SEM_PRE';\n      case identifiers.SEM_POST:\n        return 'SEM_POST';\n      case identifiers.SEM_OK:\n        return 'SEM_OK';\n      default:\n        return 'UNRECOGNIZED STATE';\n    }\n  }\n};","map":{"version":3,"names":["Parser","Ast","Trace","Stats","utilities","identifiers","fnparser","id","utils","p","thisFileName","systemData","state","ACTIVE","phraseLength","refresh","ast","undefined","stats","trace","callbacks","lookAhead","treeDepth","maxTreeDepth","nodeHits","maxMatched","rules","udts","opcodes","chars","sysData","ruleCallbacks","udtCallbacks","userData","clear","initializeCallbacks","functionName","i","length","func","list","push","lower","index","hasOwnProperty","indexOf","toLowerCase","Error","parse","grammar","startName","inputString","callbackData","stringToChars","startIndex","startRule","init","type","RNM","opExecute","success","NOMATCH","EMPTY","MATCH","stateName","idName","matched","opALT","opIndex","phraseIndex","op","children","opCAT","astLength","catCharIndex","catPhrase","getLength","setLength","opREP","repCharIndex","repPhrase","repCount","max","min","validateRnmCallbackResult","rule","charsLeft","down","str","name","opRNM","astDefined","savedOpcodes","callback","ruleDefined","up","opTRG","opTBS","len","string","opTLS","code","validateUdtCallbackResult","udt","empty","opUDT","astIndex","UdtIndex","udtDefined","opAND","opNOT","ALT","CAT","REP","TRG","TBS","TLS","UDT","AND","NOT","collect","fnast","a","nodeCount","nodeCallbacks","stack","records","rulesIn","udtsIn","charsIn","callbackIndex","thisIndex","thatIndex","SEM_PRE","pop","SEM_POST","translate","data","ret","record","indent","n","toXml","xml","depth","charsToString","forEach","rec","fntrace","thisFile","out","MAX_PHRASE","t","count","r","u","c","opName","Infinity","offset","lead","Math","phrase","thisFunc","st","displayTrace","fnstats","totals","ruleStats","udtStats","sys","incStat","displayStats","match","nomatch","total","displayRow","m","e","mm","normalize","ee","nn","tt","displayHits","sort","sortAlpha","sortIndex","sortHits","lhs","rhs","EmptyStat","fnempty","stat","map","cp","codePointAt","beg","subChars","slice","String","fromCodePoint","SEM_OK","s"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/apg-lite/lib/parser.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *\n *    Redistribution and use in source and binary forms, with or without\n *    modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this\n *       list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice,\n *       this list of conditions and the following disclaimer in the documentation\n *       and/or other materials provided with the distribution.\n *\n *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n *    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n *    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n *    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n *    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n *    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *   ********************************************************************************* */\nexport { Parser, Ast, Trace, Stats, utilities, identifiers };\n\nconst Parser = function fnparser() {\n  const id = identifiers;\n  const utils = utilities;\n  const p = this;\n  const thisFileName = 'parser.js: Parser(): ';\n  const systemData = function systemData() {\n    this.state = id.ACTIVE;\n    this.phraseLength = 0;\n    this.refresh = () => {\n      this.state = id.ACTIVE;\n      this.phraseLength = 0;\n    };\n  };\n  p.ast = undefined;\n  p.stats = undefined;\n  p.trace = undefined;\n  p.callbacks = [];\n  let lookAhead = 0;\n  let treeDepth = 0;\n  let maxTreeDepth = 0;\n  let nodeHits = 0;\n  let maxMatched = 0;\n  let rules = undefined;\n  let udts = undefined;\n  let opcodes = undefined;\n  let chars = undefined;\n  let sysData = new systemData();\n  let ruleCallbacks = undefined;\n  let udtCallbacks = undefined;\n  let userData = undefined;\n  const clear = () => {\n    lookAhead = 0;\n    treeDepth = 0;\n    maxTreeDepth = 0;\n    nodeHits = 0;\n    maxMatched = 0;\n    rules = undefined;\n    udts = undefined;\n    opcodes = undefined;\n    chars = undefined;\n    sysData.refresh();\n    ruleCallbacks = undefined;\n    udtCallbacks = undefined;\n    userData = undefined;\n  };\n\n  const initializeCallbacks = () => {\n    const functionName = `${thisFileName}initializeCallbacks(): `;\n    let i;\n    ruleCallbacks = [];\n    udtCallbacks = [];\n    for (i = 0; i < rules.length; i += 1) {\n      ruleCallbacks[i] = undefined;\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      udtCallbacks[i] = undefined;\n    }\n    let func;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    for (const index in p.callbacks) {\n      if (p.callbacks.hasOwnProperty(index)) {\n        i = list.indexOf(index.toLowerCase());\n        if (i < 0) {\n          throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\n        }\n        func = p.callbacks[index] ? p.callbacks[index] : undefined;\n        if (typeof func === 'function' || func === undefined) {\n          if (i < rules.length) {\n            ruleCallbacks[i] = func;\n          } else {\n            udtCallbacks[i - rules.length] = func;\n          }\n        } else {\n          throw new Error(`${functionName}syntax callback[${index}] must be function reference or falsy)`);\n        }\n      }\n    }\n  };\n\n  p.parse = (grammar, startName, inputString, callbackData) => {\n    const functionName = `${thisFileName}parse(): `;\n    clear();\n    chars = utils.stringToChars(inputString);\n    rules = grammar.rules;\n    udts = grammar.udts;\n    const lower = startName.toLowerCase();\n    let startIndex = undefined;\n    for (const i in rules) {\n      if (rules.hasOwnProperty(i)) {\n        if (lower === rules[i].lower) {\n          startIndex = rules[i].index;\n          break;\n        }\n      }\n    }\n    if (startIndex === undefined) {\n      throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\n    }\n    initializeCallbacks();\n    if (p.trace) {\n      p.trace.init(rules, udts, chars);\n    }\n    if (p.stats) {\n      p.stats.init(rules, udts);\n    }\n    if (p.ast) {\n      p.ast.init(rules, udts, chars);\n    }\n    userData = callbackData;\n    /* create a dummy opcode for the start rule */\n    opcodes = [\n      {\n        type: id.RNM,\n        index: startIndex,\n      },\n    ];\n    /* execute the start rule */\n    opExecute(0, 0);\n    opcodes = undefined;\n    /* test and return the sysData */\n    let success = false;\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${functionName}final state should never be 'ACTIVE'`);\n      case id.NOMATCH:\n        success = false;\n        break;\n      case id.EMPTY:\n      case id.MATCH:\n        if (sysData.phraseLength === chars.length) {\n          success = true;\n        } else {\n          success = false;\n        }\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    return {\n      success,\n      state: sysData.state,\n      stateName: id.idName(sysData.state),\n      length: chars.length,\n      matched: sysData.phraseLength,\n      maxMatched,\n      maxTreeDepth,\n      nodeHits,\n    };\n  };\n  // The `ALT` operator.<br>\n  // Executes its child nodes, from left to right, until it finds a match.\n  // Fails if *all* of its child nodes fail.\n  const opALT = (opIndex, phraseIndex) => {\n    const op = opcodes[opIndex];\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], phraseIndex);\n      if (sysData.state !== id.NOMATCH) {\n        break;\n      }\n    }\n  };\n  // The `CAT` operator.<br>\n  // Executes all of its child nodes, from left to right,\n  // concatenating the matched phrases.\n  // Fails if *any* child nodes fail.\n  const opCAT = (opIndex, phraseIndex) => {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catPhrase;\n    const op = opcodes[opIndex];\n    if (p.ast) {\n      astLength = p.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catPhrase = 0;\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], catCharIndex);\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      } else {\n        catCharIndex += sysData.phraseLength;\n        catPhrase += sysData.phraseLength;\n      }\n    }\n    if (success) {\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      if (p.ast) {\n        p.ast.setLength(astLength);\n      }\n    }\n  };\n  // The `REP` operator.<br>\n  // Repeatedly executes its single child node,\n  // concatenating each of the matched phrases found.\n  // The number of repetitions executed and its final sysData depends\n  // on its `min` & `max` repetition values.\n  const opREP = (opIndex, phraseIndex) => {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    if (op.max === 0) {\n      // this is an empty-string acceptor\n      // deprecated: use the TLS empty string operator, \"\", instead\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    if (p.ast) {\n      astLength = p.ast.getLength();\n    }\n    while (1) {\n      if (repCharIndex >= chars.length) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex += sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      if (p.ast) {\n        p.ast.setLength(astLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get them right\n  // but `RNM` fails if not.\n  const validateRnmCallbackResult = (rule, sysData, charsLeft, down) => {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        if (!down) {\n          throw new Error(\n            `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`\n          );\n        }\n        break;\n      case id.EMPTY:\n        sysData.phraseLength = 0;\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          sysData.state = id.EMPTY;\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `RNM` operator.<br>\n  // This operator will acts as a root node for a parse tree branch below and\n  // returns the matched phrase to its parent.\n  // However, its larger responsibility is handling user-defined callback functions and `AST` nodes.\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n  const opRNM = (opIndex, phraseIndex) => {\n    let astLength;\n    let astDefined;\n    let savedOpcodes;\n    const op = opcodes[opIndex];\n    const rule = rules[op.index];\n    const callback = ruleCallbacks[rule.index];\n    /* ignore AST in look ahead (AND or NOT operator above) */\n    if (!lookAhead) {\n      astDefined = p.ast && p.ast.ruleDefined(op.index);\n      if (astDefined) {\n        astLength = p.ast.getLength();\n        p.ast.down(op.index, rules[op.index].name);\n      }\n    }\n    if (callback) {\n      /* call user's callback going down the parse tree*/\n      const charsLeft = chars.length - phraseIndex;\n      callback(sysData, chars, phraseIndex, userData);\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\n      if (sysData.state === id.ACTIVE) {\n        savedOpcodes = opcodes;\n        opcodes = rule.opcodes;\n        opExecute(0, phraseIndex);\n        opcodes = savedOpcodes;\n        /* call user's callback going up the parse tree*/\n        callback(sysData, chars, phraseIndex, userData);\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\n    } else {\n      /* no callback - just execute the rule */\n      savedOpcodes = opcodes;\n      opcodes = rule.opcodes;\n      opExecute(0, phraseIndex, sysData);\n      opcodes = savedOpcodes;\n    }\n    if (!lookAhead) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          p.ast.setLength(astLength);\n        } else {\n          p.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n    }\n  };\n  // The `TRG` operator.<br>\n  // Succeeds if the single first character of the phrase is\n  // within the `min - max` range.\n  const opTRG = (opIndex, phraseIndex) => {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (phraseIndex < chars.length) {\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The `TBS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // All characters must match exactly.\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n  // operators by `apg`.\n  // Phrase length of zero is not allowed.\n  // Empty phrases can only be defined with `TLS` operators.\n  const opTBS = (opIndex, phraseIndex) => {\n    const op = opcodes[opIndex];\n    const len = op.string.length;\n    sysData.state = id.NOMATCH;\n    if (phraseIndex + len <= chars.length) {\n      for (let i = 0; i < len; i += 1) {\n        if (chars[phraseIndex + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `TLS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\n  // `TLS` is the only operator that explicitly allows empty phrases.\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\n  const opTLS = (opIndex, phraseIndex) => {\n    let code;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= chars.length) {\n      for (let i = 0; i < len; i += 1) {\n        code = chars[phraseIndex + i];\n        if (code >= 65 && code <= 90) {\n          code += 32;\n        }\n        if (code !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get it right but `UDT` fails if not.\n  const validateUdtCallbackResult = (udt, sysData, charsLeft) => {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${thisFileName}opUDT(${udt.name}) ACTIVE state return not allowed.`);\n      case id.EMPTY:\n        if (udt.empty) {\n          sysData.phraseLength = 0;\n        } else {\n          throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);\n        }\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          if (udt.empty) {\n            sysData.state = id.EMPTY;\n          } else {\n            throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);\n          }\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `UDT` operator.<br>\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n  // and back referencing.\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n  // for `AST` nodes and back referencing.\n  // See [`ast.js`](./ast.html) for usage.\n  const opUDT = (opIndex, phraseIndex) => {\n    let astLength;\n    let astIndex;\n    let astDefined;\n    const op = opcodes[opIndex];\n    const udt = udts[op.index];\n    sysData.UdtIndex = udt.index;\n    /* ignore AST in look ahead */\n    if (!lookAhead) {\n      astDefined = p.ast && p.ast.udtDefined(op.index);\n      if (astDefined) {\n        astIndex = rules.length + op.index;\n        astLength = p.ast.getLength();\n        p.ast.down(astIndex, udt.name);\n      }\n    }\n    /* call the UDT */\n    const charsLeft = chars.length - phraseIndex;\n    udtCallbacks[op.index](sysData, chars, phraseIndex, userData);\n    validateUdtCallbackResult(udt, sysData, charsLeft);\n    if (!lookAhead) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          p.ast.setLength(astLength);\n        } else {\n          p.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n    }\n  };\n  // The `AND` operator.<br>\n  // This is the positive `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it succeedsand NOMATCH if it fails.\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\n  const opAND = (opIndex, phraseIndex) => {\n    lookAhead += 1;\n    opExecute(opIndex + 1, phraseIndex);\n    lookAhead -= 1;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opAND: invalid state ${sysData.state}`);\n    }\n  };\n  // The `NOT` operator.<br>\n  // This is the negative `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it *fails* and NOMATCH if it succeeds.\n  // *Always* backtracks on any matched phrase and returns EMPTY\n  // on success (failure of its child node).\n  const opNOT = (opIndex, phraseIndex) => {\n    lookAhead += 1;\n    opExecute(opIndex + 1, phraseIndex);\n    lookAhead -= 1;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opNOT: invalid state ${sysData.state}`);\n    }\n  };\n\n  const opExecute = (opIndex, phraseIndex) => {\n    const functionName = `${thisFileName}opExecute(): `;\n    const op = opcodes[opIndex];\n    nodeHits += 1;\n    if (treeDepth > maxTreeDepth) {\n      maxTreeDepth = treeDepth;\n    }\n    treeDepth += 1;\n    sysData.refresh();\n    if (p.trace) {\n      p.trace.down(op, phraseIndex);\n    }\n    switch (op.type) {\n      case id.ALT:\n        opALT(opIndex, phraseIndex);\n        break;\n      case id.CAT:\n        opCAT(opIndex, phraseIndex);\n        break;\n      case id.REP:\n        opREP(opIndex, phraseIndex);\n        break;\n      case id.RNM:\n        opRNM(opIndex, phraseIndex);\n        break;\n      case id.TRG:\n        opTRG(opIndex, phraseIndex);\n        break;\n      case id.TBS:\n        opTBS(opIndex, phraseIndex);\n        break;\n      case id.TLS:\n        opTLS(opIndex, phraseIndex);\n        break;\n      case id.UDT:\n        opUDT(opIndex, phraseIndex);\n        break;\n      case id.AND:\n        opAND(opIndex, phraseIndex);\n        break;\n      case id.NOT:\n        opNOT(opIndex, phraseIndex);\n        break;\n      default:\n        throw new Error(`${functionName}unrecognized operator`);\n    }\n    if (!lookAhead) {\n      if (phraseIndex + sysData.phraseLength > maxMatched) {\n        maxMatched = phraseIndex + sysData.phraseLength;\n      }\n    }\n    if (p.stats) {\n      p.stats.collect(op, sysData);\n    }\n    if (p.trace) {\n      p.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength);\n    }\n    treeDepth -= 1;\n  };\n};\n\nconst Ast = function fnast() {\n  const thisFileName = 'parser.js: Ast()): ';\n  const id = identifiers;\n  const utils = utilities;\n  const a = this;\n  let rules = undefined;\n  let udts = undefined;\n  let chars = undefined;\n  let nodeCount = 0;\n  const nodeCallbacks = [];\n  const stack = [];\n  const records = [];\n  a.callbacks = [];\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\n  a.init = (rulesIn, udtsIn, charsIn) => {\n    stack.length = 0;\n    records.length = 0;\n    nodeCount = 0;\n    rules = rulesIn;\n    udts = udtsIn;\n    chars = charsIn;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    nodeCount = rules.length + udts.length;\n    for (i = 0; i < nodeCount; i += 1) {\n      nodeCallbacks[i] = undefined;\n    }\n    for (const index in a.callbacks) {\n      if (a.callbacks.hasOwnProperty(index)) {\n        const lower = index.toLowerCase();\n        i = list.indexOf(lower);\n        if (i < 0) {\n          throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\n        }\n        nodeCallbacks[i] = a.callbacks[index];\n      }\n    }\n  };\n  /* AST node rule callbacks - called by the parser's `RNM` operator */\n  a.ruleDefined = (index) => !!nodeCallbacks[index];\n  /* AST node UDT callbacks - called by the parser's `UDT` operator */\n  a.udtDefined = (index) => !!nodeCallbacks[rules.length + index];\n  /* called by the parser's `RNM` & `UDT` operators\n     builds a record for the downward traversal of the node */\n  a.down = (callbackIndex, name) => {\n    const thisIndex = records.length;\n    stack.push(thisIndex);\n    records.push({\n      name,\n      thisIndex,\n      thatIndex: undefined,\n      state: id.SEM_PRE,\n      callbackIndex,\n      phraseIndex: undefined,\n      phraseLength: undefined,\n      stack: stack.length,\n    });\n    return thisIndex;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the upward traversal of the node */\n  a.up = (callbackIndex, name, phraseIndex, phraseLength) => {\n    const thisIndex = records.length;\n    const thatIndex = stack.pop();\n    records.push({\n      name,\n      thisIndex,\n      thatIndex,\n      state: id.SEM_POST,\n      callbackIndex,\n      phraseIndex,\n      phraseLength,\n      stack: stack.length,\n    });\n    records[thatIndex].thatIndex = thisIndex;\n    records[thatIndex].phraseIndex = phraseIndex;\n    records[thatIndex].phraseLength = phraseLength;\n    return thisIndex;\n  };\n  // Called by the user to translate the AST.\n  // Translate means to associate or apply some semantic action to the\n  // phrases that were syntactically matched to the AST nodes according\n  // to the defining grammar.\n  // ```\n  // data - optional user-defined data\n  //        passed to the callback functions by the translator\n  // ```\n  a.translate = (data) => {\n    let ret;\n    let callback;\n    let record;\n    for (let i = 0; i < records.length; i += 1) {\n      record = records[i];\n      callback = nodeCallbacks[record.callbackIndex];\n      if (callback) {\n        if (record.state === id.SEM_PRE) {\n          callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n        } else if (callback) {\n          callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n        }\n      }\n    }\n  };\n  /* called by the parser to reset the length of the records array */\n  /* necessary on backtracking */\n  a.setLength = (length) => {\n    records.length = length;\n    if (length > 0) {\n      stack.length = records[length - 1].stack;\n    } else {\n      stack.length = 0;\n    }\n  };\n  /* called by the parser to get the length of the records array */\n  a.getLength = () => records.length;\n  /* helper for XML display */\n  function indent(n) {\n    let ret = '';\n    while (n-- > 0) {\n      ret += ' ';\n    }\n    return ret;\n  }\n  // Generate an `XML` version of the AST.\n  // Useful if you want to use a special or favorite XML parser to translate the\n  // AST. Node data are JavaScript strings.\n  a.toXml = () => {\n    let xml = '';\n    let depth = 0;\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n    xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\n    xml += `<!-- input string -->\\n`;\n    xml += indent(depth + 2);\n    xml += utils.charsToString(chars);\n    xml += '\\n';\n    records.forEach((rec) => {\n      if (rec.state === id.SEM_PRE) {\n        depth += 1;\n        xml += indent(depth);\n        xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\n        xml += indent(depth + 2);\n        xml += utils.charsToString(chars, rec.phraseIndex, rec.phraseLength);\n        xml += '\\n';\n      } else {\n        xml += indent(depth);\n        xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\n        depth -= 1;\n      }\n    });\n\n    xml += '</root>\\n';\n    return xml;\n  };\n};\n\nconst Trace = function fntrace() {\n  const id = identifiers;\n  const utils = utilities;\n  const thisFile = 'parser.js: Trace(): ';\n  let chars = undefined;\n  let rules = undefined;\n  let udts = undefined;\n  let out = '';\n  let treeDepth = 0;\n  const MAX_PHRASE = 100;\n  const t = this;\n  const indent = (n) => {\n    let ret = '';\n    let count = 0;\n    if (n >= 0) {\n      while (n--) {\n        count += 1;\n        if (count === 5) {\n          ret += '|';\n          count = 0;\n        } else {\n          ret += '.';\n        }\n      }\n    }\n    return ret;\n  };\n  t.init = (r, u, c) => {\n    rules = r;\n    udts = u;\n    chars = c;\n  };\n  const opName = (op) => {\n    let name;\n    switch (op.type) {\n      case id.ALT:\n        name = 'ALT';\n        break;\n      case id.CAT:\n        name = 'CAT';\n        break;\n      case id.REP:\n        if (op.max === Infinity) {\n          name = `REP(${op.min},inf)`;\n        } else {\n          name = `REP(${op.min},${op.max})`;\n        }\n        break;\n      case id.RNM:\n        name = `RNM(${rules[op.index].name})`;\n        break;\n      case id.TRG:\n        name = `TRG(${op.min},${op.max})`;\n        break;\n      case id.TBS:\n        if (op.string.length > 6) {\n          name = `TBS(${utils.charsToString(op.string, 0, 3)}...)`;\n        } else {\n          name = `TBS(${utils.charsToString(op.string, 0, 6)})`;\n        }\n        break;\n      case id.TLS:\n        if (op.string.length > 6) {\n          name = `TLS(${utils.charsToString(op.string, 0, 3)}...)`;\n        } else {\n          name = `TLS(${utils.charsToString(op.string, 0, 6)})`;\n        }\n        break;\n      case id.UDT:\n        name = `UDT(${udts[op.index].name})`;\n        break;\n      case id.AND:\n        name = 'AND';\n        break;\n      case id.NOT:\n        name = 'NOT';\n        break;\n      default:\n        throw new Error(`${thisFile}Trace: opName: unrecognized opcode`);\n    }\n    return name;\n  };\n  t.down = (op, offset) => {\n    const lead = indent(treeDepth);\n    const len = Math.min(MAX_PHRASE, chars.length - offset);\n    let phrase = utils.charsToString(chars, offset, len);\n    if (len < chars.length - offset) {\n      phrase += '...';\n    }\n    phrase = `${lead}|-|[${opName(op)}]${phrase}\\n`;\n    out += phrase;\n    treeDepth += 1;\n  };\n  t.up = (op, state, offset, phraseLength) => {\n    const thisFunc = `${thisFile}trace.up: `;\n    treeDepth -= 1;\n    const lead = indent(treeDepth);\n    let len;\n    let phrase;\n    let st;\n    switch (state) {\n      case id.EMPTY:\n        st = '|E|';\n        phrase = `''`;\n        break;\n      case id.MATCH:\n        st = '|M|';\n        len = Math.min(MAX_PHRASE, phraseLength);\n        if (len < phraseLength) {\n          phrase = `'${utils.charsToString(chars, offset, len)}...'`;\n        } else {\n          phrase = `'${utils.charsToString(chars, offset, len)}'`;\n        }\n        break;\n      case id.NOMATCH:\n        st = '|N|';\n        phrase = '';\n        break;\n      default:\n        throw new Error(`${thisFunc} unrecognized state`);\n    }\n    phrase = `${lead}${st}[${opName(op)}]${phrase}\\n`;\n    out += phrase;\n  };\n  t.displayTrace = () => out;\n};\n\nconst Stats = function fnstats() {\n  const id = identifiers;\n  const thisFileName = 'parser.js: Stats(): ';\n  let rules;\n  let udts;\n  let totals;\n  const stats = [];\n  const ruleStats = [];\n  const udtStats = [];\n  /* called by parser to initialize the stats */\n  this.init = (r, u) => {\n    rules = r;\n    udts = u;\n    clear();\n  };\n  /* This function is the main interaction with the parser. */\n  /* The parser calls it after each node has been traversed. */\n  this.collect = (op, sys) => {\n    incStat(totals, sys.state, sys.phraseLength);\n    incStat(stats[op.type], sys.state, sys.phraseLength);\n    if (op.type === id.RNM) {\n      incStat(ruleStats[op.index], sys.state, sys.phraseLength);\n    }\n    if (op.type === id.UDT) {\n      incStat(udtStats[op.index], sys.state, sys.phraseLength);\n    }\n  };\n  this.displayStats = () => {\n    let out = '';\n    const totals = {\n      match: 0,\n      empty: 0,\n      nomatch: 0,\n      total: 0,\n    };\n    const displayRow = (op, m, e, n, t) => {\n      totals.match += m;\n      totals.empty += e;\n      totals.nomatch += n;\n      totals.total += t;\n      const mm = normalize(m);\n      const ee = normalize(e);\n      const nn = normalize(n);\n      const tt = normalize(t);\n      return `${op} | ${mm} | ${ee} | ${nn} | ${tt} |\\n`;\n    };\n    out += '          OPERATOR STATS\\n';\n    out += '      |   MATCH |   EMPTY | NOMATCH |   TOTAL |\\n';\n    out += displayRow('  ALT', stats[id.ALT].match, stats[id.ALT].empty, stats[id.ALT].nomatch, stats[id.ALT].total);\n    out += displayRow('  CAT', stats[id.CAT].match, stats[id.CAT].empty, stats[id.CAT].nomatch, stats[id.CAT].total);\n    out += displayRow('  REP', stats[id.REP].match, stats[id.REP].empty, stats[id.REP].nomatch, stats[id.REP].total);\n    out += displayRow('  RNM', stats[id.RNM].match, stats[id.RNM].empty, stats[id.RNM].nomatch, stats[id.RNM].total);\n    out += displayRow('  TRG', stats[id.TRG].match, stats[id.TRG].empty, stats[id.TRG].nomatch, stats[id.TRG].total);\n    out += displayRow('  TBS', stats[id.TBS].match, stats[id.TBS].empty, stats[id.TBS].nomatch, stats[id.TBS].total);\n    out += displayRow('  TLS', stats[id.TLS].match, stats[id.TLS].empty, stats[id.TLS].nomatch, stats[id.TLS].total);\n    out += displayRow('  UDT', stats[id.UDT].match, stats[id.UDT].empty, stats[id.UDT].nomatch, stats[id.UDT].total);\n    out += displayRow('  AND', stats[id.AND].match, stats[id.AND].empty, stats[id.AND].nomatch, stats[id.AND].total);\n    out += displayRow('  NOT', stats[id.NOT].match, stats[id.NOT].empty, stats[id.NOT].nomatch, stats[id.NOT].total);\n    out += displayRow('TOTAL', totals.match, totals.empty, totals.nomatch, totals.total);\n    return out;\n  };\n  /*\n  Display rule/udt\n  */\n  this.displayHits = (type) => {\n    let out = '';\n    const displayRow = (m, e, n, t, name) => {\n      totals.match += m;\n      totals.empty += e;\n      totals.nomatch += n;\n      totals.total += t;\n      const mm = normalize(m);\n      const ee = normalize(e);\n      const nn = normalize(n);\n      const tt = normalize(t);\n      return `| ${mm} | ${ee} | ${nn} | ${tt} | ${name}\\n`;\n    };\n    if (typeof type === 'string' && type.toLowerCase()[0] === 'a') {\n      ruleStats.sort(sortAlpha);\n      udtStats.sort(sortAlpha);\n      out += '    RULES/UDTS ALPHABETICALLY\\n';\n    } else if (typeof type === 'string' && type.toLowerCase()[0] === 'i') {\n      ruleStats.sort(sortIndex);\n      udtStats.sort(sortIndex);\n      out += '    RULES/UDTS BY INDEX\\n';\n    } else {\n      ruleStats.sort(sortHits);\n      udtStats.sort(sortHits);\n      out += '    RULES/UDTS BY HIT COUNT\\n';\n    }\n    out += '|   MATCH |   EMPTY | NOMATCH |   TOTAL | NAME\\n';\n    for (let i = 0; i < ruleStats.length; i += 1) {\n      let r = ruleStats[i];\n      if (r.total) {\n        out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);\n      }\n    }\n    for (let i = 0; i < udtStats.length; i += 1) {\n      let r = udtStats[i];\n      if (r.total) {\n        out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);\n      }\n    }\n    return out;\n  };\n  const normalize = (n) => {\n    if (n < 10) {\n      return `      ${n}`;\n    }\n    if (n < 100) {\n      return `     ${n}`;\n    }\n    if (n < 1000) {\n      return `    ${n}`;\n    }\n    if (n < 10000) {\n      return `   ${n}`;\n    }\n    if (n < 100000) {\n      return `  ${n}`;\n    }\n    if (n < 1000000) {\n      return ` ${n}`;\n    }\n    return `${n}`;\n  };\n  const sortAlpha = (lhs, rhs) => {\n    if (lhs.lower < rhs.lower) {\n      return -1;\n    }\n    if (lhs.lower > rhs.lower) {\n      return 1;\n    }\n    return 0;\n  };\n  const sortHits = (lhs, rhs) => {\n    if (lhs.total < rhs.total) {\n      return 1;\n    }\n    if (lhs.total > rhs.total) {\n      return -1;\n    }\n    return sortAlpha(lhs, rhs);\n  };\n  const sortIndex = (lhs, rhs) => {\n    if (lhs.index < rhs.index) {\n      return -1;\n    }\n    if (lhs.index > rhs.index) {\n      return 1;\n    }\n    return 0;\n  };\n  const EmptyStat = function fnempty() {\n    this.empty = 0;\n    this.match = 0;\n    this.nomatch = 0;\n    this.total = 0;\n  };\n  /* Zero out all stats */\n  const clear = () => {\n    stats.length = 0;\n    totals = new EmptyStat();\n    stats[id.ALT] = new EmptyStat();\n    stats[id.CAT] = new EmptyStat();\n    stats[id.REP] = new EmptyStat();\n    stats[id.RNM] = new EmptyStat();\n    stats[id.TRG] = new EmptyStat();\n    stats[id.TBS] = new EmptyStat();\n    stats[id.TLS] = new EmptyStat();\n    stats[id.UDT] = new EmptyStat();\n    stats[id.AND] = new EmptyStat();\n    stats[id.NOT] = new EmptyStat();\n    ruleStats.length = 0;\n    for (let i = 0; i < rules.length; i += 1) {\n      ruleStats.push({\n        empty: 0,\n        match: 0,\n        nomatch: 0,\n        total: 0,\n        name: rules[i].name,\n        lower: rules[i].lower,\n        index: rules[i].index,\n      });\n    }\n    if (udts.length > 0) {\n      udtStats.length = 0;\n      for (let i = 0; i < udts.length; i += 1) {\n        udtStats.push({\n          empty: 0,\n          match: 0,\n          nomatch: 0,\n          total: 0,\n          name: udts[i].name,\n          lower: udts[i].lower,\n          index: udts[i].index,\n        });\n      }\n    }\n  };\n  /* increment the designated operator hit count by one */\n  const incStat = (stat, state) => {\n    stat.total += 1;\n    switch (state) {\n      case id.EMPTY:\n        stat.empty += 1;\n        break;\n      case id.MATCH:\n        stat.match += 1;\n        break;\n      case id.NOMATCH:\n        stat.nomatch += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\n    }\n  };\n};\n\nconst utilities = {\n  // utility functions\n  stringToChars: (string) => [...string].map((cp) => cp.codePointAt(0)),\n  charsToString: (chars, beg, len) => {\n    let subChars = chars;\n    while (1) {\n      if (beg === undefined || beg < 0) {\n        break;\n      }\n      if (len === undefined) {\n        subChars = chars.slice(beg);\n        break;\n      }\n      if (len <= 0) {\n        // always an empty string\n        return '';\n      }\n      subChars = chars.slice(beg, beg + len);\n      break;\n    }\n    return String.fromCodePoint(...subChars);\n  },\n};\n\nconst identifiers = {\n  // Identifies the operator type.\n  // NB: These must match the values in apg-js 4.3.0, apg-lib/identifiers.\n  /* the original ABNF operators */\n  ALT: 1 /* alternation */,\n  CAT: 2 /* concatenation */,\n  REP: 3 /* repetition */,\n  RNM: 4 /* rule name */,\n  TRG: 5 /* terminal range */,\n  TBS: 6 /* terminal binary string, case sensitive */,\n  TLS: 7 /* terminal literal string, case insensitive */,\n  /* the super set, SABNF operators */\n  UDT: 11 /* user-defined terminal */,\n  AND: 12 /* positive look ahead */,\n  NOT: 13 /* negative look ahead */,\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\n  // Identifies the parser state as it traverses the parse tree nodes.\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n  ACTIVE: 100,\n  MATCH: 101,\n  EMPTY: 102,\n  NOMATCH: 103,\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n  // to indicate the direction of flow through the `AST` nodes.\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n  SEM_PRE: 200,\n  SEM_POST: 201,\n  // Ignored. Retained for backwords compatibility.\n  SEM_OK: 300,\n  idName: (s) => {\n    switch (s) {\n      case identifiers.ALT:\n        return 'ALT';\n      case identifiers.CAT:\n        return 'CAT';\n      case identifiers.REP:\n        return 'REP';\n      case identifiers.RNM:\n        return 'RNM';\n      case identifiers.TRG:\n        return 'TRG';\n      case identifiers.TBS:\n        return 'TBS';\n      case identifiers.TLS:\n        return 'TLS';\n      case identifiers.UDT:\n        return 'UDT';\n      case identifiers.AND:\n        return 'AND';\n      case identifiers.NOT:\n        return 'NOT';\n      case identifiers.ACTIVE:\n        return 'ACTIVE';\n      case identifiers.EMPTY:\n        return 'EMPTY';\n      case identifiers.MATCH:\n        return 'MATCH';\n      case identifiers.NOMATCH:\n        return 'NOMATCH';\n      case identifiers.SEM_PRE:\n        return 'SEM_PRE';\n      case identifiers.SEM_POST:\n        return 'SEM_POST';\n      case identifiers.SEM_OK:\n        return 'SEM_OK';\n      default:\n        return 'UNRECOGNIZED STATE';\n    }\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}