{"ast":null,"code":"import { isUndefined } from 'ramda-adjunct';\nimport { isObjectElement, isArrayElement, isMemberElement } from \"../predicates/index.mjs\";\nconst computeEdges = (element, edges = new WeakMap()) => {\n  if (isMemberElement(element)) {\n    // @ts-ignore\n    edges.set(element.key, element);\n    // @ts-ignore\n    computeEdges(element.key, edges);\n    // @ts-ignore\n    edges.set(element.value, element);\n    // @ts-ignore\n    computeEdges(element.value, edges);\n  } else {\n    element.children.forEach(childElement => {\n      edges.set(childElement, element);\n      computeEdges(childElement, edges);\n    });\n  }\n  return edges;\n};\nconst transcludeChildOfMemberElement = (search, replace, edges) => {\n  const memberElement = edges.get(search);\n  if (!isMemberElement(memberElement)) {\n    return;\n  }\n  if (memberElement.key === search) {\n    memberElement.key = replace;\n    edges.delete(search);\n    edges.set(replace, memberElement);\n  }\n  if (memberElement.value === search) {\n    memberElement.value = replace;\n    edges.delete(search);\n    edges.set(replace, memberElement);\n  }\n};\nconst transcludeChildOfObjectElement = (search, replace, edges) => {\n  const objectElement = edges.get(search);\n  if (!isObjectElement(objectElement)) {\n    return;\n  }\n  objectElement.content = objectElement.map((value, key, member) => {\n    if (member === search) {\n      edges.delete(search);\n      edges.set(replace, objectElement);\n      return replace;\n    }\n    return member;\n  });\n};\nconst transcludeChildOfArrayElement = (search, replace, edges) => {\n  const arrayElement = edges.get(search);\n  if (!isArrayElement(arrayElement)) {\n    return;\n  }\n  arrayElement.content = arrayElement.map(element => {\n    if (element === search) {\n      edges.delete(search);\n      edges.set(replace, arrayElement);\n      return replace;\n    }\n    return element;\n  });\n};\n\n/**\n * This is a mutating stamp. If you don't want your Element to be mutated,\n * clone in before passing it to initializer of this stamp.\n */\n\nclass Transcluder {\n  element;\n  edges;\n  constructor({\n    element\n  }) {\n    this.element = element;\n  }\n  transclude(search, replace) {\n    var _this$edges;\n    // shortcut 1. - replacing entire ApiDOM tree\n    if (search === this.element) return replace;\n    // shortcut 2. - replacing nothing\n    if (search === replace) return this.element;\n    this.edges = (_this$edges = this.edges) !== null && _this$edges !== void 0 ? _this$edges : computeEdges(this.element);\n    const parent = this.edges.get(search);\n    if (isUndefined(parent)) {\n      return undefined;\n    }\n\n    /**\n     * This predicate must be first because ObjectElement extends ArrayElement.\n     * isArrayElement returns true for ObjectElements.\n     * (classical problems with polymorphism)\n     */\n    if (isObjectElement(parent)) {\n      // @ts-ignore\n      transcludeChildOfObjectElement(search, replace, this.edges);\n    } else if (isArrayElement(parent)) {\n      transcludeChildOfArrayElement(search, replace, this.edges);\n    } else if (isMemberElement(parent)) {\n      transcludeChildOfMemberElement(search, replace, this.edges);\n    }\n    return this.element;\n  }\n}\nexport default Transcluder;","map":{"version":3,"names":["isUndefined","isObjectElement","isArrayElement","isMemberElement","computeEdges","element","edges","WeakMap","set","key","value","children","forEach","childElement","transcludeChildOfMemberElement","search","replace","memberElement","get","delete","transcludeChildOfObjectElement","objectElement","content","map","member","transcludeChildOfArrayElement","arrayElement","Transcluder","constructor","transclude","_this$edges","parent","undefined"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-core/es/transcluder/Transcluder.mjs"],"sourcesContent":["import { isUndefined } from 'ramda-adjunct';\nimport { isObjectElement, isArrayElement, isMemberElement } from \"../predicates/index.mjs\";\nconst computeEdges = (element, edges = new WeakMap()) => {\n  if (isMemberElement(element)) {\n    // @ts-ignore\n    edges.set(element.key, element);\n    // @ts-ignore\n    computeEdges(element.key, edges);\n    // @ts-ignore\n    edges.set(element.value, element);\n    // @ts-ignore\n    computeEdges(element.value, edges);\n  } else {\n    element.children.forEach(childElement => {\n      edges.set(childElement, element);\n      computeEdges(childElement, edges);\n    });\n  }\n  return edges;\n};\nconst transcludeChildOfMemberElement = (search, replace, edges) => {\n  const memberElement = edges.get(search);\n  if (!isMemberElement(memberElement)) {\n    return;\n  }\n  if (memberElement.key === search) {\n    memberElement.key = replace;\n    edges.delete(search);\n    edges.set(replace, memberElement);\n  }\n  if (memberElement.value === search) {\n    memberElement.value = replace;\n    edges.delete(search);\n    edges.set(replace, memberElement);\n  }\n};\nconst transcludeChildOfObjectElement = (search, replace, edges) => {\n  const objectElement = edges.get(search);\n  if (!isObjectElement(objectElement)) {\n    return;\n  }\n  objectElement.content = objectElement.map((value, key, member) => {\n    if (member === search) {\n      edges.delete(search);\n      edges.set(replace, objectElement);\n      return replace;\n    }\n    return member;\n  });\n};\nconst transcludeChildOfArrayElement = (search, replace, edges) => {\n  const arrayElement = edges.get(search);\n  if (!isArrayElement(arrayElement)) {\n    return;\n  }\n  arrayElement.content = arrayElement.map(element => {\n    if (element === search) {\n      edges.delete(search);\n      edges.set(replace, arrayElement);\n      return replace;\n    }\n    return element;\n  });\n};\n\n/**\n * This is a mutating stamp. If you don't want your Element to be mutated,\n * clone in before passing it to initializer of this stamp.\n */\n\nclass Transcluder {\n  element;\n  edges;\n  constructor({\n    element\n  }) {\n    this.element = element;\n  }\n  transclude(search, replace) {\n    var _this$edges;\n    // shortcut 1. - replacing entire ApiDOM tree\n    if (search === this.element) return replace;\n    // shortcut 2. - replacing nothing\n    if (search === replace) return this.element;\n    this.edges = (_this$edges = this.edges) !== null && _this$edges !== void 0 ? _this$edges : computeEdges(this.element);\n    const parent = this.edges.get(search);\n    if (isUndefined(parent)) {\n      return undefined;\n    }\n\n    /**\n     * This predicate must be first because ObjectElement extends ArrayElement.\n     * isArrayElement returns true for ObjectElements.\n     * (classical problems with polymorphism)\n     */\n    if (isObjectElement(parent)) {\n      // @ts-ignore\n      transcludeChildOfObjectElement(search, replace, this.edges);\n    } else if (isArrayElement(parent)) {\n      transcludeChildOfArrayElement(search, replace, this.edges);\n    } else if (isMemberElement(parent)) {\n      transcludeChildOfMemberElement(search, replace, this.edges);\n    }\n    return this.element;\n  }\n}\nexport default Transcluder;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}