{"ast":null,"code":"const negate = require('lodash/negate');\n\n// Coerces an a parameter into a callback for matching elements.\n// This accepts an element name, an element type and returns a\n// callback to match for those elements.\nfunction coerceElementMatchingCallback(value) {\n  // Element Name\n  if (typeof value === 'string') {\n    return element => element.element === value;\n  }\n\n  // Element Type\n  if (value.constructor && value.extend) {\n    return element => element instanceof value;\n  }\n  return value;\n}\n\n/**\n * @class\n *\n * @param {Element[]} elements\n *\n * @property {Element[]} elements\n */\nclass ArraySlice {\n  constructor(elements) {\n    this.elements = elements || [];\n  }\n\n  /**\n   * @returns {Array}\n   */\n  toValue() {\n    return this.elements.map(element => element.toValue());\n  }\n\n  // High Order Functions\n\n  /**\n   * @param callback - Function to execute for each element\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {array} A new array with each element being the result of the callback function\n   */\n  map(callback, thisArg) {\n    return this.elements.map(callback, thisArg);\n  }\n\n  /**\n   * Maps and then flattens the results.\n   * @param callback - Function to execute for each element.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {array}\n   */\n  flatMap(callback, thisArg) {\n    return this.map(callback, thisArg).reduce((a, b) => a.concat(b), []);\n  }\n\n  /**\n   * Returns an array containing the truthy results of calling the given transformation with each element of this sequence\n   * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @memberof ArraySlice.prototype\n   * @returns An array of the non-undefined results of calling transform with each element of the array\n   */\n  compactMap(transform, thisArg) {\n    const results = [];\n    this.forEach(element => {\n      const result = transform.bind(thisArg)(element);\n      if (result) {\n        results.push(result);\n      }\n    });\n    return results;\n  }\n\n  /**\n   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {ArraySlice}\n   * @memberof ArraySlice.prototype\n   */\n  filter(callback, thisArg) {\n    callback = coerceElementMatchingCallback(callback);\n    return new ArraySlice(this.elements.filter(callback, thisArg));\n  }\n\n  /**\n   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {ArraySlice}\n   * @memberof ArraySlice.prototype\n   */\n  reject(callback, thisArg) {\n    callback = coerceElementMatchingCallback(callback);\n    return new ArraySlice(this.elements.filter(negate(callback), thisArg));\n  }\n\n  /**\n   * Returns the first element in the array that satisfies the given value\n   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {Element}\n   * @memberof ArraySlice.prototype\n   */\n  find(callback, thisArg) {\n    callback = coerceElementMatchingCallback(callback);\n    return this.elements.find(callback, thisArg);\n  }\n\n  /**\n   * @param callback - Function to execute for each element\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @memberof ArraySlice.prototype\n   */\n  forEach(callback, thisArg) {\n    this.elements.forEach(callback, thisArg);\n  }\n\n  /**\n   * @param callback - Function to execute for each element\n   * @param initialValue\n   * @memberof ArraySlice.prototype\n   */\n  reduce(callback, initialValue) {\n    return this.elements.reduce(callback, initialValue);\n  }\n\n  /**\n   * @param value\n   * @returns {boolean}\n   * @memberof ArraySlice.prototype\n   */\n  includes(value) {\n    return this.elements.some(element => element.equals(value));\n  }\n\n  // Mutation\n\n  /**\n   * Removes the first element from the slice\n   * @returns {Element} The removed element or undefined if the slice is empty\n   * @memberof ArraySlice.prototype\n   */\n  shift() {\n    return this.elements.shift();\n  }\n\n  /**\n   * Adds the given element to the begining of the slice\n   * @parameter {Element} value\n   * @memberof ArraySlice.prototype\n   */\n  unshift(value) {\n    this.elements.unshift(this.refract(value));\n  }\n\n  /**\n   * Adds the given element to the end of the slice\n   * @parameter {Element} value\n   * @memberof ArraySlice.prototype\n   */\n  push(value) {\n    this.elements.push(this.refract(value));\n    return this;\n  }\n\n  /**\n   * @parameter {Element} value\n   * @memberof ArraySlice.prototype\n   */\n  add(value) {\n    this.push(value);\n  }\n\n  // Accessors\n\n  /**\n   * @parameter {number} index\n   * @returns {Element}\n   * @memberof ArraySlice.prototype\n   */\n  get(index) {\n    return this.elements[index];\n  }\n\n  /**\n   * @parameter {number} index\n   * @memberof ArraySlice.prototype\n   */\n  getValue(index) {\n    const element = this.elements[index];\n    if (element) {\n      return element.toValue();\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns the number of elements in the slice\n   * @type number\n   */\n  get length() {\n    return this.elements.length;\n  }\n\n  /**\n   * Returns whether the slice is empty\n   * @type boolean\n   */\n  get isEmpty() {\n    return this.elements.length === 0;\n  }\n\n  /**\n   * Returns the first element in the slice or undefined if the slice is empty\n   * @type Element\n   */\n  get first() {\n    return this.elements[0];\n  }\n}\nif (typeof Symbol !== 'undefined') {\n  ArraySlice.prototype[Symbol.iterator] = function symbol() {\n    return this.elements[Symbol.iterator]();\n  };\n}\nmodule.exports = ArraySlice;","map":{"version":3,"names":["negate","require","coerceElementMatchingCallback","value","element","constructor","extend","ArraySlice","elements","toValue","map","callback","thisArg","flatMap","reduce","a","b","concat","compactMap","transform","results","forEach","result","bind","push","filter","reject","find","initialValue","includes","some","equals","shift","unshift","refract","add","get","index","getValue","undefined","length","isEmpty","first","Symbol","prototype","iterator","symbol","module","exports"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/minim/lib/ArraySlice.js"],"sourcesContent":["const negate = require('lodash/negate');\n\n// Coerces an a parameter into a callback for matching elements.\n// This accepts an element name, an element type and returns a\n// callback to match for those elements.\nfunction coerceElementMatchingCallback(value) {\n  // Element Name\n  if (typeof value === 'string') {\n    return element => element.element === value;\n  }\n\n  // Element Type\n  if (value.constructor && value.extend) {\n    return element => element instanceof value;\n  }\n\n  return value;\n}\n\n/**\n * @class\n *\n * @param {Element[]} elements\n *\n * @property {Element[]} elements\n */\nclass ArraySlice {\n  constructor(elements) {\n    this.elements = elements || [];\n  }\n\n  /**\n   * @returns {Array}\n   */\n  toValue() {\n    return this.elements.map(element => element.toValue());\n  }\n\n  // High Order Functions\n\n  /**\n   * @param callback - Function to execute for each element\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {array} A new array with each element being the result of the callback function\n   */\n  map(callback, thisArg) {\n    return this.elements.map(callback, thisArg);\n  }\n\n  /**\n   * Maps and then flattens the results.\n   * @param callback - Function to execute for each element.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {array}\n   */\n  flatMap(callback, thisArg) {\n    return this\n      .map(callback, thisArg)\n      .reduce((a, b) => a.concat(b), []);\n  }\n\n  /**\n   * Returns an array containing the truthy results of calling the given transformation with each element of this sequence\n   * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @memberof ArraySlice.prototype\n   * @returns An array of the non-undefined results of calling transform with each element of the array\n   */\n  compactMap(transform, thisArg) {\n    const results = [];\n\n    this.forEach((element) => {\n      const result = transform.bind(thisArg)(element);\n\n      if (result) {\n        results.push(result);\n      }\n    });\n\n    return results;\n  }\n\n  /**\n   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {ArraySlice}\n   * @memberof ArraySlice.prototype\n   */\n  filter(callback, thisArg) {\n    callback = coerceElementMatchingCallback(callback);\n    return new ArraySlice(this.elements.filter(callback, thisArg));\n  }\n\n  /**\n   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {ArraySlice}\n   * @memberof ArraySlice.prototype\n   */\n  reject(callback, thisArg) {\n    callback = coerceElementMatchingCallback(callback);\n    return new ArraySlice(this.elements.filter(negate(callback), thisArg));\n  }\n\n  /**\n   * Returns the first element in the array that satisfies the given value\n   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @returns {Element}\n   * @memberof ArraySlice.prototype\n   */\n  find(callback, thisArg) {\n    callback = coerceElementMatchingCallback(callback);\n    return this.elements.find(callback, thisArg);\n  }\n\n  /**\n   * @param callback - Function to execute for each element\n   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback\n   * @memberof ArraySlice.prototype\n   */\n  forEach(callback, thisArg) {\n    this.elements.forEach(callback, thisArg);\n  }\n\n  /**\n   * @param callback - Function to execute for each element\n   * @param initialValue\n   * @memberof ArraySlice.prototype\n   */\n  reduce(callback, initialValue) {\n    return this.elements.reduce(callback, initialValue);\n  }\n\n  /**\n   * @param value\n   * @returns {boolean}\n   * @memberof ArraySlice.prototype\n   */\n  includes(value) {\n    return this.elements.some(element => element.equals(value));\n  }\n\n  // Mutation\n\n  /**\n   * Removes the first element from the slice\n   * @returns {Element} The removed element or undefined if the slice is empty\n   * @memberof ArraySlice.prototype\n   */\n  shift() {\n    return this.elements.shift();\n  }\n\n  /**\n   * Adds the given element to the begining of the slice\n   * @parameter {Element} value\n   * @memberof ArraySlice.prototype\n   */\n  unshift(value) {\n    this.elements.unshift(this.refract(value));\n  }\n\n  /**\n   * Adds the given element to the end of the slice\n   * @parameter {Element} value\n   * @memberof ArraySlice.prototype\n   */\n  push(value) {\n    this.elements.push(this.refract(value));\n    return this;\n  }\n\n  /**\n   * @parameter {Element} value\n   * @memberof ArraySlice.prototype\n   */\n  add(value) {\n    this.push(value);\n  }\n\n  // Accessors\n\n  /**\n   * @parameter {number} index\n   * @returns {Element}\n   * @memberof ArraySlice.prototype\n   */\n  get(index) {\n    return this.elements[index];\n  }\n\n  /**\n   * @parameter {number} index\n   * @memberof ArraySlice.prototype\n   */\n  getValue(index) {\n    const element = this.elements[index];\n\n    if (element) {\n      return element.toValue();\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns the number of elements in the slice\n   * @type number\n   */\n  get length() {\n    return this.elements.length;\n  }\n\n  /**\n   * Returns whether the slice is empty\n   * @type boolean\n   */\n  get isEmpty() {\n    return this.elements.length === 0;\n  }\n\n  /**\n   * Returns the first element in the slice or undefined if the slice is empty\n   * @type Element\n   */\n  get first() {\n    return this.elements[0];\n  }\n}\n\nif (typeof Symbol !== 'undefined') {\n  ArraySlice.prototype[Symbol.iterator] = function symbol() {\n    return this.elements[Symbol.iterator]();\n  };\n}\n\nmodule.exports = ArraySlice;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}