{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Matcher } from './matcher';\nimport { alphaNumericAndMarksCharRe, alphaNumericAndMarksCharsStr } from '../regex-lib';\nimport { HashtagMatch } from '../match/hashtag-match';\nimport { throwUnhandledCaseError } from '../utils';\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\nvar hashtagTextCharRe = new RegExp(\"[_\".concat(alphaNumericAndMarksCharsStr, \"]\"));\n/**\n * @class Autolinker.matcher.Hashtag\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find HashtagMatch matches in an input string.\n */\nvar HashtagMatcher = /** @class */function (_super) {\n  __extends(HashtagMatcher, _super);\n  /**\n   * @method constructor\n   * @param {Object} cfg The configuration properties for the Match instance,\n   *   specified in an Object (map).\n   */\n  function HashtagMatcher(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /**\n     * @cfg {String} service\n     *\n     * A string for the service name to have hashtags (ex: \"#myHashtag\")\n     * auto-linked to. The currently-supported values are:\n     *\n     * - 'twitter'\n     * - 'facebook'\n     * - 'instagram'\n     * - 'tiktok'\n     */\n    _this.serviceName = 'twitter'; // default value just to get the above doc comment in the ES5 output and documentation generator\n    _this.serviceName = cfg.serviceName;\n    return _this;\n  }\n  /**\n   * @inheritdoc\n   */\n  HashtagMatcher.prototype.parseMatches = function (text) {\n    var tagBuilder = this.tagBuilder;\n    var serviceName = this.serviceName;\n    var matches = [];\n    var len = text.length;\n    var charIdx = 0,\n      hashCharIdx = -1,\n      state = 0 /* None */;\n    // For debugging: search for other \"For debugging\" lines\n    // const table = new CliTable( {\n    // \thead: [ 'charIdx', 'char', 'state', 'charIdx', 'currentEmailAddress.idx', 'hasDomainDot' ]\n    // } );\n    while (charIdx < len) {\n      var char = text.charAt(charIdx);\n      // For debugging: search for other \"For debugging\" lines\n      // table.push(\n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ]\n      // );\n      switch (state) {\n        case 0 /* None */:\n          stateNone(char);\n          break;\n        case 1 /* NonHashtagWordChar */:\n          stateNonHashtagWordChar(char);\n          break;\n        case 2 /* HashtagHashChar */:\n          stateHashtagHashChar(char);\n          break;\n        case 3 /* HashtagTextChar */:\n          stateHashtagTextChar(char);\n          break;\n        default:\n          throwUnhandledCaseError(state);\n      }\n      // For debugging: search for other \"For debugging\" lines\n      // table.push(\n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ]\n      // );\n      charIdx++;\n    }\n    // Capture any valid match at the end of the string\n    captureMatchIfValid();\n    // For debugging: search for other \"For debugging\" lines\n    //console.log( '\\n' + table.toString() );\n    return matches;\n    // Handles the state when we're not in a hashtag or any word\n    function stateNone(char) {\n      if (char === '#') {\n        state = 2 /* HashtagHashChar */;\n        hashCharIdx = charIdx;\n      } else if (alphaNumericAndMarksCharRe.test(char)) {\n        state = 1 /* NonHashtagWordChar */;\n      } else {\n        // not a hashtag character ('#') or word char, stay in State.None\n      }\n    }\n    // Handles the state when we've encountered a word character but are not\n    // in a hashtag. This is used to distinguish between a standalone\n    // hashtag such as '#Stuff' vs a hash char that is part of a word like\n    // 'asdf#stuff' (the latter of which would not be a match)\n    function stateNonHashtagWordChar(char) {\n      if (alphaNumericAndMarksCharRe.test(char)) {\n        // continue in NonHashtagWordChar state\n      } else {\n        state = 0 /* None */;\n      }\n    }\n    // Handles the state when we've just encountered a '#' character\n    function stateHashtagHashChar(char) {\n      if (hashtagTextCharRe.test(char)) {\n        // '#' char with valid hash text char following\n        state = 3 /* HashtagTextChar */;\n      } else if (alphaNumericAndMarksCharRe.test(char)) {\n        state = 1 /* NonHashtagWordChar */;\n      } else {\n        state = 0 /* None */;\n      }\n    }\n    // Handles the state when we're currently in the hash tag's text chars\n    function stateHashtagTextChar(char) {\n      if (hashtagTextCharRe.test(char)) {\n        // Continue reading characters in the HashtagText state\n      } else {\n        captureMatchIfValid();\n        hashCharIdx = -1;\n        if (alphaNumericAndMarksCharRe.test(char)) {\n          state = 1 /* NonHashtagWordChar */;\n        } else {\n          state = 0 /* None */;\n        }\n      }\n    }\n    /*\n     * Captures the current hashtag as a HashtagMatch if it's valid.\n     */\n    function captureMatchIfValid() {\n      if (hashCharIdx > -1 && charIdx - hashCharIdx <= 140) {\n        // Max length of 140 for a hashtag ('#' char + 139 word chars)\n        var matchedText = text.slice(hashCharIdx, charIdx);\n        var match = new HashtagMatch({\n          tagBuilder: tagBuilder,\n          matchedText: matchedText,\n          offset: hashCharIdx,\n          serviceName: serviceName,\n          hashtag: matchedText.slice(1)\n        });\n        matches.push(match);\n      }\n    }\n  };\n  return HashtagMatcher;\n}(Matcher);\nexport { HashtagMatcher };\nexport var hashtagServices = ['twitter', 'facebook', 'instagram', 'tiktok'];","map":{"version":3,"names":["Matcher","alphaNumericAndMarksCharRe","alphaNumericAndMarksCharsStr","HashtagMatch","throwUnhandledCaseError","hashtagTextCharRe","RegExp","concat","HashtagMatcher","_super","__extends","cfg","_this","call","serviceName","prototype","parseMatches","text","tagBuilder","matches","len","length","charIdx","hashCharIdx","state","char","charAt","stateNone","stateNonHashtagWordChar","stateHashtagHashChar","stateHashtagTextChar","captureMatchIfValid","test","matchedText","slice","match","offset","hashtag","push","hashtagServices"],"sources":["../../../src/matcher/hashtag-matcher.ts"],"sourcesContent":[null],"mappings":";AAAA,SAASA,OAAO,QAAuB,WAAW;AAClD,SAASC,0BAA0B,EAAEC,4BAA4B,QAAQ,cAAc;AACvF,SAASC,YAAY,QAAQ,wBAAwB;AAErD,SAASC,uBAAuB,QAAQ,UAAU;AAElD;AACA;AAEA,IAAMC,iBAAiB,GAAG,IAAIC,MAAM,CAAC,KAAAC,MAAA,CAAKL,4BAA4B,MAAG,CAAC;AAE1E;;;;;;AAMA,IAAAM,cAAA,0BAAAC,MAAA;EAAoCC,SAAA,CAAAF,cAAA,EAAAC,MAAA;EAchC;;;;;EAKA,SAAAD,eAAYG,GAAyB;IAArC,IAAAC,KAAA,GACIH,MAAA,CAAAI,IAAA,OAAMF,GAAG,CAAC;IAnBd;;;;;;;;;;;IAWmBC,KAAA,CAAAE,WAAW,GAAmB,SAAS,CAAC,CAAC;IAUxDF,KAAI,CAACE,WAAW,GAAGH,GAAG,CAACG,WAAW;;EACtC;EAEA;;;EAGAN,cAAA,CAAAO,SAAA,CAAAC,YAAY,GAAZ,UAAaC,IAAY;IACrB,IAAMC,UAAU,GAAG,IAAI,CAACA,UAAU;IAClC,IAAMJ,WAAW,GAAG,IAAI,CAACA,WAAW;IAEpC,IAAMK,OAAO,GAAY,EAAE;IAC3B,IAAMC,GAAG,GAAGH,IAAI,CAACI,MAAM;IAEvB,IAAIC,OAAO,GAAG,CAAC;MACXC,WAAW,GAAG,CAAC,CAAC;MAChBC,KAAK,GAAG;IAEZ;IACA;IACA;IACA;IAEA,OAAOF,OAAO,GAAGF,GAAG,EAAE;MAClB,IAAMK,IAAI,GAAGR,IAAI,CAACS,MAAM,CAACJ,OAAO,CAAC;MAEjC;MACA;MACA;MACA;MAEA,QAAQE,KAAK;QACT;UACIG,SAAS,CAACF,IAAI,CAAC;UACf;QACJ;UACIG,uBAAuB,CAACH,IAAI,CAAC;UAC7B;QACJ;UACII,oBAAoB,CAACJ,IAAI,CAAC;UAC1B;QACJ;UACIK,oBAAoB,CAACL,IAAI,CAAC;UAC1B;QAEJ;UACIrB,uBAAuB,CAACoB,KAAK,CAAC;;MAGtC;MACA;MACA;MACA;MAEAF,OAAO,EAAE;;IAGb;IACAS,mBAAmB,EAAE;IAErB;IACA;IAEA,OAAOZ,OAAO;IAEd;IACA,SAASQ,SAASA,CAACF,IAAY;MAC3B,IAAIA,IAAI,KAAK,GAAG,EAAE;QACdD,KAAK;QACLD,WAAW,GAAGD,OAAO;OACxB,MAAM,IAAIrB,0BAA0B,CAAC+B,IAAI,CAACP,IAAI,CAAC,EAAE;QAC9CD,KAAK;OACR,MAAM;QACH;MAAA;IAER;IAEA;IACA;IACA;IACA;IACA,SAASI,uBAAuBA,CAACH,IAAY;MACzC,IAAIxB,0BAA0B,CAAC+B,IAAI,CAACP,IAAI,CAAC,EAAE;QACvC;MAAA,CACH,MAAM;QACHD,KAAK;;IAEb;IAEA;IACA,SAASK,oBAAoBA,CAACJ,IAAY;MACtC,IAAIpB,iBAAiB,CAAC2B,IAAI,CAACP,IAAI,CAAC,EAAE;QAC9B;QACAD,KAAK;OACR,MAAM,IAAIvB,0BAA0B,CAAC+B,IAAI,CAACP,IAAI,CAAC,EAAE;QAC9CD,KAAK;OACR,MAAM;QACHA,KAAK;;IAEb;IAEA;IACA,SAASM,oBAAoBA,CAACL,IAAY;MACtC,IAAIpB,iBAAiB,CAAC2B,IAAI,CAACP,IAAI,CAAC,EAAE;QAC9B;MAAA,CACH,MAAM;QACHM,mBAAmB,EAAE;QACrBR,WAAW,GAAG,CAAC,CAAC;QAEhB,IAAItB,0BAA0B,CAAC+B,IAAI,CAACP,IAAI,CAAC,EAAE;UACvCD,KAAK;SACR,MAAM;UACHA,KAAK;;;IAGjB;IAEA;;;IAGA,SAASO,mBAAmBA,CAAA;MACxB,IAAIR,WAAW,GAAG,CAAC,CAAC,IAAID,OAAO,GAAGC,WAAW,IAAI,GAAG,EAAE;QAClD;QACA,IAAIU,WAAW,GAAGhB,IAAI,CAACiB,KAAK,CAACX,WAAW,EAAED,OAAO,CAAC;QAElD,IAAMa,KAAK,GAAG,IAAIhC,YAAY,CAAC;UAC3Be,UAAU,EAAAA,UAAA;UACVe,WAAW,EAAEA,WAAW;UACxBG,MAAM,EAAEb,WAAW;UACnBT,WAAW,EAAEA,WAAW;UACxBuB,OAAO,EAAEJ,WAAW,CAACC,KAAK,CAAC,CAAC;SAC/B,CAAC;QACFf,OAAO,CAACmB,IAAI,CAACH,KAAK,CAAC;;IAE3B;EACJ,CAAC;EACL,OAAA3B,cAAC;AAAD,CAAC,CA7JmCR,OAAO;;AA8K3C,OAAO,IAAMuC,eAAe,GAAqB,CAAC,SAAS,EAAE,UAAU,EAAE,WAAW,EAAE,QAAQ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}