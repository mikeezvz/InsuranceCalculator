{"ast":null,"code":"import { clone } from 'ramda';\nimport YamlTagError from \"../../errors/YamlTagError.mjs\";\nimport { YamlNodeKind } from \"../../nodes/YamlTag.mjs\";\nimport GenericMappingTag from \"./GenericMapping.mjs\";\nimport GenericSequenceTag from \"./GenericSequence.mjs\";\nimport GenericStringTag from \"./GenericString.mjs\";\nimport ScalarTag from \"../ScalarTag.mjs\";\nclass FailsafeSchema {\n  tags;\n  tagDirectives;\n  constructor() {\n    this.tags = [];\n    this.tagDirectives = [];\n    this.registerTag(new GenericMappingTag());\n    this.registerTag(new GenericSequenceTag());\n    this.registerTag(new GenericStringTag());\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  toSpecificTagName(node) {\n    let specificTagName = node.tag.explicitName;\n    if (node.tag.explicitName === '!') {\n      // non-specific tag; we assume tag by kind\n      if (node.tag.kind === YamlNodeKind.Scalar) {\n        specificTagName = GenericStringTag.uri;\n      } else if (node.tag.kind === YamlNodeKind.Sequence) {\n        specificTagName = GenericSequenceTag.uri;\n      } else if (node.tag.kind === YamlNodeKind.Mapping) {\n        specificTagName = GenericMappingTag.uri;\n      }\n    } else if (node.tag.explicitName.startsWith('!<')) {\n      // verbatim form\n      specificTagName = node.tag.explicitName.replace(/^!</, '').replace(/>$/, '');\n    } else if (node.tag.explicitName.startsWith('!!')) {\n      // shorthand notation\n      specificTagName = `tag:yaml.org,2002:${node.tag.explicitName.replace(/^!!/, '')}`;\n    }\n    return specificTagName;\n  }\n  registerTagDirective(tagDirective) {\n    this.tagDirectives.push({\n      // @ts-ignore\n      handle: tagDirective.parameters.handle,\n      // @ts-ignore\n      prefix: tagDirective.parameters.prefix\n    });\n  }\n  registerTag(tag, beginning = false) {\n    if (beginning) {\n      this.tags.unshift(tag);\n    } else {\n      this.tags.push(tag);\n    }\n    return this;\n  }\n  overrideTag(tag) {\n    this.tags = this.tags.filter(itag => itag.tag === tag.tag);\n    this.tags.push(tag);\n    return this;\n  }\n  resolve(node) {\n    const specificTagName = this.toSpecificTagName(node);\n\n    // leave this node unresolved\n    if (specificTagName === '?') {\n      return node;\n    }\n\n    // turn scalar nodes into canonical format before resolving\n    let canonicalNode = node;\n    if (ScalarTag.test(node)) {\n      canonicalNode = ScalarTag.canonicalFormat(node);\n    }\n    const tag = this.tags.find(itag => (itag === null || itag === void 0 ? void 0 : itag.tag) === specificTagName);\n\n    // mechanism for resolving node (tag implementation) not found\n    if (typeof tag === 'undefined') {\n      throw new YamlTagError(`Tag \"${specificTagName}\" was not recognized.`, {\n        specificTagName,\n        explicitTagName: node.tag.explicitName,\n        tagKind: node.tag.kind,\n        tagPosition: clone(node.tag.position),\n        node: node.clone()\n      });\n    }\n\n    // node content is not compatible with resolving mechanism (tag implementation)\n    if (!tag.test(canonicalNode)) {\n      throw new YamlTagError(`Node couldn't be resolved against the tag \"${specificTagName}\"`, {\n        specificTagName,\n        explicitTagName: node.tag.explicitName,\n        tagKind: node.tag.kind,\n        tagPosition: clone(node.tag.position),\n        nodeCanonicalContent: canonicalNode.content,\n        node: node.clone()\n      });\n    }\n    return tag.resolve(canonicalNode);\n  }\n}\nexport default FailsafeSchema;","map":{"version":3,"names":["clone","YamlTagError","YamlNodeKind","GenericMappingTag","GenericSequenceTag","GenericStringTag","ScalarTag","FailsafeSchema","tags","tagDirectives","constructor","registerTag","toSpecificTagName","node","specificTagName","tag","explicitName","kind","Scalar","uri","Sequence","Mapping","startsWith","replace","registerTagDirective","tagDirective","push","handle","parameters","prefix","beginning","unshift","overrideTag","filter","itag","resolve","canonicalNode","test","canonicalFormat","find","explicitTagName","tagKind","tagPosition","position","nodeCanonicalContent","content"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-ast/es/yaml/schemas/failsafe/index.mjs"],"sourcesContent":["import { clone } from 'ramda';\nimport YamlTagError from \"../../errors/YamlTagError.mjs\";\nimport { YamlNodeKind } from \"../../nodes/YamlTag.mjs\";\nimport GenericMappingTag from \"./GenericMapping.mjs\";\nimport GenericSequenceTag from \"./GenericSequence.mjs\";\nimport GenericStringTag from \"./GenericString.mjs\";\nimport ScalarTag from \"../ScalarTag.mjs\";\nclass FailsafeSchema {\n  tags;\n  tagDirectives;\n  constructor() {\n    this.tags = [];\n    this.tagDirectives = [];\n    this.registerTag(new GenericMappingTag());\n    this.registerTag(new GenericSequenceTag());\n    this.registerTag(new GenericStringTag());\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  toSpecificTagName(node) {\n    let specificTagName = node.tag.explicitName;\n    if (node.tag.explicitName === '!') {\n      // non-specific tag; we assume tag by kind\n      if (node.tag.kind === YamlNodeKind.Scalar) {\n        specificTagName = GenericStringTag.uri;\n      } else if (node.tag.kind === YamlNodeKind.Sequence) {\n        specificTagName = GenericSequenceTag.uri;\n      } else if (node.tag.kind === YamlNodeKind.Mapping) {\n        specificTagName = GenericMappingTag.uri;\n      }\n    } else if (node.tag.explicitName.startsWith('!<')) {\n      // verbatim form\n      specificTagName = node.tag.explicitName.replace(/^!</, '').replace(/>$/, '');\n    } else if (node.tag.explicitName.startsWith('!!')) {\n      // shorthand notation\n      specificTagName = `tag:yaml.org,2002:${node.tag.explicitName.replace(/^!!/, '')}`;\n    }\n    return specificTagName;\n  }\n  registerTagDirective(tagDirective) {\n    this.tagDirectives.push({\n      // @ts-ignore\n      handle: tagDirective.parameters.handle,\n      // @ts-ignore\n      prefix: tagDirective.parameters.prefix\n    });\n  }\n  registerTag(tag, beginning = false) {\n    if (beginning) {\n      this.tags.unshift(tag);\n    } else {\n      this.tags.push(tag);\n    }\n    return this;\n  }\n  overrideTag(tag) {\n    this.tags = this.tags.filter(itag => itag.tag === tag.tag);\n    this.tags.push(tag);\n    return this;\n  }\n  resolve(node) {\n    const specificTagName = this.toSpecificTagName(node);\n\n    // leave this node unresolved\n    if (specificTagName === '?') {\n      return node;\n    }\n\n    // turn scalar nodes into canonical format before resolving\n    let canonicalNode = node;\n    if (ScalarTag.test(node)) {\n      canonicalNode = ScalarTag.canonicalFormat(node);\n    }\n    const tag = this.tags.find(itag => (itag === null || itag === void 0 ? void 0 : itag.tag) === specificTagName);\n\n    // mechanism for resolving node (tag implementation) not found\n    if (typeof tag === 'undefined') {\n      throw new YamlTagError(`Tag \"${specificTagName}\" was not recognized.`, {\n        specificTagName,\n        explicitTagName: node.tag.explicitName,\n        tagKind: node.tag.kind,\n        tagPosition: clone(node.tag.position),\n        node: node.clone()\n      });\n    }\n\n    // node content is not compatible with resolving mechanism (tag implementation)\n    if (!tag.test(canonicalNode)) {\n      throw new YamlTagError(`Node couldn't be resolved against the tag \"${specificTagName}\"`, {\n        specificTagName,\n        explicitTagName: node.tag.explicitName,\n        tagKind: node.tag.kind,\n        tagPosition: clone(node.tag.position),\n        nodeCanonicalContent: canonicalNode.content,\n        node: node.clone()\n      });\n    }\n    return tag.resolve(canonicalNode);\n  }\n}\nexport default FailsafeSchema;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}