{"ast":null,"code":"'use strict';\n\nvar repeat = require('repeat-string');\nvar splitOnTags = function splitOnTags(str) {\n  return str.split(/(<\\/?[^>]+>)/g).filter(function (line) {\n    return line.trim() !== '';\n  });\n};\nvar isTag = function isTag(str) {\n  return /<[^>!]+>/.test(str);\n};\nvar isClosingTag = function isClosingTag(str) {\n  return /<\\/+[^>]+>/.test(str);\n};\nvar isSelfClosingTag = function isSelfClosingTag(str) {\n  return /<[^>]+\\/>/.test(str);\n};\nvar isOpeningTag = function isOpeningTag(str) {\n  return isTag(str) && !isClosingTag(str) && !isSelfClosingTag(str);\n};\nmodule.exports = function (xml) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var indentor = config.indentor,\n    textNodesOnSameLine = config.textNodesOnSameLine;\n  var depth = 0;\n  var indicesToRemove = [];\n  indentor = indentor || '    ';\n  var rawResult = lexer(xml).map(function (element, i, arr) {\n    var value = element.value,\n      type = element.type;\n    if (type === 'ClosingTag') {\n      depth--;\n    }\n    var indentation = repeat(indentor, depth);\n    var line = indentation + value;\n    if (type === 'OpeningTag') {\n      depth++;\n    }\n    if (textNodesOnSameLine) {\n      // Lookbehind for [OpeningTag][Text][ClosingTag]\n      var oneBefore = arr[i - 1];\n      var twoBefore = arr[i - 2];\n      if (type === \"ClosingTag\" && oneBefore.type === \"Text\" && twoBefore.type === \"OpeningTag\") {\n        // collapse into a single line\n        line = '' + indentation + twoBefore.value + oneBefore.value + value;\n        indicesToRemove.push(i - 2, i - 1);\n      }\n    }\n    return line;\n  });\n  indicesToRemove.forEach(function (idx) {\n    return rawResult[idx] = null;\n  });\n  return rawResult.filter(function (val) {\n    return !!val;\n  }).join('\\n');\n};\nfunction lexer(xmlStr) {\n  var values = splitOnTags(xmlStr);\n  return values.map(function (value) {\n    return {\n      value: value,\n      type: getType(value)\n    };\n  });\n}\n\n// Helpers\n\nfunction getType(str) {\n  if (isClosingTag(str)) {\n    return 'ClosingTag';\n  }\n  if (isOpeningTag(str)) {\n    return 'OpeningTag';\n  }\n  if (isSelfClosingTag(str)) {\n    return 'SelfClosingTag';\n  }\n  return 'Text';\n}","map":{"version":3,"names":["repeat","require","splitOnTags","str","split","filter","line","trim","isTag","test","isClosingTag","isSelfClosingTag","isOpeningTag","module","exports","xml","config","arguments","length","undefined","indentor","textNodesOnSameLine","depth","indicesToRemove","rawResult","lexer","map","element","i","arr","value","type","indentation","oneBefore","twoBefore","push","forEach","idx","val","join","xmlStr","values","getType"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/xml-but-prettier/dist/index.js"],"sourcesContent":["'use strict';\n\nvar repeat = require('repeat-string');\n\nvar splitOnTags = function splitOnTags(str) {\n  return str.split(/(<\\/?[^>]+>)/g).filter(function (line) {\n    return line.trim() !== '';\n  });\n};\nvar isTag = function isTag(str) {\n  return (/<[^>!]+>/.test(str)\n  );\n};\nvar isClosingTag = function isClosingTag(str) {\n  return (/<\\/+[^>]+>/.test(str)\n  );\n};\nvar isSelfClosingTag = function isSelfClosingTag(str) {\n  return (/<[^>]+\\/>/.test(str)\n  );\n};\nvar isOpeningTag = function isOpeningTag(str) {\n  return isTag(str) && !isClosingTag(str) && !isSelfClosingTag(str);\n};\n\nmodule.exports = function (xml) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var indentor = config.indentor,\n      textNodesOnSameLine = config.textNodesOnSameLine;\n\n  var depth = 0;\n  var indicesToRemove = [];\n  indentor = indentor || '    ';\n\n  var rawResult = lexer(xml).map(function (element, i, arr) {\n    var value = element.value,\n        type = element.type;\n\n    if (type === 'ClosingTag') {\n      depth--;\n    }\n\n    var indentation = repeat(indentor, depth);\n    var line = indentation + value;\n\n    if (type === 'OpeningTag') {\n      depth++;\n    }\n\n    if (textNodesOnSameLine) {\n      // Lookbehind for [OpeningTag][Text][ClosingTag]\n      var oneBefore = arr[i - 1];\n      var twoBefore = arr[i - 2];\n\n      if (type === \"ClosingTag\" && oneBefore.type === \"Text\" && twoBefore.type === \"OpeningTag\") {\n        // collapse into a single line\n        line = '' + indentation + twoBefore.value + oneBefore.value + value;\n        indicesToRemove.push(i - 2, i - 1);\n      }\n    }\n\n    return line;\n  });\n\n  indicesToRemove.forEach(function (idx) {\n    return rawResult[idx] = null;\n  });\n\n  return rawResult.filter(function (val) {\n    return !!val;\n  }).join('\\n');\n};\n\nfunction lexer(xmlStr) {\n  var values = splitOnTags(xmlStr);\n  return values.map(function (value) {\n    return {\n      value: value,\n      type: getType(value)\n    };\n  });\n}\n\n// Helpers\n\nfunction getType(str) {\n  if (isClosingTag(str)) {\n    return 'ClosingTag';\n  }\n\n  if (isOpeningTag(str)) {\n    return 'OpeningTag';\n  }\n\n  if (isSelfClosingTag(str)) {\n    return 'SelfClosingTag';\n  }\n\n  return 'Text';\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}