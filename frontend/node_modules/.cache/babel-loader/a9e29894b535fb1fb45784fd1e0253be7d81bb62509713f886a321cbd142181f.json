{"ast":null,"code":"import { uniqWith, pathOr, last } from 'ramda';\nimport { toValue } from '@swagger-api/apidom-core';\nimport { OperationParametersElement } from '@swagger-api/apidom-ns-openapi-3-0';\nimport NormalizeStorage from \"./normalize-header-examples/NormalizeStorage.mjs\";\n/**\n * Inheritance of Parameter Objects.\n *\n * OpenAPI 3.1 specification excerpt that defines the inheritance behavior:\n *\n * A list of parameters that are applicable for this operation. If a parameter is already defined at the Path Item,\n * the new definition will override it but can never remove it. The list MUST NOT include duplicated parameters.\n * A unique parameter is defined by a combination of a name and location.\n *\n * NOTE: this plugin is idempotent\n */\n/* eslint-disable no-param-reassign */\nconst plugin = ({\n  storageField = 'x-normalized'\n} = {}) => toolbox => {\n  const {\n    predicates,\n    ancestorLineageToJSONPointer\n  } = toolbox;\n  /**\n   * Establishes identity between two Parameter Objects.\n   *\n   * {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#user-content-operationparameters}\n   */\n  const parameterEquals = (parameter1, parameter2) => {\n    if (!predicates.isParameterElement(parameter1)) return false;\n    if (!predicates.isParameterElement(parameter2)) return false;\n    if (!predicates.isStringElement(parameter1.name)) return false;\n    if (!predicates.isStringElement(parameter1.in)) return false;\n    if (!predicates.isStringElement(parameter2.name)) return false;\n    if (!predicates.isStringElement(parameter2.in)) return false;\n    return toValue(parameter1.name) === toValue(parameter2.name) && toValue(parameter1.in) === toValue(parameter2.in);\n  };\n  const pathItemParameters = [];\n  let storage;\n  return {\n    visitor: {\n      OpenApi3_1Element: {\n        enter(element) {\n          storage = new NormalizeStorage(element, storageField, 'parameters');\n        },\n        leave() {\n          storage = undefined;\n        }\n      },\n      PathItemElement: {\n        enter(pathItemElement, key, parent, path, ancestors) {\n          // skip visiting this Path Item\n          if (ancestors.some(predicates.isComponentsElement)) {\n            return;\n          }\n          const {\n            parameters\n          } = pathItemElement;\n          if (predicates.isArrayElement(parameters)) {\n            pathItemParameters.push([...parameters.content]);\n          } else {\n            pathItemParameters.push([]);\n          }\n        },\n        leave() {\n          pathItemParameters.pop();\n        }\n      },\n      OperationElement: {\n        leave(operationElement, key, parent, path, ancestors) {\n          const parentPathItemParameters = last(pathItemParameters);\n\n          // no Path Item Object parameters to inherit from\n          if (!Array.isArray(parentPathItemParameters) || parentPathItemParameters.length === 0) {\n            return;\n          }\n          const operationJSONPointer = ancestorLineageToJSONPointer([...ancestors, parent, operationElement]);\n\n          // skip visiting this Operation Object if it's already normalized\n          if (storage.includes(operationJSONPointer)) {\n            return;\n          }\n          const operationParameters = pathOr([], ['parameters', 'content'], operationElement);\n\n          // prefers the first item if two items compare equal based on the predicate\n          const mergedParameters = uniqWith(parameterEquals, [...operationParameters, ...parentPathItemParameters]);\n          operationElement.parameters = new OperationParametersElement(mergedParameters);\n          storage.append(operationJSONPointer);\n        }\n      }\n    }\n  };\n};\n/* eslint-enable */\n\nexport default plugin;","map":{"version":3,"names":["uniqWith","pathOr","last","toValue","OperationParametersElement","NormalizeStorage","plugin","storageField","toolbox","predicates","ancestorLineageToJSONPointer","parameterEquals","parameter1","parameter2","isParameterElement","isStringElement","name","in","pathItemParameters","storage","visitor","OpenApi3_1Element","enter","element","leave","undefined","PathItemElement","pathItemElement","key","parent","path","ancestors","some","isComponentsElement","parameters","isArrayElement","push","content","pop","OperationElement","operationElement","parentPathItemParameters","Array","isArray","length","operationJSONPointer","includes","operationParameters","mergedParameters","append"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-ns-openapi-3-1/es/refractor/plugins/normalize-parameters.mjs"],"sourcesContent":["import { uniqWith, pathOr, last } from 'ramda';\nimport { toValue } from '@swagger-api/apidom-core';\nimport { OperationParametersElement } from '@swagger-api/apidom-ns-openapi-3-0';\nimport NormalizeStorage from \"./normalize-header-examples/NormalizeStorage.mjs\";\n/**\n * Inheritance of Parameter Objects.\n *\n * OpenAPI 3.1 specification excerpt that defines the inheritance behavior:\n *\n * A list of parameters that are applicable for this operation. If a parameter is already defined at the Path Item,\n * the new definition will override it but can never remove it. The list MUST NOT include duplicated parameters.\n * A unique parameter is defined by a combination of a name and location.\n *\n * NOTE: this plugin is idempotent\n */\n/* eslint-disable no-param-reassign */\nconst plugin = ({\n  storageField = 'x-normalized'\n} = {}) => toolbox => {\n  const {\n    predicates,\n    ancestorLineageToJSONPointer\n  } = toolbox;\n  /**\n   * Establishes identity between two Parameter Objects.\n   *\n   * {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#user-content-operationparameters}\n   */\n  const parameterEquals = (parameter1, parameter2) => {\n    if (!predicates.isParameterElement(parameter1)) return false;\n    if (!predicates.isParameterElement(parameter2)) return false;\n    if (!predicates.isStringElement(parameter1.name)) return false;\n    if (!predicates.isStringElement(parameter1.in)) return false;\n    if (!predicates.isStringElement(parameter2.name)) return false;\n    if (!predicates.isStringElement(parameter2.in)) return false;\n    return toValue(parameter1.name) === toValue(parameter2.name) && toValue(parameter1.in) === toValue(parameter2.in);\n  };\n  const pathItemParameters = [];\n  let storage;\n  return {\n    visitor: {\n      OpenApi3_1Element: {\n        enter(element) {\n          storage = new NormalizeStorage(element, storageField, 'parameters');\n        },\n        leave() {\n          storage = undefined;\n        }\n      },\n      PathItemElement: {\n        enter(pathItemElement, key, parent, path, ancestors) {\n          // skip visiting this Path Item\n          if (ancestors.some(predicates.isComponentsElement)) {\n            return;\n          }\n          const {\n            parameters\n          } = pathItemElement;\n          if (predicates.isArrayElement(parameters)) {\n            pathItemParameters.push([...parameters.content]);\n          } else {\n            pathItemParameters.push([]);\n          }\n        },\n        leave() {\n          pathItemParameters.pop();\n        }\n      },\n      OperationElement: {\n        leave(operationElement, key, parent, path, ancestors) {\n          const parentPathItemParameters = last(pathItemParameters);\n\n          // no Path Item Object parameters to inherit from\n          if (!Array.isArray(parentPathItemParameters) || parentPathItemParameters.length === 0) {\n            return;\n          }\n          const operationJSONPointer = ancestorLineageToJSONPointer([...ancestors, parent, operationElement]);\n\n          // skip visiting this Operation Object if it's already normalized\n          if (storage.includes(operationJSONPointer)) {\n            return;\n          }\n          const operationParameters = pathOr([], ['parameters', 'content'], operationElement);\n\n          // prefers the first item if two items compare equal based on the predicate\n          const mergedParameters = uniqWith(parameterEquals, [...operationParameters, ...parentPathItemParameters]);\n          operationElement.parameters = new OperationParametersElement(mergedParameters);\n          storage.append(operationJSONPointer);\n        }\n      }\n    }\n  };\n};\n/* eslint-enable */\n\nexport default plugin;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}