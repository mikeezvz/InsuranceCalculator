{"ast":null,"code":"import { isFreelyNamed, generateAbsoluteRefPatches } from '../helpers.js';\nexport default {\n  key: 'allOf',\n  plugin: (val, key, fullPath, specmap, patch) => {\n    // Ignore replace patches created by $ref because the changes will\n    // occur in the original \"add\" patch and we don't want this plugin\n    // to redundantly processes those \"relace\" patches.\n    if (patch.meta && patch.meta.$$ref) {\n      return undefined;\n    }\n    const parent = fullPath.slice(0, -1);\n    if (isFreelyNamed(parent)) {\n      return undefined;\n    }\n    if (!Array.isArray(val)) {\n      const err = new TypeError('allOf must be an array');\n      err.fullPath = fullPath; // This is an array\n      return err;\n    }\n    let alreadyAddError = false;\n\n    // Find the original definition from the `patch.value` object\n    // Remove the `allOf` property so it doesn't get added to the result of the `allOf` plugin\n    let originalDefinitionObj = patch.value;\n    parent.forEach(part => {\n      if (!originalDefinitionObj) return; // bail out if we've lost sight of our target\n      originalDefinitionObj = originalDefinitionObj[part];\n    });\n    originalDefinitionObj = {\n      ...originalDefinitionObj\n    };\n\n    // when we've lost sight, interrupt prematurely\n    if (Object.keys(originalDefinitionObj).length === 0) {\n      return undefined;\n    }\n    delete originalDefinitionObj.allOf;\n    const patches = [];\n\n    // remove existing content\n    patches.push(specmap.replace(parent, {}));\n    val.forEach((toMerge, i) => {\n      if (!specmap.isObject(toMerge)) {\n        if (alreadyAddError) {\n          return null;\n        }\n        alreadyAddError = true;\n        const err = new TypeError('Elements in allOf must be objects');\n        err.fullPath = fullPath; // This is an array\n        return patches.push(err);\n      }\n\n      // Deeply merge the member's contents onto the parent location\n      patches.push(specmap.mergeDeep(parent, toMerge));\n\n      // Generate patches that migrate $ref values based on ContextTree information\n\n      // remove [\"allOf\"], which will not be present when these patches are applied\n      const collapsedFullPath = fullPath.slice(0, -1);\n      const absoluteRefPatches = generateAbsoluteRefPatches(toMerge, collapsedFullPath, {\n        getBaseUrlForNodePath: nodePath => specmap.getContext([...fullPath, i, ...nodePath]).baseDoc,\n        specmap\n      });\n      patches.push(...absoluteRefPatches);\n      return undefined;\n    });\n\n    // If there was an example in the original definition,\n    // keep it instead of merging with examples from other schema\n    if (originalDefinitionObj.example) {\n      // Delete other schema examples\n      patches.push(specmap.remove([].concat(parent, 'example')));\n    }\n    // Merge back the values from the original definition\n    patches.push(specmap.mergeDeep(parent, originalDefinitionObj));\n\n    // If there was not an original $$ref value, make sure to remove\n    // any $$ref value that may exist from the result of `allOf` merges\n    if (!originalDefinitionObj.$$ref) {\n      patches.push(specmap.remove([].concat(parent, '$$ref')));\n    }\n    return patches;\n  }\n};","map":{"version":3,"names":["isFreelyNamed","generateAbsoluteRefPatches","key","plugin","val","fullPath","specmap","patch","meta","$$ref","undefined","parent","slice","Array","isArray","err","TypeError","alreadyAddError","originalDefinitionObj","value","forEach","part","Object","keys","length","allOf","patches","push","replace","toMerge","i","isObject","mergeDeep","collapsedFullPath","absoluteRefPatches","getBaseUrlForNodePath","nodePath","getContext","baseDoc","example","remove","concat"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/resolver/specmap/lib/all-of.js"],"sourcesContent":["import { isFreelyNamed, generateAbsoluteRefPatches } from '../helpers.js';\nexport default {\n  key: 'allOf',\n  plugin: (val, key, fullPath, specmap, patch) => {\n    // Ignore replace patches created by $ref because the changes will\n    // occur in the original \"add\" patch and we don't want this plugin\n    // to redundantly processes those \"relace\" patches.\n    if (patch.meta && patch.meta.$$ref) {\n      return undefined;\n    }\n    const parent = fullPath.slice(0, -1);\n    if (isFreelyNamed(parent)) {\n      return undefined;\n    }\n    if (!Array.isArray(val)) {\n      const err = new TypeError('allOf must be an array');\n      err.fullPath = fullPath; // This is an array\n      return err;\n    }\n    let alreadyAddError = false;\n\n    // Find the original definition from the `patch.value` object\n    // Remove the `allOf` property so it doesn't get added to the result of the `allOf` plugin\n    let originalDefinitionObj = patch.value;\n    parent.forEach(part => {\n      if (!originalDefinitionObj) return; // bail out if we've lost sight of our target\n      originalDefinitionObj = originalDefinitionObj[part];\n    });\n    originalDefinitionObj = {\n      ...originalDefinitionObj\n    };\n\n    // when we've lost sight, interrupt prematurely\n    if (Object.keys(originalDefinitionObj).length === 0) {\n      return undefined;\n    }\n    delete originalDefinitionObj.allOf;\n    const patches = [];\n\n    // remove existing content\n    patches.push(specmap.replace(parent, {}));\n    val.forEach((toMerge, i) => {\n      if (!specmap.isObject(toMerge)) {\n        if (alreadyAddError) {\n          return null;\n        }\n        alreadyAddError = true;\n        const err = new TypeError('Elements in allOf must be objects');\n        err.fullPath = fullPath; // This is an array\n        return patches.push(err);\n      }\n\n      // Deeply merge the member's contents onto the parent location\n      patches.push(specmap.mergeDeep(parent, toMerge));\n\n      // Generate patches that migrate $ref values based on ContextTree information\n\n      // remove [\"allOf\"], which will not be present when these patches are applied\n      const collapsedFullPath = fullPath.slice(0, -1);\n      const absoluteRefPatches = generateAbsoluteRefPatches(toMerge, collapsedFullPath, {\n        getBaseUrlForNodePath: nodePath => specmap.getContext([...fullPath, i, ...nodePath]).baseDoc,\n        specmap\n      });\n      patches.push(...absoluteRefPatches);\n      return undefined;\n    });\n\n    // If there was an example in the original definition,\n    // keep it instead of merging with examples from other schema\n    if (originalDefinitionObj.example) {\n      // Delete other schema examples\n      patches.push(specmap.remove([].concat(parent, 'example')));\n    }\n    // Merge back the values from the original definition\n    patches.push(specmap.mergeDeep(parent, originalDefinitionObj));\n\n    // If there was not an original $$ref value, make sure to remove\n    // any $$ref value that may exist from the result of `allOf` merges\n    if (!originalDefinitionObj.$$ref) {\n      patches.push(specmap.remove([].concat(parent, '$$ref')));\n    }\n    return patches;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}