{"ast":null,"code":"import process from 'process';\nimport { pathSatisfies, propOr, pipe, test, last } from 'ramda';\nimport { isUndefined, replaceAll, isNotUndefined, trimCharsEnd } from 'ramda-adjunct';\n\n/**\n * SPDX-FileCopyrightText: Copyright (c) 2015 James Messinger\n *\n * SPDX-License-Identifier: MIT\n */\n\nconst isWindows = () => pathSatisfies(test(/^win/), ['platform'], process);\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n */\nexport const getProtocol = url => {\n  try {\n    const parsedUrl = new URL(url);\n    return trimCharsEnd(':', parsedUrl.protocol);\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n * Returns true if given URL has protocol.\n */\nexport const hasProtocol = pipe(getProtocol, isNotUndefined);\n\n/**\n * Returns the lower-cased file extension of the given URL,\n * or an empty string if it has no extension.\n */\nexport const getExtension = url => {\n  const lastDotPosition = url.lastIndexOf('.');\n  if (lastDotPosition >= 0) {\n    return url.substring(lastDotPosition).toLowerCase();\n  }\n  return '';\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n */\nexport const isFileSystemPath = uri => {\n  // @ts-ignore\n  if (process.browser) {\n    /**\n     * We're running in a browser, so assume that all paths are URLs.\n     * This way, even relative paths will be treated as URLs rather than as filesystem paths.\n     */\n    return false;\n  }\n  const protocol = getProtocol(uri);\n  return isUndefined(protocol) || protocol === 'file' || /^[a-zA-Z]$/.test(protocol);\n};\n\n/**\n * Determines whether the given URI is an HTTP(S) URL.\n */\nexport const isHttpUrl = url => {\n  const protocol = getProtocol(url);\n  return protocol === 'http' || protocol === 'https';\n};\n\n/**\n * Determines whether the given URI\n * @param uri\n */\nexport const isURI = uri => {\n  try {\n    return new URL(uri) && true;\n  } catch {\n    return false;\n  }\n};\n/**\n * Converts a URL to a local filesystem path.\n */\nexport const toFileSystemPath = (uri, options) => {\n  // RegExp patterns to URL-decode special characters for local filesystem paths\n  const urlDecodePatterns = [/%23/g, '#', /%24/g, '$', /%26/g, '&', /%2C/g, ',', /%40/g, '@'];\n  const keepFileProtocol = propOr(false, 'keepFileProtocol', options);\n  const isWindowsPredicate = propOr(isWindows, 'isWindows', options);\n\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  let path = decodeURI(uri);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substring(0, 7).toLowerCase() === 'file://';\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === '/' ? path.substring(8) : path.substring(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindowsPredicate() && path[1] === '/') {\n      path = `${path[0]}:${path.substring(1)}`;\n    }\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = `file:///${path}`;\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindowsPredicate() ? path : `/${path}`;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindowsPredicate() && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = replaceAll('/', '\\\\', path);\n\n    // Capitalize the drive letter\n    if (path.substring(1, 3) === ':\\\\') {\n      path = path[0].toUpperCase() + path.substring(1);\n    }\n  }\n  return path;\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where resolver is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n */\nexport const fromFileSystemPath = uri => {\n  const urlEncodePatterns = [/\\?/g, '%3F', /#/g, '%23'];\n  let path = uri;\n\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows()) {\n    path = path.replace(/\\\\/g, '/');\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n  return path;\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n */\nexport const getHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  if (hashIndex !== -1) {\n    return uri.substring(hashIndex);\n  }\n  return '#';\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n */\nexport const stripHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  let hashStrippedUri = uri;\n  if (hashIndex >= 0) {\n    hashStrippedUri = uri.substring(0, hashIndex);\n  }\n  return hashStrippedUri;\n};\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n */\nexport const cwd = () => {\n  // @ts-ignore\n  if (process.browser) {\n    return stripHash(globalThis.location.href);\n  }\n  const path = process.cwd();\n  const lastChar = last(path);\n  if (['/', '\\\\'].includes(lastChar)) {\n    return path;\n  }\n  return path + (isWindows() ? '\\\\' : '/');\n};\n\n/**\n *  Resolves a target URI relative to a base URI in a manner similar to that of a Web browser resolving an anchor tag HREF.\n */\nexport const resolve = (from, to) => {\n  const resolvedUrl = new URL(to, new URL(from, 'resolve://'));\n  if (resolvedUrl.protocol === 'resolve:') {\n    // `from` is a relative URL.\n    const {\n      pathname,\n      search,\n      hash\n    } = resolvedUrl;\n    return pathname + search + hash;\n  }\n  return resolvedUrl.toString();\n};\n\n/**\n * Sanitizes/Encodes URI to it's url encoded form.\n *\n * The functional will compensate with the usecase when\n * already sanitized URI is passed to it,\n * by first unsatizing it and then performing sanitization again.\n */\n\nexport const sanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return fromFileSystemPath(toFileSystemPath(uri));\n  }\n  try {\n    return new URL(uri).toString();\n  } catch {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI#encoding_for_ipv6\n    return encodeURI(decodeURI(uri)).replace(/%5B/g, '[').replace(/%5D/g, ']');\n  }\n};\n\n/**\n * Unsanitizes/Decodes URI to it's url encoded form.\n * This function already assumes that hash part of the URI\n * has been removed prior to transforming it to it's sanitized form.\n */\n\nexport const unsanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return toFileSystemPath(uri);\n  }\n  return decodeURI(uri);\n};","map":{"version":3,"names":["process","pathSatisfies","propOr","pipe","test","last","isUndefined","replaceAll","isNotUndefined","trimCharsEnd","isWindows","getProtocol","url","parsedUrl","URL","protocol","undefined","hasProtocol","getExtension","lastDotPosition","lastIndexOf","substring","toLowerCase","isFileSystemPath","uri","browser","isHttpUrl","isURI","toFileSystemPath","options","urlDecodePatterns","keepFileProtocol","isWindowsPredicate","path","decodeURI","i","length","replace","isFileUrl","toUpperCase","fromFileSystemPath","urlEncodePatterns","encodeURI","getHash","hashIndex","indexOf","stripHash","hashStrippedUri","cwd","globalThis","location","href","lastChar","includes","resolve","from","to","resolvedUrl","pathname","search","hash","toString","sanitize","unsanitize"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-reference/es/util/url.mjs"],"sourcesContent":["import process from 'process';\nimport { pathSatisfies, propOr, pipe, test, last } from 'ramda';\nimport { isUndefined, replaceAll, isNotUndefined, trimCharsEnd } from 'ramda-adjunct';\n\n/**\n * SPDX-FileCopyrightText: Copyright (c) 2015 James Messinger\n *\n * SPDX-License-Identifier: MIT\n */\n\nconst isWindows = () => pathSatisfies(test(/^win/), ['platform'], process);\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n */\nexport const getProtocol = url => {\n  try {\n    const parsedUrl = new URL(url);\n    return trimCharsEnd(':', parsedUrl.protocol);\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n * Returns true if given URL has protocol.\n */\nexport const hasProtocol = pipe(getProtocol, isNotUndefined);\n\n/**\n * Returns the lower-cased file extension of the given URL,\n * or an empty string if it has no extension.\n */\nexport const getExtension = url => {\n  const lastDotPosition = url.lastIndexOf('.');\n  if (lastDotPosition >= 0) {\n    return url.substring(lastDotPosition).toLowerCase();\n  }\n  return '';\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n */\nexport const isFileSystemPath = uri => {\n  // @ts-ignore\n  if (process.browser) {\n    /**\n     * We're running in a browser, so assume that all paths are URLs.\n     * This way, even relative paths will be treated as URLs rather than as filesystem paths.\n     */\n    return false;\n  }\n  const protocol = getProtocol(uri);\n  return isUndefined(protocol) || protocol === 'file' || /^[a-zA-Z]$/.test(protocol);\n};\n\n/**\n * Determines whether the given URI is an HTTP(S) URL.\n */\nexport const isHttpUrl = url => {\n  const protocol = getProtocol(url);\n  return protocol === 'http' || protocol === 'https';\n};\n\n/**\n * Determines whether the given URI\n * @param uri\n */\nexport const isURI = uri => {\n  try {\n    return new URL(uri) && true;\n  } catch {\n    return false;\n  }\n};\n/**\n * Converts a URL to a local filesystem path.\n */\nexport const toFileSystemPath = (uri, options) => {\n  // RegExp patterns to URL-decode special characters for local filesystem paths\n  const urlDecodePatterns = [/%23/g, '#', /%24/g, '$', /%26/g, '&', /%2C/g, ',', /%40/g, '@'];\n  const keepFileProtocol = propOr(false, 'keepFileProtocol', options);\n  const isWindowsPredicate = propOr(isWindows, 'isWindows', options);\n\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  let path = decodeURI(uri);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substring(0, 7).toLowerCase() === 'file://';\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === '/' ? path.substring(8) : path.substring(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindowsPredicate() && path[1] === '/') {\n      path = `${path[0]}:${path.substring(1)}`;\n    }\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = `file:///${path}`;\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindowsPredicate() ? path : `/${path}`;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindowsPredicate() && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = replaceAll('/', '\\\\', path);\n\n    // Capitalize the drive letter\n    if (path.substring(1, 3) === ':\\\\') {\n      path = path[0].toUpperCase() + path.substring(1);\n    }\n  }\n  return path;\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where resolver is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n */\nexport const fromFileSystemPath = uri => {\n  const urlEncodePatterns = [/\\?/g, '%3F', /#/g, '%23'];\n  let path = uri;\n\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows()) {\n    path = path.replace(/\\\\/g, '/');\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n  return path;\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n */\nexport const getHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  if (hashIndex !== -1) {\n    return uri.substring(hashIndex);\n  }\n  return '#';\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n */\nexport const stripHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  let hashStrippedUri = uri;\n  if (hashIndex >= 0) {\n    hashStrippedUri = uri.substring(0, hashIndex);\n  }\n  return hashStrippedUri;\n};\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n */\nexport const cwd = () => {\n  // @ts-ignore\n  if (process.browser) {\n    return stripHash(globalThis.location.href);\n  }\n  const path = process.cwd();\n  const lastChar = last(path);\n  if (['/', '\\\\'].includes(lastChar)) {\n    return path;\n  }\n  return path + (isWindows() ? '\\\\' : '/');\n};\n\n/**\n *  Resolves a target URI relative to a base URI in a manner similar to that of a Web browser resolving an anchor tag HREF.\n */\nexport const resolve = (from, to) => {\n  const resolvedUrl = new URL(to, new URL(from, 'resolve://'));\n  if (resolvedUrl.protocol === 'resolve:') {\n    // `from` is a relative URL.\n    const {\n      pathname,\n      search,\n      hash\n    } = resolvedUrl;\n    return pathname + search + hash;\n  }\n  return resolvedUrl.toString();\n};\n\n/**\n * Sanitizes/Encodes URI to it's url encoded form.\n *\n * The functional will compensate with the usecase when\n * already sanitized URI is passed to it,\n * by first unsatizing it and then performing sanitization again.\n */\n\nexport const sanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return fromFileSystemPath(toFileSystemPath(uri));\n  }\n  try {\n    return new URL(uri).toString();\n  } catch {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI#encoding_for_ipv6\n    return encodeURI(decodeURI(uri)).replace(/%5B/g, '[').replace(/%5D/g, ']');\n  }\n};\n\n/**\n * Unsanitizes/Decodes URI to it's url encoded form.\n * This function already assumes that hash part of the URI\n * has been removed prior to transforming it to it's sanitized form.\n */\n\nexport const unsanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return toFileSystemPath(uri);\n  }\n  return decodeURI(uri);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}