{"ast":null,"code":"import { isEmpty, propEq } from 'ramda';\nimport File from \"../File.mjs\";\nimport * as plugins from \"../util/plugins.mjs\";\nimport UnmatchedBundleStrategyError from \"../errors/UnmatchedBundleStrategyError.mjs\";\nimport BundleError from \"../errors/BundleError.mjs\";\nimport parse from \"../parse/index.mjs\";\nimport { merge as mergeOptions } from \"../options/util.mjs\";\nimport * as url from \"../util/url.mjs\";\n/**\n * Bundle a file with all its external references to a compound document.\n */\nconst bundle = async (uri, options) => {\n  const {\n    refSet\n  } = options.bundle;\n  const sanitizedURI = url.sanitize(uri);\n  const mergedOptions = mergeOptions(options, {\n    resolve: {\n      baseURI: sanitizedURI\n    }\n  });\n  let parseResult;\n\n  // if refSet was provided, use it to avoid unnecessary parsing\n  if (refSet !== null && refSet.has(sanitizedURI)) {\n    // @ts-ignore\n    ({\n      value: parseResult\n    } = refSet.find(propEq(sanitizedURI, 'uri')));\n  } else {\n    parseResult = await parse(uri, mergedOptions);\n  }\n  const file = new File({\n    uri: mergedOptions.resolve.baseURI,\n    parseResult,\n    mediaType: mergedOptions.parse.mediaType\n  });\n  const bundleStrategies = await plugins.filter('canBundle', [file, mergedOptions], mergedOptions.bundle.strategies);\n\n  // we couldn't find any bundle strategy for this File\n  if (isEmpty(bundleStrategies)) {\n    throw new UnmatchedBundleStrategyError(file.uri);\n  }\n  try {\n    const {\n      result\n    } = await plugins.run('bundle', [file, mergedOptions], bundleStrategies);\n    return result;\n  } catch (error) {\n    throw new BundleError(`Error while bundling file \"${file.uri}\"`, {\n      cause: error\n    });\n  }\n};\nexport default bundle;","map":{"version":3,"names":["isEmpty","propEq","File","plugins","UnmatchedBundleStrategyError","BundleError","parse","merge","mergeOptions","url","bundle","uri","options","refSet","sanitizedURI","sanitize","mergedOptions","resolve","baseURI","parseResult","has","value","find","file","mediaType","bundleStrategies","filter","strategies","result","run","error","cause"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-reference/es/bundle/index.mjs"],"sourcesContent":["import { isEmpty, propEq } from 'ramda';\nimport File from \"../File.mjs\";\nimport * as plugins from \"../util/plugins.mjs\";\nimport UnmatchedBundleStrategyError from \"../errors/UnmatchedBundleStrategyError.mjs\";\nimport BundleError from \"../errors/BundleError.mjs\";\nimport parse from \"../parse/index.mjs\";\nimport { merge as mergeOptions } from \"../options/util.mjs\";\nimport * as url from \"../util/url.mjs\";\n/**\n * Bundle a file with all its external references to a compound document.\n */\nconst bundle = async (uri, options) => {\n  const {\n    refSet\n  } = options.bundle;\n  const sanitizedURI = url.sanitize(uri);\n  const mergedOptions = mergeOptions(options, {\n    resolve: {\n      baseURI: sanitizedURI\n    }\n  });\n  let parseResult;\n\n  // if refSet was provided, use it to avoid unnecessary parsing\n  if (refSet !== null && refSet.has(sanitizedURI)) {\n    // @ts-ignore\n    ({\n      value: parseResult\n    } = refSet.find(propEq(sanitizedURI, 'uri')));\n  } else {\n    parseResult = await parse(uri, mergedOptions);\n  }\n  const file = new File({\n    uri: mergedOptions.resolve.baseURI,\n    parseResult,\n    mediaType: mergedOptions.parse.mediaType\n  });\n  const bundleStrategies = await plugins.filter('canBundle', [file, mergedOptions], mergedOptions.bundle.strategies);\n\n  // we couldn't find any bundle strategy for this File\n  if (isEmpty(bundleStrategies)) {\n    throw new UnmatchedBundleStrategyError(file.uri);\n  }\n  try {\n    const {\n      result\n    } = await plugins.run('bundle', [file, mergedOptions], bundleStrategies);\n    return result;\n  } catch (error) {\n    throw new BundleError(`Error while bundling file \"${file.uri}\"`, {\n      cause: error\n    });\n  }\n};\nexport default bundle;"],"mappings":"AAAA,SAASA,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACvC,OAAOC,IAAI,MAAM,aAAa;AAC9B,OAAO,KAAKC,OAAO,MAAM,qBAAqB;AAC9C,OAAOC,4BAA4B,MAAM,4CAA4C;AACrF,OAAOC,WAAW,MAAM,2BAA2B;AACnD,OAAOC,KAAK,MAAM,oBAAoB;AACtC,SAASC,KAAK,IAAIC,YAAY,QAAQ,qBAAqB;AAC3D,OAAO,KAAKC,GAAG,MAAM,iBAAiB;AACtC;AACA;AACA;AACA,MAAMC,MAAM,GAAG,MAAAA,CAAOC,GAAG,EAAEC,OAAO,KAAK;EACrC,MAAM;IACJC;EACF,CAAC,GAAGD,OAAO,CAACF,MAAM;EAClB,MAAMI,YAAY,GAAGL,GAAG,CAACM,QAAQ,CAACJ,GAAG,CAAC;EACtC,MAAMK,aAAa,GAAGR,YAAY,CAACI,OAAO,EAAE;IAC1CK,OAAO,EAAE;MACPC,OAAO,EAAEJ;IACX;EACF,CAAC,CAAC;EACF,IAAIK,WAAW;;EAEf;EACA,IAAIN,MAAM,KAAK,IAAI,IAAIA,MAAM,CAACO,GAAG,CAACN,YAAY,CAAC,EAAE;IAC/C;IACA,CAAC;MACCO,KAAK,EAAEF;IACT,CAAC,GAAGN,MAAM,CAACS,IAAI,CAACrB,MAAM,CAACa,YAAY,EAAE,KAAK,CAAC,CAAC;EAC9C,CAAC,MAAM;IACLK,WAAW,GAAG,MAAMb,KAAK,CAACK,GAAG,EAAEK,aAAa,CAAC;EAC/C;EACA,MAAMO,IAAI,GAAG,IAAIrB,IAAI,CAAC;IACpBS,GAAG,EAAEK,aAAa,CAACC,OAAO,CAACC,OAAO;IAClCC,WAAW;IACXK,SAAS,EAAER,aAAa,CAACV,KAAK,CAACkB;EACjC,CAAC,CAAC;EACF,MAAMC,gBAAgB,GAAG,MAAMtB,OAAO,CAACuB,MAAM,CAAC,WAAW,EAAE,CAACH,IAAI,EAAEP,aAAa,CAAC,EAAEA,aAAa,CAACN,MAAM,CAACiB,UAAU,CAAC;;EAElH;EACA,IAAI3B,OAAO,CAACyB,gBAAgB,CAAC,EAAE;IAC7B,MAAM,IAAIrB,4BAA4B,CAACmB,IAAI,CAACZ,GAAG,CAAC;EAClD;EACA,IAAI;IACF,MAAM;MACJiB;IACF,CAAC,GAAG,MAAMzB,OAAO,CAAC0B,GAAG,CAAC,QAAQ,EAAE,CAACN,IAAI,EAAEP,aAAa,CAAC,EAAES,gBAAgB,CAAC;IACxE,OAAOG,MAAM;EACf,CAAC,CAAC,OAAOE,KAAK,EAAE;IACd,MAAM,IAAIzB,WAAW,CAAC,8BAA8BkB,IAAI,CAACZ,GAAG,GAAG,EAAE;MAC/DoB,KAAK,EAAED;IACT,CAAC,CAAC;EACJ;AACF,CAAC;AACD,eAAepB,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}