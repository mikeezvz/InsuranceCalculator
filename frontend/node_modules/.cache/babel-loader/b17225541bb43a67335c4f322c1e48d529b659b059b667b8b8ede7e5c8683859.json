{"ast":null,"code":"/* eslint-disable camelcase */\nimport { createNamespace, visit, cloneDeep } from '@swagger-api/apidom-core';\nimport { ReferenceSet, Reference } from '@swagger-api/apidom-reference/configuration/empty';\nimport OpenAPI3_1DereferenceStrategy from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1';\nimport openApi3_1Namespace, { getNodeType, keyMap } from '@swagger-api/apidom-ns-openapi-3-1';\nimport RootVisitor from './visitors/root.js';\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\nclass OpenAPI3_1SwaggerClientDereferenceStrategy extends OpenAPI3_1DereferenceStrategy {\n  allowMetaPatches;\n  parameterMacro;\n  modelPropertyMacro;\n  mode;\n  ancestors;\n  constructor({\n    allowMetaPatches = false,\n    parameterMacro = null,\n    modelPropertyMacro = null,\n    mode = 'non-strict',\n    ancestors = [],\n    ...rest\n  } = {}) {\n    super({\n      ...rest\n    });\n    this.name = 'openapi-3-1-swagger-client';\n    this.allowMetaPatches = allowMetaPatches;\n    this.parameterMacro = parameterMacro;\n    this.modelPropertyMacro = modelPropertyMacro;\n    this.mode = mode;\n    this.ancestors = [...ancestors];\n  }\n  async dereference(file, options) {\n    var _options$dereference$;\n    const namespace = createNamespace(openApi3_1Namespace);\n    const immutableRefSet = (_options$dereference$ = options.dereference.refSet) !== null && _options$dereference$ !== void 0 ? _options$dereference$ : new ReferenceSet();\n    const mutableRefsSet = new ReferenceSet();\n    let refSet = immutableRefSet;\n    let reference;\n    if (!immutableRefSet.has(file.uri)) {\n      reference = new Reference({\n        uri: file.uri,\n        value: file.parseResult\n      });\n      immutableRefSet.add(reference);\n    } else {\n      // pre-computed refSet was provided as configuration option\n      reference = immutableRefSet.find(ref => ref.uri === file.uri);\n    }\n\n    /**\n     * Clone refSet due the dereferencing process being mutable.\n     * We don't want to mutate the original refSet and the references.\n     */\n    if (options.dereference.immutable) {\n      immutableRefSet.refs.map(ref => new Reference({\n        ...ref,\n        value: cloneDeep(ref.value)\n      })).forEach(ref => mutableRefsSet.add(ref));\n      reference = mutableRefsSet.find(ref => ref.uri === file.uri);\n      refSet = mutableRefsSet;\n    }\n    const rootVisitor = new RootVisitor({\n      reference,\n      namespace,\n      options,\n      allowMetaPatches: this.allowMetaPatches,\n      ancestors: this.ancestors,\n      modelPropertyMacro: this.modelPropertyMacro,\n      mode: this.mode,\n      parameterMacro: this.parameterMacro\n    });\n    const dereferencedElement = await visitAsync(refSet.rootRef.value, rootVisitor, {\n      keyMap,\n      nodeTypeGetter: getNodeType\n    });\n\n    /**\n     * If immutable option is set, replay refs from the refSet.\n     */\n    if (options.dereference.immutable) {\n      mutableRefsSet.refs.filter(ref => ref.uri.startsWith('immutable://')).map(ref => new Reference({\n        ...ref,\n        uri: ref.uri.replace(/^immutable:\\/\\//, '')\n      })).forEach(ref => immutableRefSet.add(ref));\n    }\n\n    /**\n     * Release all memory if this refSet was not provided as an configuration option.\n     * If provided as configuration option, then provider is responsible for cleanup.\n     */\n    if (options.dereference.refSet === null) {\n      immutableRefSet.clean();\n    }\n    mutableRefsSet.clean();\n    return dereferencedElement;\n  }\n}\nexport default OpenAPI3_1SwaggerClientDereferenceStrategy;\n/* eslint-enable camelcase */","map":{"version":3,"names":["createNamespace","visit","cloneDeep","ReferenceSet","Reference","OpenAPI3_1DereferenceStrategy","openApi3_1Namespace","getNodeType","keyMap","RootVisitor","visitAsync","Symbol","for","OpenAPI3_1SwaggerClientDereferenceStrategy","allowMetaPatches","parameterMacro","modelPropertyMacro","mode","ancestors","constructor","rest","name","dereference","file","options","_options$dereference$","namespace","immutableRefSet","refSet","mutableRefsSet","reference","has","uri","value","parseResult","add","find","ref","immutable","refs","map","forEach","rootVisitor","dereferencedElement","rootRef","nodeTypeGetter","filter","startsWith","replace","clean"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/index.js"],"sourcesContent":["/* eslint-disable camelcase */\nimport { createNamespace, visit, cloneDeep } from '@swagger-api/apidom-core';\nimport { ReferenceSet, Reference } from '@swagger-api/apidom-reference/configuration/empty';\nimport OpenAPI3_1DereferenceStrategy from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1';\nimport openApi3_1Namespace, { getNodeType, keyMap } from '@swagger-api/apidom-ns-openapi-3-1';\nimport RootVisitor from './visitors/root.js';\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\nclass OpenAPI3_1SwaggerClientDereferenceStrategy extends OpenAPI3_1DereferenceStrategy {\n  allowMetaPatches;\n  parameterMacro;\n  modelPropertyMacro;\n  mode;\n  ancestors;\n  constructor({\n    allowMetaPatches = false,\n    parameterMacro = null,\n    modelPropertyMacro = null,\n    mode = 'non-strict',\n    ancestors = [],\n    ...rest\n  } = {}) {\n    super({\n      ...rest\n    });\n    this.name = 'openapi-3-1-swagger-client';\n    this.allowMetaPatches = allowMetaPatches;\n    this.parameterMacro = parameterMacro;\n    this.modelPropertyMacro = modelPropertyMacro;\n    this.mode = mode;\n    this.ancestors = [...ancestors];\n  }\n  async dereference(file, options) {\n    var _options$dereference$;\n    const namespace = createNamespace(openApi3_1Namespace);\n    const immutableRefSet = (_options$dereference$ = options.dereference.refSet) !== null && _options$dereference$ !== void 0 ? _options$dereference$ : new ReferenceSet();\n    const mutableRefsSet = new ReferenceSet();\n    let refSet = immutableRefSet;\n    let reference;\n    if (!immutableRefSet.has(file.uri)) {\n      reference = new Reference({\n        uri: file.uri,\n        value: file.parseResult\n      });\n      immutableRefSet.add(reference);\n    } else {\n      // pre-computed refSet was provided as configuration option\n      reference = immutableRefSet.find(ref => ref.uri === file.uri);\n    }\n\n    /**\n     * Clone refSet due the dereferencing process being mutable.\n     * We don't want to mutate the original refSet and the references.\n     */\n    if (options.dereference.immutable) {\n      immutableRefSet.refs.map(ref => new Reference({\n        ...ref,\n        value: cloneDeep(ref.value)\n      })).forEach(ref => mutableRefsSet.add(ref));\n      reference = mutableRefsSet.find(ref => ref.uri === file.uri);\n      refSet = mutableRefsSet;\n    }\n    const rootVisitor = new RootVisitor({\n      reference,\n      namespace,\n      options,\n      allowMetaPatches: this.allowMetaPatches,\n      ancestors: this.ancestors,\n      modelPropertyMacro: this.modelPropertyMacro,\n      mode: this.mode,\n      parameterMacro: this.parameterMacro\n    });\n    const dereferencedElement = await visitAsync(refSet.rootRef.value, rootVisitor, {\n      keyMap,\n      nodeTypeGetter: getNodeType\n    });\n\n    /**\n     * If immutable option is set, replay refs from the refSet.\n     */\n    if (options.dereference.immutable) {\n      mutableRefsSet.refs.filter(ref => ref.uri.startsWith('immutable://')).map(ref => new Reference({\n        ...ref,\n        uri: ref.uri.replace(/^immutable:\\/\\//, '')\n      })).forEach(ref => immutableRefSet.add(ref));\n    }\n\n    /**\n     * Release all memory if this refSet was not provided as an configuration option.\n     * If provided as configuration option, then provider is responsible for cleanup.\n     */\n    if (options.dereference.refSet === null) {\n      immutableRefSet.clean();\n    }\n    mutableRefsSet.clean();\n    return dereferencedElement;\n  }\n}\nexport default OpenAPI3_1SwaggerClientDereferenceStrategy;\n/* eslint-enable camelcase */"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}