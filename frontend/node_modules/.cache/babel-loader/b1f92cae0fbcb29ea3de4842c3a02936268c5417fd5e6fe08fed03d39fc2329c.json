{"ast":null,"code":"// This function runs after the common function,\n// `src/execute/index.js#buildRequest`\nimport { isPlainObject } from 'ramda-adjunct';\nimport btoa from '../../helpers/btoa.node.js';\nexport default function buildRequest(options, req) {\n  const {\n    operation,\n    requestBody,\n    securities,\n    spec,\n    attachContentTypeForEmptyPayload\n  } = options;\n  let {\n    requestContentType\n  } = options;\n  req = applySecurities({\n    request: req,\n    securities,\n    operation,\n    spec\n  });\n  const requestBodyDef = operation.requestBody || {};\n  const requestBodyMediaTypes = Object.keys(requestBodyDef.content || {});\n  const isExplicitContentTypeValid = requestContentType && requestBodyMediaTypes.indexOf(requestContentType) > -1;\n\n  // for OAS3: set the Content-Type\n  if (requestBody || attachContentTypeForEmptyPayload) {\n    // does the passed requestContentType appear in the requestBody definition?\n\n    if (requestContentType && isExplicitContentTypeValid) {\n      req.headers['Content-Type'] = requestContentType;\n    } else if (!requestContentType) {\n      const firstMediaType = requestBodyMediaTypes[0];\n      if (firstMediaType) {\n        req.headers['Content-Type'] = firstMediaType;\n        requestContentType = firstMediaType;\n      }\n    }\n  } else if (requestContentType && isExplicitContentTypeValid) {\n    req.headers['Content-Type'] = requestContentType;\n  }\n  if (!options.responseContentType && operation.responses) {\n    const mediaTypes = Object.entries(operation.responses).filter(([key, value]) => {\n      const code = parseInt(key, 10);\n      return code >= 200 && code < 300 && isPlainObject(value.content);\n    }).reduce((acc, [, value]) => acc.concat(Object.keys(value.content)), []);\n    if (mediaTypes.length > 0) {\n      req.headers.accept = mediaTypes.join(', ');\n    }\n  }\n\n  // for OAS3: add requestBody to request\n  if (requestBody) {\n    if (requestContentType) {\n      if (requestBodyMediaTypes.indexOf(requestContentType) > -1) {\n        // only attach body if the requestBody has a definition for the\n        // contentType that has been explicitly set\n        if (requestContentType === 'application/x-www-form-urlencoded' || requestContentType === 'multipart/form-data') {\n          if (typeof requestBody === 'object') {\n            var _requestBodyDef$conte, _requestBodyDef$conte2;\n            const encoding = (_requestBodyDef$conte = (_requestBodyDef$conte2 = requestBodyDef.content[requestContentType]) === null || _requestBodyDef$conte2 === void 0 ? void 0 : _requestBodyDef$conte2.encoding) !== null && _requestBodyDef$conte !== void 0 ? _requestBodyDef$conte : {};\n            req.form = {};\n            Object.keys(requestBody).forEach(k => {\n              let value;\n              try {\n                value = JSON.parse(requestBody[k]);\n              } catch {\n                value = requestBody[k];\n              }\n              req.form[k] = {\n                value,\n                encoding: encoding[k] || {}\n              };\n            });\n          } else if (typeof requestBody === 'string') {\n            var _requestBodyDef$conte3, _requestBodyDef$conte4;\n            const encoding = (_requestBodyDef$conte3 = (_requestBodyDef$conte4 = requestBodyDef.content[requestContentType]) === null || _requestBodyDef$conte4 === void 0 ? void 0 : _requestBodyDef$conte4.encoding) !== null && _requestBodyDef$conte3 !== void 0 ? _requestBodyDef$conte3 : {};\n            try {\n              req.form = {};\n              const form = JSON.parse(requestBody);\n              Object.entries(form).forEach(([key, value]) => {\n                req.form[key] = {\n                  value,\n                  encoding: encoding[key] || {}\n                };\n              });\n            } catch {\n              req.form = requestBody;\n            }\n          } else {\n            req.form = requestBody;\n          }\n        } else {\n          req.body = requestBody;\n        }\n      }\n    } else {\n      req.body = requestBody;\n    }\n  }\n  return req;\n}\n\n// Add security values, to operations - that declare their need on them\n// Adapted from the Swagger2 implementation\nexport function applySecurities({\n  request,\n  securities = {},\n  operation = {},\n  spec\n}) {\n  var _spec$components;\n  const result = {\n    ...request\n  };\n  const {\n    authorized = {}\n  } = securities;\n  const security = operation.security || spec.security || [];\n  const isAuthorized = authorized && !!Object.keys(authorized).length;\n  const securityDef = (spec === null || spec === void 0 || (_spec$components = spec.components) === null || _spec$components === void 0 ? void 0 : _spec$components.securitySchemes) || {};\n  result.headers = result.headers || {};\n  result.query = result.query || {};\n  if (!Object.keys(securities).length || !isAuthorized || !security || Array.isArray(operation.security) && !operation.security.length) {\n    return request;\n  }\n  security.forEach(securityObj => {\n    Object.keys(securityObj).forEach(key => {\n      const auth = authorized[key];\n      const schema = securityDef[key];\n      if (!auth) {\n        return;\n      }\n      const value = auth.value || auth;\n      const {\n        type\n      } = schema;\n      if (auth) {\n        if (type === 'apiKey') {\n          if (schema.in === 'query') {\n            result.query[schema.name] = value;\n          }\n          if (schema.in === 'header') {\n            result.headers[schema.name] = value;\n          }\n          if (schema.in === 'cookie') {\n            result.cookies[schema.name] = value;\n          }\n        } else if (type === 'http') {\n          if (/^basic$/i.test(schema.scheme)) {\n            const username = value.username || '';\n            const password = value.password || '';\n            const encoded = btoa(`${username}:${password}`);\n            result.headers.Authorization = `Basic ${encoded}`;\n          }\n          if (/^bearer$/i.test(schema.scheme)) {\n            result.headers.Authorization = `Bearer ${value}`;\n          }\n        } else if (type === 'oauth2' || type === 'openIdConnect') {\n          const token = auth.token || {};\n          const tokenName = schema['x-tokenName'] || 'access_token';\n          const tokenValue = token[tokenName];\n          let tokenType = token.token_type;\n          if (!tokenType || tokenType.toLowerCase() === 'bearer') {\n            tokenType = 'Bearer';\n          }\n          result.headers.Authorization = `${tokenType} ${tokenValue}`;\n        }\n      }\n    });\n  });\n  return result;\n}","map":{"version":3,"names":["isPlainObject","btoa","buildRequest","options","req","operation","requestBody","securities","spec","attachContentTypeForEmptyPayload","requestContentType","applySecurities","request","requestBodyDef","requestBodyMediaTypes","Object","keys","content","isExplicitContentTypeValid","indexOf","headers","firstMediaType","responseContentType","responses","mediaTypes","entries","filter","key","value","code","parseInt","reduce","acc","concat","length","accept","join","_requestBodyDef$conte","_requestBodyDef$conte2","encoding","form","forEach","k","JSON","parse","_requestBodyDef$conte3","_requestBodyDef$conte4","body","_spec$components","result","authorized","security","isAuthorized","securityDef","components","securitySchemes","query","Array","isArray","securityObj","auth","schema","type","in","name","cookies","test","scheme","username","password","encoded","Authorization","token","tokenName","tokenValue","tokenType","token_type","toLowerCase"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/execute/oas3/build-request.js"],"sourcesContent":["// This function runs after the common function,\n// `src/execute/index.js#buildRequest`\nimport { isPlainObject } from 'ramda-adjunct';\nimport btoa from '../../helpers/btoa.node.js';\nexport default function buildRequest(options, req) {\n  const {\n    operation,\n    requestBody,\n    securities,\n    spec,\n    attachContentTypeForEmptyPayload\n  } = options;\n  let {\n    requestContentType\n  } = options;\n  req = applySecurities({\n    request: req,\n    securities,\n    operation,\n    spec\n  });\n  const requestBodyDef = operation.requestBody || {};\n  const requestBodyMediaTypes = Object.keys(requestBodyDef.content || {});\n  const isExplicitContentTypeValid = requestContentType && requestBodyMediaTypes.indexOf(requestContentType) > -1;\n\n  // for OAS3: set the Content-Type\n  if (requestBody || attachContentTypeForEmptyPayload) {\n    // does the passed requestContentType appear in the requestBody definition?\n\n    if (requestContentType && isExplicitContentTypeValid) {\n      req.headers['Content-Type'] = requestContentType;\n    } else if (!requestContentType) {\n      const firstMediaType = requestBodyMediaTypes[0];\n      if (firstMediaType) {\n        req.headers['Content-Type'] = firstMediaType;\n        requestContentType = firstMediaType;\n      }\n    }\n  } else if (requestContentType && isExplicitContentTypeValid) {\n    req.headers['Content-Type'] = requestContentType;\n  }\n  if (!options.responseContentType && operation.responses) {\n    const mediaTypes = Object.entries(operation.responses).filter(([key, value]) => {\n      const code = parseInt(key, 10);\n      return code >= 200 && code < 300 && isPlainObject(value.content);\n    }).reduce((acc, [, value]) => acc.concat(Object.keys(value.content)), []);\n    if (mediaTypes.length > 0) {\n      req.headers.accept = mediaTypes.join(', ');\n    }\n  }\n\n  // for OAS3: add requestBody to request\n  if (requestBody) {\n    if (requestContentType) {\n      if (requestBodyMediaTypes.indexOf(requestContentType) > -1) {\n        // only attach body if the requestBody has a definition for the\n        // contentType that has been explicitly set\n        if (requestContentType === 'application/x-www-form-urlencoded' || requestContentType === 'multipart/form-data') {\n          if (typeof requestBody === 'object') {\n            var _requestBodyDef$conte, _requestBodyDef$conte2;\n            const encoding = (_requestBodyDef$conte = (_requestBodyDef$conte2 = requestBodyDef.content[requestContentType]) === null || _requestBodyDef$conte2 === void 0 ? void 0 : _requestBodyDef$conte2.encoding) !== null && _requestBodyDef$conte !== void 0 ? _requestBodyDef$conte : {};\n            req.form = {};\n            Object.keys(requestBody).forEach(k => {\n              let value;\n              try {\n                value = JSON.parse(requestBody[k]);\n              } catch {\n                value = requestBody[k];\n              }\n              req.form[k] = {\n                value,\n                encoding: encoding[k] || {}\n              };\n            });\n          } else if (typeof requestBody === 'string') {\n            var _requestBodyDef$conte3, _requestBodyDef$conte4;\n            const encoding = (_requestBodyDef$conte3 = (_requestBodyDef$conte4 = requestBodyDef.content[requestContentType]) === null || _requestBodyDef$conte4 === void 0 ? void 0 : _requestBodyDef$conte4.encoding) !== null && _requestBodyDef$conte3 !== void 0 ? _requestBodyDef$conte3 : {};\n            try {\n              req.form = {};\n              const form = JSON.parse(requestBody);\n              Object.entries(form).forEach(([key, value]) => {\n                req.form[key] = {\n                  value,\n                  encoding: encoding[key] || {}\n                };\n              });\n            } catch {\n              req.form = requestBody;\n            }\n          } else {\n            req.form = requestBody;\n          }\n        } else {\n          req.body = requestBody;\n        }\n      }\n    } else {\n      req.body = requestBody;\n    }\n  }\n  return req;\n}\n\n// Add security values, to operations - that declare their need on them\n// Adapted from the Swagger2 implementation\nexport function applySecurities({\n  request,\n  securities = {},\n  operation = {},\n  spec\n}) {\n  var _spec$components;\n  const result = {\n    ...request\n  };\n  const {\n    authorized = {}\n  } = securities;\n  const security = operation.security || spec.security || [];\n  const isAuthorized = authorized && !!Object.keys(authorized).length;\n  const securityDef = (spec === null || spec === void 0 || (_spec$components = spec.components) === null || _spec$components === void 0 ? void 0 : _spec$components.securitySchemes) || {};\n  result.headers = result.headers || {};\n  result.query = result.query || {};\n  if (!Object.keys(securities).length || !isAuthorized || !security || Array.isArray(operation.security) && !operation.security.length) {\n    return request;\n  }\n  security.forEach(securityObj => {\n    Object.keys(securityObj).forEach(key => {\n      const auth = authorized[key];\n      const schema = securityDef[key];\n      if (!auth) {\n        return;\n      }\n      const value = auth.value || auth;\n      const {\n        type\n      } = schema;\n      if (auth) {\n        if (type === 'apiKey') {\n          if (schema.in === 'query') {\n            result.query[schema.name] = value;\n          }\n          if (schema.in === 'header') {\n            result.headers[schema.name] = value;\n          }\n          if (schema.in === 'cookie') {\n            result.cookies[schema.name] = value;\n          }\n        } else if (type === 'http') {\n          if (/^basic$/i.test(schema.scheme)) {\n            const username = value.username || '';\n            const password = value.password || '';\n            const encoded = btoa(`${username}:${password}`);\n            result.headers.Authorization = `Basic ${encoded}`;\n          }\n          if (/^bearer$/i.test(schema.scheme)) {\n            result.headers.Authorization = `Bearer ${value}`;\n          }\n        } else if (type === 'oauth2' || type === 'openIdConnect') {\n          const token = auth.token || {};\n          const tokenName = schema['x-tokenName'] || 'access_token';\n          const tokenValue = token[tokenName];\n          let tokenType = token.token_type;\n          if (!tokenType || tokenType.toLowerCase() === 'bearer') {\n            tokenType = 'Bearer';\n          }\n          result.headers.Authorization = `${tokenType} ${tokenValue}`;\n        }\n      }\n    });\n  });\n  return result;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}