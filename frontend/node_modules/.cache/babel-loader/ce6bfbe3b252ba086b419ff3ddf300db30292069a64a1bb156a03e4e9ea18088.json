{"ast":null,"code":"/* eslint-disable camelcase */\nimport { RefElement, isObjectElement, isPrimitiveElement, isStringElement, isMemberElement, IdentityManager, visit, includesClasses, toValue, cloneShallow, cloneDeep } from '@swagger-api/apidom-core';\nimport { ApiDOMError } from '@swagger-api/apidom-error';\nimport { isReferenceLikeElement, isReferenceElement, isBooleanJsonSchemaElement, isPathItemElement, isSchemaElement, ReferenceElement, PathItemElement, SchemaElement, getNodeType, keyMap } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { evaluate as jsonPointerEvaluate, uriToPointer } from '@swagger-api/apidom-json-pointer';\nimport { url, MaximumDereferenceDepthError, File } from '@swagger-api/apidom-reference/configuration/empty';\nimport { OpenAPI3_1DereferenceVisitor, resolveSchema$refField, maybeRefractToSchemaElement } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1';\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1/selectors/$anchor';\nimport { evaluate as uriEvaluate, EvaluationJsonSchemaUriError } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1/selectors/uri';\nimport toPath from '../utils/to-path.js';\nimport getRootCause from '../utils/get-root-cause.js';\nimport specMapMod from '../../../../../../specmap/lib/refs.js';\nimport SchemaRefError from '../errors/SchemaRefError.js';\nconst {\n  wrapError\n} = specMapMod;\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n// initialize element identity manager\nconst identityManager = new IdentityManager();\n\n// custom mutation replacer\nconst mutationReplacer = (newElement, oldElement, key, parent) => {\n  if (isMemberElement(parent)) {\n    parent.value = newElement; // eslint-disable-line no-param-reassign\n  } else if (Array.isArray(parent)) {\n    parent[key] = newElement; // eslint-disable-line no-param-reassign\n  }\n};\nclass OpenAPI3_1SwaggerClientDereferenceVisitor extends OpenAPI3_1DereferenceVisitor {\n  useCircularStructures;\n  allowMetaPatches;\n  basePath;\n  constructor({\n    allowMetaPatches = true,\n    useCircularStructures = false,\n    basePath = null,\n    ...rest\n  }) {\n    super(rest);\n    this.allowMetaPatches = allowMetaPatches;\n    this.useCircularStructures = useCircularStructures;\n    this.basePath = basePath;\n  }\n  async ReferenceElement(referencingElement, key, parent, path, ancestors, link) {\n    try {\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(referencingElement)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n      const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Reference Objects\n      if (!this.options.resolve.internal && isInternalReference) {\n        return false;\n      }\n      // ignore resolving external Reference Objects\n      if (!this.options.resolve.external && isExternalReference) {\n        return false;\n      }\n      const reference = await this.toReference(toValue(referencingElement.$ref));\n      const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n      this.indirections.push(referencingElement);\n      const jsonPointer = uriToPointer($refBaseURI);\n\n      // possibly non-semantic fragment\n      let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n      referencedElement.id = identityManager.identify(referencedElement);\n\n      // applying semantics to a fragment\n      if (isPrimitiveElement(referencedElement)) {\n        const referencedElementType = toValue(referencingElement.meta.get('referenced-element'));\n        const cacheKey = `${referencedElementType}-${toValue(identityManager.identify(referencedElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          referencedElement = this.refractCache.get(cacheKey);\n        } else if (isReferenceLikeElement(referencedElement)) {\n          // handling indirect references\n          referencedElement = ReferenceElement.refract(referencedElement);\n          referencedElement.setMetaProperty('referenced-element', referencedElementType);\n          this.refractCache.set(cacheKey, referencedElement);\n        } else {\n          // handling direct references\n          const ElementClass = this.namespace.getElementClass(referencedElementType);\n          referencedElement = ElementClass.refract(referencedElement);\n          this.refractCache.set(cacheKey, referencedElement);\n        }\n      }\n\n      // detect direct or indirect reference\n      if (referencingElement === referencedElement) {\n        throw new ApiDOMError('Recursive Reference Object detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer, _this$options$derefer2;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'reference',\n            uri: reference.uri,\n            $ref: toValue(referencingElement.$ref),\n            baseURI: $refBaseURI,\n            referencingElement\n          });\n          const replacer = (_this$options$derefer = (_this$options$derefer2 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer2 === void 0 ? void 0 : _this$options$derefer2.circularReplacer) !== null && _this$options$derefer !== void 0 ? _this$options$derefer : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(refElement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Reference Object. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isReferenceElement(referencedElement) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath;\n        // append referencing reference to ancestors lineage\n        directAncestors.add(referencingElement);\n        const visitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          refractCache: this.refractCache,\n          ancestors: ancestorsLineage,\n          allowMetaPatches: this.allowMetaPatches,\n          useCircularStructures: this.useCircularStructures,\n          basePath: (_this$basePath = this.basePath) !== null && _this$basePath !== void 0 ? _this$basePath : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing reference from ancestors lineage\n        directAncestors.delete(referencingElement);\n      }\n      this.indirections.pop();\n      const mergedElement = cloneShallow(referencedElement);\n\n      // annotate fragment with info about original Reference element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        description: toValue(referencingElement.description),\n        summary: toValue(referencingElement.summary)\n      });\n      // annotate fragment with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n      // override description and summary (outer has higher priority then inner)\n      if (isObjectElement(referencedElement)) {\n        if (referencingElement.hasKey('description') && 'description' in referencedElement) {\n          mergedElement.remove('description');\n          mergedElement.set('description', referencingElement.get('description'));\n        }\n        if (referencingElement.hasKey('summary') && 'summary' in referencedElement) {\n          mergedElement.remove('summary');\n          mergedElement.set('summary', referencingElement.get('summary'));\n        }\n      }\n\n      // apply meta patches\n      if (this.allowMetaPatches && isObjectElement(mergedElement)) {\n        // apply meta patch only when not already applied\n        if (!mergedElement.hasKey('$$ref')) {\n          const baseURI = url.resolve(retrievalURI, $refBaseURI);\n          mergedElement.set('$$ref', baseURI);\n        }\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(mergedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? mergedElement : false;\n    } catch (error) {\n      var _this$basePath2, _this$options$derefer3, _this$options$derefer4;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(referencingElement.$ref),\n        pointer: uriToPointer(toValue(referencingElement.$ref)),\n        fullPath: (_this$basePath2 = this.basePath) !== null && _this$basePath2 !== void 0 ? _this$basePath2 : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n      });\n      (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || (_this$options$derefer3 = _this$options$derefer3.errors) === null || _this$options$derefer3 === void 0 || (_this$options$derefer4 = _this$options$derefer3.push) === null || _this$options$derefer4 === void 0 || _this$options$derefer4.call(_this$options$derefer3, wrappedError);\n      return undefined;\n    }\n  }\n  async PathItemElement(pathItemElement, key, parent, path, ancestors, link) {\n    try {\n      // ignore PathItemElement without $ref field\n      if (!isStringElement(pathItemElement.$ref)) {\n        return undefined;\n      }\n\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(pathItemElement)) {\n        return false;\n      }\n\n      // skip already identified cycled Path Item Objects\n      if (includesClasses(['cycle'], pathItemElement.$ref)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n      const retrievalURI = this.toBaseURI(toValue(pathItemElement.$ref));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Path Item Elements\n      if (!this.options.resolve.internal && isInternalReference) {\n        return undefined;\n      }\n      // ignore resolving external Path Item Elements\n      if (!this.options.resolve.external && isExternalReference) {\n        return undefined;\n      }\n      const reference = await this.toReference(toValue(pathItemElement.$ref));\n      const $refBaseURI = url.resolve(retrievalURI, toValue(pathItemElement.$ref));\n      this.indirections.push(pathItemElement);\n      const jsonPointer = uriToPointer($refBaseURI);\n\n      // possibly non-semantic referenced element\n      let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n      referencedElement.id = identityManager.identify(referencedElement);\n\n      // applying semantics to a referenced element\n      if (isPrimitiveElement(referencedElement)) {\n        const cacheKey = `path-item-${toValue(identityManager.identify(referencedElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          referencedElement = this.refractCache.get(cacheKey);\n        } else {\n          referencedElement = PathItemElement.refract(referencedElement);\n          this.refractCache.set(cacheKey, referencedElement);\n        }\n      }\n\n      // detect direct or indirect reference\n      if (pathItemElement === referencedElement) {\n        throw new ApiDOMError('Recursive Path Item Object reference detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer5, _this$options$derefer6;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'path-item',\n            uri: reference.uri,\n            $ref: toValue(pathItemElement.$ref),\n            baseURI: $refBaseURI,\n            referencingElement: pathItemElement\n          });\n          const replacer = (_this$options$derefer5 = (_this$options$derefer6 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer6 === void 0 ? void 0 : _this$options$derefer6.circularReplacer) !== null && _this$options$derefer5 !== void 0 ? _this$options$derefer5 : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(refElement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Path Item Object with $ref field. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isPathItemElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath3;\n        // append referencing schema to ancestors lineage\n        directAncestors.add(pathItemElement);\n\n        // dive deep into the referenced element\n        const visitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          ancestors: ancestorsLineage,\n          allowMetaPatches: this.allowMetaPatches,\n          useCircularStructures: this.useCircularStructures,\n          basePath: (_this$basePath3 = this.basePath) !== null && _this$basePath3 !== void 0 ? _this$basePath3 : [...toPath([...ancestors, parent, pathItemElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing schema from ancestors lineage\n        directAncestors.delete(pathItemElement);\n      }\n      this.indirections.pop();\n\n      /**\n       * Creating a new version of Path Item by merging fields from referenced Path Item with referencing one.\n       */\n      if (isPathItemElement(referencedElement)) {\n        const mergedElement = new PathItemElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n        // existing keywords from referencing PathItemElement overrides ones from referenced element\n        pathItemElement.forEach((value, keyElement, item) => {\n          mergedElement.remove(toValue(keyElement));\n          mergedElement.content.push(item);\n        });\n        mergedElement.remove('$ref');\n\n        // annotate referenced element with info about original referencing element\n        mergedElement.setMetaProperty('ref-fields', {\n          $ref: toValue(pathItemElement.$ref)\n        });\n        // annotate referenced element with info about origin\n        mergedElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(pathItemElement)));\n\n        // apply meta patches\n        if (this.allowMetaPatches) {\n          // apply meta patch only when not already applied\n          if (typeof mergedElement.get('$$ref') === 'undefined') {\n            const baseURI = url.resolve(retrievalURI, $refBaseURI);\n            mergedElement.set('$$ref', baseURI);\n          }\n        }\n        referencedElement = mergedElement;\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(referencedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? referencedElement : undefined;\n    } catch (error) {\n      var _this$basePath4, _this$options$derefer7, _this$options$derefer8;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(pathItemElement.$ref),\n        pointer: uriToPointer(toValue(pathItemElement.$ref)),\n        fullPath: (_this$basePath4 = this.basePath) !== null && _this$basePath4 !== void 0 ? _this$basePath4 : [...toPath([...ancestors, parent, pathItemElement]), '$ref']\n      });\n      (_this$options$derefer7 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer7 === void 0 || (_this$options$derefer7 = _this$options$derefer7.errors) === null || _this$options$derefer7 === void 0 || (_this$options$derefer8 = _this$options$derefer7.push) === null || _this$options$derefer8 === void 0 || _this$options$derefer8.call(_this$options$derefer7, wrappedError);\n      return undefined;\n    }\n  }\n  async SchemaElement(referencingElement, key, parent, path, ancestors, link) {\n    try {\n      // skip current referencing schema as $ref keyword was not defined\n      if (!isStringElement(referencingElement.$ref)) {\n        // skip traversing this schema but traverse all it's child schemas\n        return undefined;\n      }\n\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(referencingElement)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n\n      // compute baseURI using rules around $id and $ref keywords\n      let reference = await this.toReference(url.unsanitize(this.reference.uri));\n      let {\n        uri: retrievalURI\n      } = reference;\n      const $refBaseURI = resolveSchema$refField(retrievalURI, referencingElement);\n      const $refBaseURIStrippedHash = url.stripHash($refBaseURI);\n      const file = new File({\n        uri: $refBaseURIStrippedHash\n      });\n      const isUnknownURI = !this.options.resolve.resolvers.some(r => r.canRead(file));\n      const isURL = !isUnknownURI;\n      let isInternalReference = url.stripHash(this.reference.uri) === $refBaseURI;\n      let isExternalReference = !isInternalReference;\n      this.indirections.push(referencingElement);\n\n      // determining reference, proper evaluation and selection mechanism\n      let referencedElement;\n      try {\n        if (isUnknownURI || isURL) {\n          // we're dealing with canonical URI or URL with possible fragment\n          retrievalURI = this.toBaseURI($refBaseURI);\n          const selector = $refBaseURI;\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = uriEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n        } else {\n          // we're assuming here that we're dealing with JSON Pointer here\n          retrievalURI = this.toBaseURI($refBaseURI);\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = uriToPointer($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = jsonPointerEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        }\n      } catch (error) {\n        /**\n         * No SchemaElement($id=URL) was not found, so we're going to try to resolve\n         * the URL and assume the returned response is a JSON Schema.\n         */\n        if (isURL && error instanceof EvaluationJsonSchemaUriError) {\n          if (isAnchor(uriToAnchor($refBaseURI))) {\n            // we're dealing with JSON Schema $anchor here\n            isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n            isExternalReference = !isInternalReference;\n\n            // ignore resolving internal Schema Objects\n            if (!this.options.resolve.internal && isInternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            // ignore resolving external Schema Objects\n            if (!this.options.resolve.external && isExternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n            const selector = uriToAnchor($refBaseURI);\n            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n            referencedElement = $anchorEvaluate(selector, referenceAsSchema);\n            referencedElement = maybeRefractToSchemaElement(referencedElement);\n            referencedElement.id = identityManager.identify(referencedElement);\n          } else {\n            // we're assuming here that we're dealing with JSON Pointer here\n            retrievalURI = this.toBaseURI(toValue($refBaseURI));\n            isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n            isExternalReference = !isInternalReference;\n\n            // ignore resolving internal Schema Objects\n            if (!this.options.resolve.internal && isInternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            // ignore resolving external Schema Objects\n            if (!this.options.resolve.external && isExternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n            const selector = uriToPointer($refBaseURI);\n            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n            referencedElement = jsonPointerEvaluate(selector, referenceAsSchema);\n            referencedElement = maybeRefractToSchemaElement(referencedElement);\n            referencedElement.id = identityManager.identify(referencedElement);\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      // detect direct or indirect reference\n      if (referencingElement === referencedElement) {\n        throw new ApiDOMError('Recursive Schema Object reference detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer9, _this$options$derefer10;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'json-schema',\n            uri: reference.uri,\n            $ref: toValue(referencingElement.$ref),\n            baseURI: url.resolve(retrievalURI, $refBaseURI),\n            referencingElement\n          });\n          const replacer = (_this$options$derefer9 = (_this$options$derefer10 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer10 === void 0 ? void 0 : _this$options$derefer10.circularReplacer) !== null && _this$options$derefer9 !== void 0 ? _this$options$derefer9 : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(replacement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Schema Object with $ref field. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isSchemaElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath5;\n        // append referencing schema to ancestors lineage\n        directAncestors.add(referencingElement);\n\n        // dive deep into the fragment\n        const mergeVisitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          useCircularStructures: this.useCircularStructures,\n          allowMetaPatches: this.allowMetaPatches,\n          ancestors: ancestorsLineage,\n          basePath: (_this$basePath5 = this.basePath) !== null && _this$basePath5 !== void 0 ? _this$basePath5 : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, mergeVisitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing schema from ancestors lineage\n        directAncestors.delete(referencingElement);\n      }\n      this.indirections.pop();\n      if (isBooleanJsonSchemaElement(referencedElement)) {\n        const booleanJsonSchemaElement = cloneDeep(referencedElement);\n        // annotate referenced element with info about original referencing element\n        booleanJsonSchemaElement.setMetaProperty('ref-fields', {\n          $ref: toValue(referencingElement.$ref)\n        });\n        // annotate referenced element with info about origin\n        booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n        link.replaceWith(booleanJsonSchemaElement, mutationReplacer);\n        return !parent ? booleanJsonSchemaElement : false;\n      }\n\n      /**\n       * Creating a new version of Schema Object by merging fields from referenced Schema Object with referencing one.\n       */\n      if (isSchemaElement(referencedElement)) {\n        // Schema Object - merge keywords from referenced schema with referencing schema\n        const mergedElement = new SchemaElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n        // existing keywords from referencing schema overrides ones from referenced schema\n        referencingElement.forEach((value, keyElement, item) => {\n          mergedElement.remove(toValue(keyElement));\n          mergedElement.content.push(item);\n        });\n        mergedElement.remove('$ref');\n        // annotate referenced element with info about original referencing element\n        mergedElement.setMetaProperty('ref-fields', {\n          $ref: toValue(referencingElement.$ref)\n        });\n        // annotate fragment with info about origin\n        mergedElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n        // allowMetaPatches option processing\n        if (this.allowMetaPatches) {\n          // apply meta patch only when not already applied\n          if (typeof mergedElement.get('$$ref') === 'undefined') {\n            const baseURI = url.resolve(retrievalURI, $refBaseURI);\n            mergedElement.set('$$ref', baseURI);\n          }\n        }\n        referencedElement = mergedElement;\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(referencedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? referencedElement : undefined;\n    } catch (error) {\n      var _this$basePath6, _this$options$derefer11, _this$options$derefer12;\n      const rootCause = getRootCause(error);\n      const wrappedError = new SchemaRefError(`Could not resolve reference: ${rootCause.message}`, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(referencingElement.$ref),\n        fullPath: (_this$basePath6 = this.basePath) !== null && _this$basePath6 !== void 0 ? _this$basePath6 : [...toPath([...ancestors, parent, referencingElement]), '$ref'],\n        cause: rootCause\n      });\n      (_this$options$derefer11 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer11 === void 0 || (_this$options$derefer11 = _this$options$derefer11.errors) === null || _this$options$derefer11 === void 0 || (_this$options$derefer12 = _this$options$derefer11.push) === null || _this$options$derefer12 === void 0 || _this$options$derefer12.call(_this$options$derefer11, wrappedError);\n      return undefined;\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async LinkElement() {\n    /**\n     * OpenApi3_1DereferenceVisitor is doing lookup of Operation Objects\n     * and assigns them to Link Object metadata. This is not needed in\n     * swagger-client context, so we're disabling it here.\n     */\n    return undefined;\n  }\n  async ExampleElement(exampleElement, key, parent, path, ancestors, link) {\n    try {\n      return await super.ExampleElement(exampleElement, key, parent, path, ancestors, link);\n    } catch (error) {\n      var _this$basePath7, _this$options$derefer13, _this$options$derefer14;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        externalValue: toValue(exampleElement.externalValue),\n        fullPath: (_this$basePath7 = this.basePath) !== null && _this$basePath7 !== void 0 ? _this$basePath7 : [...toPath([...ancestors, parent, exampleElement]), 'externalValue']\n      });\n      (_this$options$derefer13 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer13 === void 0 || (_this$options$derefer13 = _this$options$derefer13.errors) === null || _this$options$derefer13 === void 0 || (_this$options$derefer14 = _this$options$derefer13.push) === null || _this$options$derefer14 === void 0 || _this$options$derefer14.call(_this$options$derefer13, wrappedError);\n      return undefined;\n    }\n  }\n}\nexport default OpenAPI3_1SwaggerClientDereferenceVisitor;\n/* eslint-enable camelcase */","map":{"version":3,"names":["RefElement","isObjectElement","isPrimitiveElement","isStringElement","isMemberElement","IdentityManager","visit","includesClasses","toValue","cloneShallow","cloneDeep","ApiDOMError","isReferenceLikeElement","isReferenceElement","isBooleanJsonSchemaElement","isPathItemElement","isSchemaElement","ReferenceElement","PathItemElement","SchemaElement","getNodeType","keyMap","evaluate","jsonPointerEvaluate","uriToPointer","url","MaximumDereferenceDepthError","File","OpenAPI3_1DereferenceVisitor","resolveSchema$refField","maybeRefractToSchemaElement","isAnchor","uriToAnchor","$anchorEvaluate","uriEvaluate","EvaluationJsonSchemaUriError","toPath","getRootCause","specMapMod","SchemaRefError","wrapError","visitAsync","Symbol","for","identityManager","mutationReplacer","newElement","oldElement","key","parent","value","Array","isArray","OpenAPI3_1SwaggerClientDereferenceVisitor","useCircularStructures","allowMetaPatches","basePath","constructor","rest","referencingElement","path","ancestors","link","indirections","includes","ancestorsLineage","directAncestors","toAncestorLineage","retrievalURI","toBaseURI","$ref","isInternalReference","stripHash","reference","uri","isExternalReference","options","resolve","internal","external","toReference","$refBaseURI","push","jsonPointer","referencedElement","result","id","identify","referencedElementType","meta","get","cacheKey","refractCache","has","refract","setMetaProperty","set","ElementClass","namespace","getElementClass","length","dereference","maxDepth","refSet","circular","_this$options$derefer","_this$options$derefer2","refElement","type","baseURI","replacer","strategyOpts","circularReplacer","replacement","replaceWith","isNonRootDocument","rootRef","shouldDetectCircular","includesCycle","_this$basePath","add","visitor","nodeTypeGetter","delete","pop","mergedElement","description","summary","hasKey","remove","error","_this$basePath2","_this$options$derefer3","_this$options$derefer4","rootCause","wrappedError","baseDoc","pointer","fullPath","dereferenceOpts","errors","call","undefined","pathItemElement","_this$options$derefer5","_this$options$derefer6","_this$basePath3","content","attributes","forEach","keyElement","item","_this$basePath4","_this$options$derefer7","_this$options$derefer8","unsanitize","$refBaseURIStrippedHash","file","isUnknownURI","resolvers","some","r","canRead","isURL","selector","referenceAsSchema","_this$options$derefer9","_this$options$derefer10","_this$basePath5","mergeVisitor","booleanJsonSchemaElement","_this$basePath6","_this$options$derefer11","_this$options$derefer12","message","cause","LinkElement","ExampleElement","exampleElement","_this$basePath7","_this$options$derefer13","_this$options$derefer14","externalValue"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/visitors/dereference.js"],"sourcesContent":["/* eslint-disable camelcase */\nimport { RefElement, isObjectElement, isPrimitiveElement, isStringElement, isMemberElement, IdentityManager, visit, includesClasses, toValue, cloneShallow, cloneDeep } from '@swagger-api/apidom-core';\nimport { ApiDOMError } from '@swagger-api/apidom-error';\nimport { isReferenceLikeElement, isReferenceElement, isBooleanJsonSchemaElement, isPathItemElement, isSchemaElement, ReferenceElement, PathItemElement, SchemaElement, getNodeType, keyMap } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { evaluate as jsonPointerEvaluate, uriToPointer } from '@swagger-api/apidom-json-pointer';\nimport { url, MaximumDereferenceDepthError, File } from '@swagger-api/apidom-reference/configuration/empty';\nimport { OpenAPI3_1DereferenceVisitor, resolveSchema$refField, maybeRefractToSchemaElement } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1';\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1/selectors/$anchor';\nimport { evaluate as uriEvaluate, EvaluationJsonSchemaUriError } from '@swagger-api/apidom-reference/dereference/strategies/openapi-3-1/selectors/uri';\nimport toPath from '../utils/to-path.js';\nimport getRootCause from '../utils/get-root-cause.js';\nimport specMapMod from '../../../../../../specmap/lib/refs.js';\nimport SchemaRefError from '../errors/SchemaRefError.js';\nconst {\n  wrapError\n} = specMapMod;\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n// initialize element identity manager\nconst identityManager = new IdentityManager();\n\n// custom mutation replacer\nconst mutationReplacer = (newElement, oldElement, key, parent) => {\n  if (isMemberElement(parent)) {\n    parent.value = newElement; // eslint-disable-line no-param-reassign\n  } else if (Array.isArray(parent)) {\n    parent[key] = newElement; // eslint-disable-line no-param-reassign\n  }\n};\nclass OpenAPI3_1SwaggerClientDereferenceVisitor extends OpenAPI3_1DereferenceVisitor {\n  useCircularStructures;\n  allowMetaPatches;\n  basePath;\n  constructor({\n    allowMetaPatches = true,\n    useCircularStructures = false,\n    basePath = null,\n    ...rest\n  }) {\n    super(rest);\n    this.allowMetaPatches = allowMetaPatches;\n    this.useCircularStructures = useCircularStructures;\n    this.basePath = basePath;\n  }\n  async ReferenceElement(referencingElement, key, parent, path, ancestors, link) {\n    try {\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(referencingElement)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n      const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Reference Objects\n      if (!this.options.resolve.internal && isInternalReference) {\n        return false;\n      }\n      // ignore resolving external Reference Objects\n      if (!this.options.resolve.external && isExternalReference) {\n        return false;\n      }\n      const reference = await this.toReference(toValue(referencingElement.$ref));\n      const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n      this.indirections.push(referencingElement);\n      const jsonPointer = uriToPointer($refBaseURI);\n\n      // possibly non-semantic fragment\n      let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n      referencedElement.id = identityManager.identify(referencedElement);\n\n      // applying semantics to a fragment\n      if (isPrimitiveElement(referencedElement)) {\n        const referencedElementType = toValue(referencingElement.meta.get('referenced-element'));\n        const cacheKey = `${referencedElementType}-${toValue(identityManager.identify(referencedElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          referencedElement = this.refractCache.get(cacheKey);\n        } else if (isReferenceLikeElement(referencedElement)) {\n          // handling indirect references\n          referencedElement = ReferenceElement.refract(referencedElement);\n          referencedElement.setMetaProperty('referenced-element', referencedElementType);\n          this.refractCache.set(cacheKey, referencedElement);\n        } else {\n          // handling direct references\n          const ElementClass = this.namespace.getElementClass(referencedElementType);\n          referencedElement = ElementClass.refract(referencedElement);\n          this.refractCache.set(cacheKey, referencedElement);\n        }\n      }\n\n      // detect direct or indirect reference\n      if (referencingElement === referencedElement) {\n        throw new ApiDOMError('Recursive Reference Object detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer, _this$options$derefer2;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'reference',\n            uri: reference.uri,\n            $ref: toValue(referencingElement.$ref),\n            baseURI: $refBaseURI,\n            referencingElement\n          });\n          const replacer = (_this$options$derefer = (_this$options$derefer2 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer2 === void 0 ? void 0 : _this$options$derefer2.circularReplacer) !== null && _this$options$derefer !== void 0 ? _this$options$derefer : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(refElement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Reference Object. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isReferenceElement(referencedElement) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath;\n        // append referencing reference to ancestors lineage\n        directAncestors.add(referencingElement);\n        const visitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          refractCache: this.refractCache,\n          ancestors: ancestorsLineage,\n          allowMetaPatches: this.allowMetaPatches,\n          useCircularStructures: this.useCircularStructures,\n          basePath: (_this$basePath = this.basePath) !== null && _this$basePath !== void 0 ? _this$basePath : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing reference from ancestors lineage\n        directAncestors.delete(referencingElement);\n      }\n      this.indirections.pop();\n      const mergedElement = cloneShallow(referencedElement);\n\n      // annotate fragment with info about original Reference element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        description: toValue(referencingElement.description),\n        summary: toValue(referencingElement.summary)\n      });\n      // annotate fragment with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n      // override description and summary (outer has higher priority then inner)\n      if (isObjectElement(referencedElement)) {\n        if (referencingElement.hasKey('description') && 'description' in referencedElement) {\n          mergedElement.remove('description');\n          mergedElement.set('description', referencingElement.get('description'));\n        }\n        if (referencingElement.hasKey('summary') && 'summary' in referencedElement) {\n          mergedElement.remove('summary');\n          mergedElement.set('summary', referencingElement.get('summary'));\n        }\n      }\n\n      // apply meta patches\n      if (this.allowMetaPatches && isObjectElement(mergedElement)) {\n        // apply meta patch only when not already applied\n        if (!mergedElement.hasKey('$$ref')) {\n          const baseURI = url.resolve(retrievalURI, $refBaseURI);\n          mergedElement.set('$$ref', baseURI);\n        }\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(mergedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? mergedElement : false;\n    } catch (error) {\n      var _this$basePath2, _this$options$derefer3, _this$options$derefer4;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(referencingElement.$ref),\n        pointer: uriToPointer(toValue(referencingElement.$ref)),\n        fullPath: (_this$basePath2 = this.basePath) !== null && _this$basePath2 !== void 0 ? _this$basePath2 : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n      });\n      (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || (_this$options$derefer3 = _this$options$derefer3.errors) === null || _this$options$derefer3 === void 0 || (_this$options$derefer4 = _this$options$derefer3.push) === null || _this$options$derefer4 === void 0 || _this$options$derefer4.call(_this$options$derefer3, wrappedError);\n      return undefined;\n    }\n  }\n  async PathItemElement(pathItemElement, key, parent, path, ancestors, link) {\n    try {\n      // ignore PathItemElement without $ref field\n      if (!isStringElement(pathItemElement.$ref)) {\n        return undefined;\n      }\n\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(pathItemElement)) {\n        return false;\n      }\n\n      // skip already identified cycled Path Item Objects\n      if (includesClasses(['cycle'], pathItemElement.$ref)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n      const retrievalURI = this.toBaseURI(toValue(pathItemElement.$ref));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Path Item Elements\n      if (!this.options.resolve.internal && isInternalReference) {\n        return undefined;\n      }\n      // ignore resolving external Path Item Elements\n      if (!this.options.resolve.external && isExternalReference) {\n        return undefined;\n      }\n      const reference = await this.toReference(toValue(pathItemElement.$ref));\n      const $refBaseURI = url.resolve(retrievalURI, toValue(pathItemElement.$ref));\n      this.indirections.push(pathItemElement);\n      const jsonPointer = uriToPointer($refBaseURI);\n\n      // possibly non-semantic referenced element\n      let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);\n      referencedElement.id = identityManager.identify(referencedElement);\n\n      // applying semantics to a referenced element\n      if (isPrimitiveElement(referencedElement)) {\n        const cacheKey = `path-item-${toValue(identityManager.identify(referencedElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          referencedElement = this.refractCache.get(cacheKey);\n        } else {\n          referencedElement = PathItemElement.refract(referencedElement);\n          this.refractCache.set(cacheKey, referencedElement);\n        }\n      }\n\n      // detect direct or indirect reference\n      if (pathItemElement === referencedElement) {\n        throw new ApiDOMError('Recursive Path Item Object reference detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer5, _this$options$derefer6;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'path-item',\n            uri: reference.uri,\n            $ref: toValue(pathItemElement.$ref),\n            baseURI: $refBaseURI,\n            referencingElement: pathItemElement\n          });\n          const replacer = (_this$options$derefer5 = (_this$options$derefer6 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer6 === void 0 ? void 0 : _this$options$derefer6.circularReplacer) !== null && _this$options$derefer5 !== void 0 ? _this$options$derefer5 : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(refElement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Path Item Object with $ref field. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isPathItemElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath3;\n        // append referencing schema to ancestors lineage\n        directAncestors.add(pathItemElement);\n\n        // dive deep into the referenced element\n        const visitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          ancestors: ancestorsLineage,\n          allowMetaPatches: this.allowMetaPatches,\n          useCircularStructures: this.useCircularStructures,\n          basePath: (_this$basePath3 = this.basePath) !== null && _this$basePath3 !== void 0 ? _this$basePath3 : [...toPath([...ancestors, parent, pathItemElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, visitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing schema from ancestors lineage\n        directAncestors.delete(pathItemElement);\n      }\n      this.indirections.pop();\n\n      /**\n       * Creating a new version of Path Item by merging fields from referenced Path Item with referencing one.\n       */\n      if (isPathItemElement(referencedElement)) {\n        const mergedElement = new PathItemElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n        // existing keywords from referencing PathItemElement overrides ones from referenced element\n        pathItemElement.forEach((value, keyElement, item) => {\n          mergedElement.remove(toValue(keyElement));\n          mergedElement.content.push(item);\n        });\n        mergedElement.remove('$ref');\n\n        // annotate referenced element with info about original referencing element\n        mergedElement.setMetaProperty('ref-fields', {\n          $ref: toValue(pathItemElement.$ref)\n        });\n        // annotate referenced element with info about origin\n        mergedElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(pathItemElement)));\n\n        // apply meta patches\n        if (this.allowMetaPatches) {\n          // apply meta patch only when not already applied\n          if (typeof mergedElement.get('$$ref') === 'undefined') {\n            const baseURI = url.resolve(retrievalURI, $refBaseURI);\n            mergedElement.set('$$ref', baseURI);\n          }\n        }\n        referencedElement = mergedElement;\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(referencedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? referencedElement : undefined;\n    } catch (error) {\n      var _this$basePath4, _this$options$derefer7, _this$options$derefer8;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(pathItemElement.$ref),\n        pointer: uriToPointer(toValue(pathItemElement.$ref)),\n        fullPath: (_this$basePath4 = this.basePath) !== null && _this$basePath4 !== void 0 ? _this$basePath4 : [...toPath([...ancestors, parent, pathItemElement]), '$ref']\n      });\n      (_this$options$derefer7 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer7 === void 0 || (_this$options$derefer7 = _this$options$derefer7.errors) === null || _this$options$derefer7 === void 0 || (_this$options$derefer8 = _this$options$derefer7.push) === null || _this$options$derefer8 === void 0 || _this$options$derefer8.call(_this$options$derefer7, wrappedError);\n      return undefined;\n    }\n  }\n  async SchemaElement(referencingElement, key, parent, path, ancestors, link) {\n    try {\n      // skip current referencing schema as $ref keyword was not defined\n      if (!isStringElement(referencingElement.$ref)) {\n        // skip traversing this schema but traverse all it's child schemas\n        return undefined;\n      }\n\n      // skip current referencing element as it's already been access\n      if (this.indirections.includes(referencingElement)) {\n        return false;\n      }\n      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n\n      // compute baseURI using rules around $id and $ref keywords\n      let reference = await this.toReference(url.unsanitize(this.reference.uri));\n      let {\n        uri: retrievalURI\n      } = reference;\n      const $refBaseURI = resolveSchema$refField(retrievalURI, referencingElement);\n      const $refBaseURIStrippedHash = url.stripHash($refBaseURI);\n      const file = new File({\n        uri: $refBaseURIStrippedHash\n      });\n      const isUnknownURI = !this.options.resolve.resolvers.some(r => r.canRead(file));\n      const isURL = !isUnknownURI;\n      let isInternalReference = url.stripHash(this.reference.uri) === $refBaseURI;\n      let isExternalReference = !isInternalReference;\n      this.indirections.push(referencingElement);\n\n      // determining reference, proper evaluation and selection mechanism\n      let referencedElement;\n      try {\n        if (isUnknownURI || isURL) {\n          // we're dealing with canonical URI or URL with possible fragment\n          retrievalURI = this.toBaseURI($refBaseURI);\n          const selector = $refBaseURI;\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = uriEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n        } else {\n          // we're assuming here that we're dealing with JSON Pointer here\n          retrievalURI = this.toBaseURI($refBaseURI);\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = uriToPointer($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = jsonPointerEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        }\n      } catch (error) {\n        /**\n         * No SchemaElement($id=URL) was not found, so we're going to try to resolve\n         * the URL and assume the returned response is a JSON Schema.\n         */\n        if (isURL && error instanceof EvaluationJsonSchemaUriError) {\n          if (isAnchor(uriToAnchor($refBaseURI))) {\n            // we're dealing with JSON Schema $anchor here\n            isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n            isExternalReference = !isInternalReference;\n\n            // ignore resolving internal Schema Objects\n            if (!this.options.resolve.internal && isInternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            // ignore resolving external Schema Objects\n            if (!this.options.resolve.external && isExternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n            const selector = uriToAnchor($refBaseURI);\n            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n            referencedElement = $anchorEvaluate(selector, referenceAsSchema);\n            referencedElement = maybeRefractToSchemaElement(referencedElement);\n            referencedElement.id = identityManager.identify(referencedElement);\n          } else {\n            // we're assuming here that we're dealing with JSON Pointer here\n            retrievalURI = this.toBaseURI(toValue($refBaseURI));\n            isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n            isExternalReference = !isInternalReference;\n\n            // ignore resolving internal Schema Objects\n            if (!this.options.resolve.internal && isInternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            // ignore resolving external Schema Objects\n            if (!this.options.resolve.external && isExternalReference) {\n              // skip traversing this schema element but traverse all it's child elements\n              return undefined;\n            }\n            reference = await this.toReference(url.unsanitize($refBaseURI));\n            const selector = uriToPointer($refBaseURI);\n            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n            referencedElement = jsonPointerEvaluate(selector, referenceAsSchema);\n            referencedElement = maybeRefractToSchemaElement(referencedElement);\n            referencedElement.id = identityManager.identify(referencedElement);\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      // detect direct or indirect reference\n      if (referencingElement === referencedElement) {\n        throw new ApiDOMError('Recursive Schema Object reference detected');\n      }\n\n      // detect maximum depth of dereferencing\n      if (this.indirections.length > this.options.dereference.maxDepth) {\n        throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n      }\n\n      // detect second deep dive into the same fragment and avoid it\n      if (ancestorsLineage.includes(referencedElement)) {\n        reference.refSet.circular = true;\n        if (this.options.dereference.circular === 'error') {\n          throw new ApiDOMError('Circular reference detected');\n        } else if (this.options.dereference.circular === 'replace') {\n          var _this$options$derefer9, _this$options$derefer10;\n          const refElement = new RefElement(referencedElement.id, {\n            type: 'json-schema',\n            uri: reference.uri,\n            $ref: toValue(referencingElement.$ref),\n            baseURI: url.resolve(retrievalURI, $refBaseURI),\n            referencingElement\n          });\n          const replacer = (_this$options$derefer9 = (_this$options$derefer10 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer10 === void 0 ? void 0 : _this$options$derefer10.circularReplacer) !== null && _this$options$derefer9 !== void 0 ? _this$options$derefer9 : this.options.dereference.circularReplacer;\n          const replacement = replacer(refElement);\n          link.replaceWith(replacement, mutationReplacer);\n          return !parent ? replacement : false;\n        }\n      }\n\n      /**\n       * Dive deep into the fragment.\n       *\n       * Cases to consider:\n       *  1. We're crossing document boundary\n       *  2. Fragment is from non-root document\n       *  3. Fragment is a Schema Object with $ref field. We need to follow it to get the eventual value\n       *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n       */\n      const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n      const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n      if ((isExternalReference || isNonRootDocument || isSchemaElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n        var _this$basePath5;\n        // append referencing schema to ancestors lineage\n        directAncestors.add(referencingElement);\n\n        // dive deep into the fragment\n        const mergeVisitor = new OpenAPI3_1SwaggerClientDereferenceVisitor({\n          reference,\n          namespace: this.namespace,\n          indirections: [...this.indirections],\n          options: this.options,\n          useCircularStructures: this.useCircularStructures,\n          allowMetaPatches: this.allowMetaPatches,\n          ancestors: ancestorsLineage,\n          basePath: (_this$basePath5 = this.basePath) !== null && _this$basePath5 !== void 0 ? _this$basePath5 : [...toPath([...ancestors, parent, referencingElement]), '$ref']\n        });\n        referencedElement = await visitAsync(referencedElement, mergeVisitor, {\n          keyMap,\n          nodeTypeGetter: getNodeType\n        });\n\n        // remove referencing schema from ancestors lineage\n        directAncestors.delete(referencingElement);\n      }\n      this.indirections.pop();\n      if (isBooleanJsonSchemaElement(referencedElement)) {\n        const booleanJsonSchemaElement = cloneDeep(referencedElement);\n        // annotate referenced element with info about original referencing element\n        booleanJsonSchemaElement.setMetaProperty('ref-fields', {\n          $ref: toValue(referencingElement.$ref)\n        });\n        // annotate referenced element with info about origin\n        booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n        link.replaceWith(booleanJsonSchemaElement, mutationReplacer);\n        return !parent ? booleanJsonSchemaElement : false;\n      }\n\n      /**\n       * Creating a new version of Schema Object by merging fields from referenced Schema Object with referencing one.\n       */\n      if (isSchemaElement(referencedElement)) {\n        // Schema Object - merge keywords from referenced schema with referencing schema\n        const mergedElement = new SchemaElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n        // existing keywords from referencing schema overrides ones from referenced schema\n        referencingElement.forEach((value, keyElement, item) => {\n          mergedElement.remove(toValue(keyElement));\n          mergedElement.content.push(item);\n        });\n        mergedElement.remove('$ref');\n        // annotate referenced element with info about original referencing element\n        mergedElement.setMetaProperty('ref-fields', {\n          $ref: toValue(referencingElement.$ref)\n        });\n        // annotate fragment with info about origin\n        mergedElement.setMetaProperty('ref-origin', reference.uri);\n        // annotate fragment with info about referencing element\n        mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n        // allowMetaPatches option processing\n        if (this.allowMetaPatches) {\n          // apply meta patch only when not already applied\n          if (typeof mergedElement.get('$$ref') === 'undefined') {\n            const baseURI = url.resolve(retrievalURI, $refBaseURI);\n            mergedElement.set('$$ref', baseURI);\n          }\n        }\n        referencedElement = mergedElement;\n      }\n\n      /**\n       * Transclude referencing element with merged referenced element.\n       */\n      link.replaceWith(referencedElement, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? referencedElement : undefined;\n    } catch (error) {\n      var _this$basePath6, _this$options$derefer11, _this$options$derefer12;\n      const rootCause = getRootCause(error);\n      const wrappedError = new SchemaRefError(`Could not resolve reference: ${rootCause.message}`, {\n        baseDoc: this.reference.uri,\n        $ref: toValue(referencingElement.$ref),\n        fullPath: (_this$basePath6 = this.basePath) !== null && _this$basePath6 !== void 0 ? _this$basePath6 : [...toPath([...ancestors, parent, referencingElement]), '$ref'],\n        cause: rootCause\n      });\n      (_this$options$derefer11 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer11 === void 0 || (_this$options$derefer11 = _this$options$derefer11.errors) === null || _this$options$derefer11 === void 0 || (_this$options$derefer12 = _this$options$derefer11.push) === null || _this$options$derefer12 === void 0 || _this$options$derefer12.call(_this$options$derefer11, wrappedError);\n      return undefined;\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async LinkElement() {\n    /**\n     * OpenApi3_1DereferenceVisitor is doing lookup of Operation Objects\n     * and assigns them to Link Object metadata. This is not needed in\n     * swagger-client context, so we're disabling it here.\n     */\n    return undefined;\n  }\n  async ExampleElement(exampleElement, key, parent, path, ancestors, link) {\n    try {\n      return await super.ExampleElement(exampleElement, key, parent, path, ancestors, link);\n    } catch (error) {\n      var _this$basePath7, _this$options$derefer13, _this$options$derefer14;\n      const rootCause = getRootCause(error);\n      const wrappedError = wrapError(rootCause, {\n        baseDoc: this.reference.uri,\n        externalValue: toValue(exampleElement.externalValue),\n        fullPath: (_this$basePath7 = this.basePath) !== null && _this$basePath7 !== void 0 ? _this$basePath7 : [...toPath([...ancestors, parent, exampleElement]), 'externalValue']\n      });\n      (_this$options$derefer13 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer13 === void 0 || (_this$options$derefer13 = _this$options$derefer13.errors) === null || _this$options$derefer13 === void 0 || (_this$options$derefer14 = _this$options$derefer13.push) === null || _this$options$derefer14 === void 0 || _this$options$derefer14.call(_this$options$derefer13, wrappedError);\n      return undefined;\n    }\n  }\n}\nexport default OpenAPI3_1SwaggerClientDereferenceVisitor;\n/* eslint-enable camelcase */"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}