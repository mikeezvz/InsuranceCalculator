{"ast":null,"code":"import { isEmpty } from 'ramda';\nimport * as url from \"../util/url.mjs\";\nimport File from \"../File.mjs\";\nimport * as plugins from \"../util/plugins.mjs\";\nimport ParseError from \"../errors/ParseError.mjs\";\nimport UnmatchedResolverError from \"../errors/UnmatchedResolverError.mjs\";\nimport { readFile } from \"../resolve/util.mjs\";\n/**\n * Parses the given file's contents, using the configured parser plugins.\n */\nconst parseFile = async (file, options) => {\n  const optsBoundParsers = options.parse.parsers.map(parser => {\n    const clonedParser = Object.create(parser);\n    return Object.assign(clonedParser, options.parse.parserOpts);\n  });\n  const parsers = await plugins.filter('canParse', [file, options], optsBoundParsers);\n\n  // we couldn't find any parser for this File\n  if (isEmpty(parsers)) {\n    throw new UnmatchedResolverError(file.uri);\n  }\n  try {\n    const {\n      plugin,\n      result\n    } = await plugins.run('parse', [file, options], parsers);\n\n    // empty files handling\n    if (!plugin.allowEmpty && result.isEmpty) {\n      return Promise.reject(new ParseError(`Error while parsing file \"${file.uri}\". File is empty.`));\n    }\n    return result;\n  } catch (error) {\n    throw new ParseError(`Error while parsing file \"${file.uri}\"`, {\n      cause: error\n    });\n  }\n};\n\n/**\n * Parses a file into ApiDOM.\n */\nconst parse = async (uri, options) => {\n  /**\n   * If the path is a filesystem path, then convert it to a URL.\n   *\n   * NOTE: According to the JSON Reference spec, these should already be URLs,\n   * but, in practice, many people use local filesystem paths instead.\n   * So we're being generous here and doing the conversion automatically.\n   * This is not intended to be a 100% bulletproof solution.\n   * If it doesn't work for your use-case, then use a URL instead.\n   */\n  const file = new File({\n    uri: url.sanitize(url.stripHash(uri)),\n    mediaType: options.parse.mediaType\n  });\n  const data = await readFile(file, options);\n  return parseFile(new File({\n    ...file,\n    data\n  }), options);\n};\nexport default parse;","map":{"version":3,"names":["isEmpty","url","File","plugins","ParseError","UnmatchedResolverError","readFile","parseFile","file","options","optsBoundParsers","parse","parsers","map","parser","clonedParser","Object","create","assign","parserOpts","filter","uri","plugin","result","run","allowEmpty","Promise","reject","error","cause","sanitize","stripHash","mediaType","data"],"sources":["/home/mikezvz/Documents/GitHub/InsuranceCalculator/frontend/node_modules/@swagger-api/apidom-reference/es/parse/index.mjs"],"sourcesContent":["import { isEmpty } from 'ramda';\nimport * as url from \"../util/url.mjs\";\nimport File from \"../File.mjs\";\nimport * as plugins from \"../util/plugins.mjs\";\nimport ParseError from \"../errors/ParseError.mjs\";\nimport UnmatchedResolverError from \"../errors/UnmatchedResolverError.mjs\";\nimport { readFile } from \"../resolve/util.mjs\";\n/**\n * Parses the given file's contents, using the configured parser plugins.\n */\nconst parseFile = async (file, options) => {\n  const optsBoundParsers = options.parse.parsers.map(parser => {\n    const clonedParser = Object.create(parser);\n    return Object.assign(clonedParser, options.parse.parserOpts);\n  });\n  const parsers = await plugins.filter('canParse', [file, options], optsBoundParsers);\n\n  // we couldn't find any parser for this File\n  if (isEmpty(parsers)) {\n    throw new UnmatchedResolverError(file.uri);\n  }\n  try {\n    const {\n      plugin,\n      result\n    } = await plugins.run('parse', [file, options], parsers);\n\n    // empty files handling\n    if (!plugin.allowEmpty && result.isEmpty) {\n      return Promise.reject(new ParseError(`Error while parsing file \"${file.uri}\". File is empty.`));\n    }\n    return result;\n  } catch (error) {\n    throw new ParseError(`Error while parsing file \"${file.uri}\"`, {\n      cause: error\n    });\n  }\n};\n\n/**\n * Parses a file into ApiDOM.\n */\nconst parse = async (uri, options) => {\n  /**\n   * If the path is a filesystem path, then convert it to a URL.\n   *\n   * NOTE: According to the JSON Reference spec, these should already be URLs,\n   * but, in practice, many people use local filesystem paths instead.\n   * So we're being generous here and doing the conversion automatically.\n   * This is not intended to be a 100% bulletproof solution.\n   * If it doesn't work for your use-case, then use a URL instead.\n   */\n  const file = new File({\n    uri: url.sanitize(url.stripHash(uri)),\n    mediaType: options.parse.mediaType\n  });\n  const data = await readFile(file, options);\n  return parseFile(new File({\n    ...file,\n    data\n  }), options);\n};\nexport default parse;"],"mappings":"AAAA,SAASA,OAAO,QAAQ,OAAO;AAC/B,OAAO,KAAKC,GAAG,MAAM,iBAAiB;AACtC,OAAOC,IAAI,MAAM,aAAa;AAC9B,OAAO,KAAKC,OAAO,MAAM,qBAAqB;AAC9C,OAAOC,UAAU,MAAM,0BAA0B;AACjD,OAAOC,sBAAsB,MAAM,sCAAsC;AACzE,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C;AACA;AACA;AACA,MAAMC,SAAS,GAAG,MAAAA,CAAOC,IAAI,EAAEC,OAAO,KAAK;EACzC,MAAMC,gBAAgB,GAAGD,OAAO,CAACE,KAAK,CAACC,OAAO,CAACC,GAAG,CAACC,MAAM,IAAI;IAC3D,MAAMC,YAAY,GAAGC,MAAM,CAACC,MAAM,CAACH,MAAM,CAAC;IAC1C,OAAOE,MAAM,CAACE,MAAM,CAACH,YAAY,EAAEN,OAAO,CAACE,KAAK,CAACQ,UAAU,CAAC;EAC9D,CAAC,CAAC;EACF,MAAMP,OAAO,GAAG,MAAMT,OAAO,CAACiB,MAAM,CAAC,UAAU,EAAE,CAACZ,IAAI,EAAEC,OAAO,CAAC,EAAEC,gBAAgB,CAAC;;EAEnF;EACA,IAAIV,OAAO,CAACY,OAAO,CAAC,EAAE;IACpB,MAAM,IAAIP,sBAAsB,CAACG,IAAI,CAACa,GAAG,CAAC;EAC5C;EACA,IAAI;IACF,MAAM;MACJC,MAAM;MACNC;IACF,CAAC,GAAG,MAAMpB,OAAO,CAACqB,GAAG,CAAC,OAAO,EAAE,CAAChB,IAAI,EAAEC,OAAO,CAAC,EAAEG,OAAO,CAAC;;IAExD;IACA,IAAI,CAACU,MAAM,CAACG,UAAU,IAAIF,MAAM,CAACvB,OAAO,EAAE;MACxC,OAAO0B,OAAO,CAACC,MAAM,CAAC,IAAIvB,UAAU,CAAC,6BAA6BI,IAAI,CAACa,GAAG,mBAAmB,CAAC,CAAC;IACjG;IACA,OAAOE,MAAM;EACf,CAAC,CAAC,OAAOK,KAAK,EAAE;IACd,MAAM,IAAIxB,UAAU,CAAC,6BAA6BI,IAAI,CAACa,GAAG,GAAG,EAAE;MAC7DQ,KAAK,EAAED;IACT,CAAC,CAAC;EACJ;AACF,CAAC;;AAED;AACA;AACA;AACA,MAAMjB,KAAK,GAAG,MAAAA,CAAOU,GAAG,EAAEZ,OAAO,KAAK;EACpC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMD,IAAI,GAAG,IAAIN,IAAI,CAAC;IACpBmB,GAAG,EAAEpB,GAAG,CAAC6B,QAAQ,CAAC7B,GAAG,CAAC8B,SAAS,CAACV,GAAG,CAAC,CAAC;IACrCW,SAAS,EAAEvB,OAAO,CAACE,KAAK,CAACqB;EAC3B,CAAC,CAAC;EACF,MAAMC,IAAI,GAAG,MAAM3B,QAAQ,CAACE,IAAI,EAAEC,OAAO,CAAC;EAC1C,OAAOF,SAAS,CAAC,IAAIL,IAAI,CAAC;IACxB,GAAGM,IAAI;IACPyB;EACF,CAAC,CAAC,EAAExB,OAAO,CAAC;AACd,CAAC;AACD,eAAeE,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}